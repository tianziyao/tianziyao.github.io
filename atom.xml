<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iSTian&#39;notes</title>
  <subtitle>Quick notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-10-14T11:33:10.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>iSTian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CocoaPods错误 - googlesource timed out</title>
    <link href="http://yoursite.com/2016/10/14/CocoaPods%E9%94%99%E8%AF%AF%20-%20googlesource%20timed%20out/"/>
    <id>http://yoursite.com/2016/10/14/CocoaPods错误 - googlesource timed out/</id>
    <published>2016-10-13T18:24:00.000Z</published>
    <updated>2016-10-14T11:33:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>安装 libwebp 时提示如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Failed to connect to chromium.googlesource.com port 443: Operation timed out</div></pre></td></tr></table></figure>
<p>虽然已经科学上网，直接打开网页无碍，但是 CocoaPods 谷歌源还是超时，请教老司机答曰：可能出在 hosts 上。于是找了一下 host 翻墙的方法，成功解决。</p>
<p>我使用的 host 是下面这个：</p>
<p><a href="https://raw.githubusercontent.com/racaljk/hosts/master/hosts" target="_blank" rel="external">https://raw.githubusercontent.com/racaljk/hosts/master/hosts</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装 libwebp 时提示如下错误：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=
    
    </summary>
    
      <category term="CocoaPods错误" scheme="http://yoursite.com/categories/CocoaPods%E9%94%99%E8%AF%AF/"/>
    
    
      <category term="CocoaPods错误" scheme="http://yoursite.com/tags/CocoaPods%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>【转载】Swift算法 - 基本语法与技巧</title>
    <link href="http://yoursite.com/2016/10/14/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Swift%E7%AE%97%E6%B3%95%20-%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2016/10/14/【转载】Swift算法 - 基本语法与技巧/</id>
    <published>2016-10-13T18:24:00.000Z</published>
    <updated>2016-10-13T17:47:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Swift 是苹果新推出的编程语言，也是苹果首个开源语言。相比于原来的 Objective-C，Swift 要更轻便和灵活。笔者最近使用 Swift 实践了大量的算法（绝大部分是硅谷各大公司的面试题），将心得体会总结于下。此文并不是纯粹讨论 Swift 如何实现某一个具体的算法或者数据结构，如冒泡排序、深度优先遍历，或是树和栈，而是总结归纳一些 Swift 常用的语法和技巧，以便大家在解决面试题中使用。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(chars:[Character],  p: Int, q: Int)</span></span> &#123;</div><div class="line">  <span class="keyword">var</span> temp = chars[p]</div><div class="line">  chars[p] = chars[q]</div><div class="line">  chars[q] = temp</div><div class="line">&#125;</div><div class="line"><span class="comment">// Assume array is a character array and it has enough elements</span></div><div class="line"><span class="built_in">swap</span>(array, p: <span class="number">0</span>, q: <span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>上面代码实现了一个非常简单的功能，就是交换一个数组中的两个值。乍一看非常正确，实际上存在以下几个问题。</p>
<ol>
<li>在第一个参数前应该加上 <strong>inout </strong>关键字。因为在 Swift 中，struct 都是按值传递，class 是按引用传递；数组和字典都是 struct。所以要改变原来的 chars 数组，在其前部加入 inout 关键字，表示是按引用传递。</li>
<li>p 和 q 之前应该加入下划线。Swift 默认函数的第一个参数是局部（local）变量，而后续参数都是外部（external）变量，外部变量必须声明。如果在 p 和 q 前加上下划线，则在调用函数时无需声明外部变量，这样调用起来更简便。</li>
<li>temp 前的 var 应该改为 <strong>let</strong>。let 用于声明常量（constant），var 用于声明变量（variable）。swap 函数中，temp 并未进行修改，所以应当视为常量，用let来声明。</li>
</ol>
<blockquote>
<p>除原作者以上写出的 3 点问题之外，在我编译时，也有几个方面值得记录下来：</p>
<p>swap 是自带的方法，API 文档描述如下：</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**我的笔记*/</span></div><div class="line"><span class="comment">/// Exchange the values of `a` and `b`.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">/// - Precondition: `a` and `b` do not alias each other.</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">swap</span>&lt;T&gt;<span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> T, <span class="number">_</span> b: <span class="keyword">inout</span> T)</span></span></div></pre></td></tr></table></figure>
<blockquote>
<p>系统提供的 swap 方法和我们自定义的方法使用略有不同，可以说更加简洁一些：</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**我的笔记*/</span></div><div class="line"><span class="built_in">swap</span>(&amp;chars[<span class="number">0</span>], &amp;chars[<span class="number">1</span>])</div></pre></td></tr></table></figure>
<blockquote>
<p>在我看到自定义 swap 方法时，最先想到的是在方法内部修改传入参数，需要使用 var 进行描述，而在 Swift 3 中，var 关键字被取消，<strong>强制要求我们使用 inout 关键字</strong>，当然我们也可以在方法内部创建一个新的变量：</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**我的笔记*/</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(chars: [String], <span class="number">_</span> p: Int, <span class="number">_</span> q: Int)</span></span> -&gt; [<span class="type">String</span>] &#123;</div><div class="line">    <span class="keyword">var</span> chars = chars</div><div class="line">    <span class="keyword">let</span> temp = chars[p]</div><div class="line">    chars[p] = chars[q]</div><div class="line">    chars[q] = temp</div><div class="line">    <span class="keyword">return</span> chars</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>但这样处理是交换新的变量，而传入的 chars 是不会被修改的，因此在我们需要一份新的拷贝时，也可以使用这种方式。</p>
</blockquote>
   <a id="more"></a>
<p>修改后的代码为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(chars: <span class="keyword">inout</span> [String], <span class="number">_</span> p: Int, <span class="number">_</span> q: Int)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> temp = chars[p]</div><div class="line">    chars[p] = chars[q]</div><div class="line">    chars[q] = temp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> chars = [<span class="string">"a"</span>,<span class="string">"b"</span>]</div><div class="line"><span class="built_in">swap</span>(chars: &amp;chars, <span class="number">0</span>, <span class="number">1</span>)</div><div class="line">chars   <span class="comment">//["b", "a"]</span></div></pre></td></tr></table></figure>
<p>再来看一段代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">toZero</span><span class="params">(x: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">  <span class="keyword">while</span> x &gt; <span class="number">0</span> &#123;</div><div class="line">    x -= <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> x</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里在 <code>x -= 1</code> 处会报错。原因是函数中所有的参数是常量（let），是不可以修改的。解决的方法是在函数中写上 <code>var x = x</code>，之后就可以对 x 进行修改了。</p>
<blockquote>
<p>这里所犯的错误和上面类似，同样，如果我们需要对原值进行修改，使用 inout，如果需要得到一份拷贝，就使用 var。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**我的笔记*/</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">toZero</span><span class="params">(x: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">var</span> x = x</div><div class="line">    <span class="keyword">while</span> x &gt; <span class="number">0</span> &#123;</div><div class="line">        x -= <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> x</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">toZero</span><span class="params">(x: <span class="keyword">inout</span> Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">while</span> x &gt; <span class="number">0</span> &#123;</div><div class="line">        x -= <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> x</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> num = <span class="number">10</span></div><div class="line"><span class="keyword">var</span> x = toZero(x: num)  <span class="comment">//0</span></div><div class="line">num                     <span class="comment">//10</span></div><div class="line">x = toZero(x: &amp;num)     <span class="comment">//0</span></div><div class="line">num                     <span class="comment">//0</span></div></pre></td></tr></table></figure>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>Swift 循环分为 for 和 while 两种，注意他们的结构跟传统的 Java, C / C++ 有很大区别，笔者将其总结如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Assume names is an array holds enough Strings</span></div><div class="line"><span class="comment">// for loop</span></div><div class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names &#123; &#125;</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ... names.<span class="built_in">count</span> - <span class="number">1</span> &#123; &#125;</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; names.<span class="built_in">count</span> &#123; &#125;</div><div class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span> ..&lt; names.<span class="built_in">count</span> &#123; &#125;</div><div class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names.<span class="built_in">reverse</span>() &#123; &#125;</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>.<span class="built_in">stride</span>(through: names.<span class="built_in">count</span> - <span class="number">1</span>, by <span class="number">2</span>) &#123; &#125;</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>.<span class="built_in">stride</span>(to: names.<span class="built_in">count</span>, by: <span class="number">2</span>) &#123; &#125;</div><div class="line"></div><div class="line"><span class="comment">// while loop</span></div><div class="line"><span class="keyword">var</span> i = <span class="number">0</span></div><div class="line"><span class="keyword">while</span> i &lt; names.<span class="built_in">count</span> &#123; &#125;</div><div class="line"><span class="keyword">repeat</span> &#123; &#125; <span class="keyword">while</span> i &lt; names.<span class="built_in">count</span></div></pre></td></tr></table></figure>
<p>以上代码非常简单。需要说明的有两个，一个是 <code>for _ in 0 ..&lt; names.count { }</code> 。当我们不需要数组中每一个具体的元素值时，我们就可以用下划线来代表序号。<br>另一个是是 <code>repeat { } while i &lt; names.count</code> 。这个相当于我们熟悉（java）的 <code>do { } while (i &lt; names.length)</code>。<br>注意，在循环中，i是let变量，是不可以修改的。</p>
<blockquote>
<p>在这里，因为 stride 方法语法变更的问题，在 Swift 3 下的写法应为：</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**我的笔记*/</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">0</span>, to: names.<span class="built_in">count</span>, by: <span class="number">2</span>) &#123;&#125;</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">0</span>, through: names.<span class="built_in">count</span> - <span class="number">1</span>, by: <span class="number">2</span>) &#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>Swift 排序效率很高，写法也很简洁。笔者将其总结如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Sort an Int array，ascending</span></div><div class="line">nums.sortInPlace(&#123;$<span class="number">0</span> &lt; $<span class="number">1</span>&#125;)</div><div class="line"></div><div class="line"><span class="comment">// Sort an Int array without mutating the original one, ascending</span></div><div class="line"><span class="keyword">var</span> sortedNums = nums.<span class="built_in">sort</span>(&#123;$<span class="number">0</span> &lt; $<span class="number">1</span>&#125;)</div><div class="line"></div><div class="line"><span class="comment">// Sort an array with custom-defined objects, ascending</span></div><div class="line">timeIntervals.sortInPlace(&#123;$<span class="number">0</span>.startTime &lt; $<span class="number">1</span>.startTime&#125;)</div><div class="line"></div><div class="line"><span class="comment">// Sort keys in a dictionary according to its value, ascending</span></div><div class="line"><span class="keyword">let</span> keys = <span class="type">Array</span>(dict.keys)</div><div class="line"><span class="keyword">var</span> sortedKeys = keys.<span class="built_in">sort</span>() &#123;</div><div class="line">  <span class="keyword">let</span> value0 = dict[$<span class="number">0</span>]</div><div class="line">  <span class="keyword">let</span> value1 = dict[$<span class="number">1</span>]</div><div class="line">  <span class="keyword">return</span> value0 &lt; value1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>同样由于版本问题，我将原作者的代码重新写了一遍，并添加了一部分代码：</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**我的笔记*/</span></div><div class="line"><span class="keyword">var</span> nums = [<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">10</span>]</div><div class="line"><span class="comment">// Sort an Int array，ascending</span></div><div class="line">nums.<span class="built_in">sort</span>(by: &#123;$<span class="number">0</span> &lt; $<span class="number">1</span>&#125;)</div><div class="line"><span class="comment">// Sort an Int array without mutating the original one, ascending</span></div><div class="line"><span class="keyword">var</span> sortedNums = nums.sorted(by: &#123;$<span class="number">0</span> &lt; $<span class="number">1</span>&#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>上面是对原数组进行排序和创建原数组的 Copy 并进行排序，下面是对象数组的排序：</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**我的笔记*/</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">model</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> startTime: <span class="type">Float</span></div><div class="line">    <span class="keyword">let</span> productName: <span class="type">String</span></div><div class="line">    <span class="keyword">var</span> timestamp: <span class="type">Date</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = model(startTime: <span class="number">1</span>, productName: <span class="string">"a"</span>, timestamp: <span class="type">Date</span>.<span class="keyword">init</span>(timeIntervalSince1970: <span class="number">5000</span>))</div><div class="line"><span class="keyword">var</span> b = model(startTime: <span class="number">2</span>, productName: <span class="string">"b"</span>, timestamp: <span class="type">Date</span>.<span class="keyword">init</span>(timeIntervalSince1970: <span class="number">2000</span>))</div><div class="line"></div><div class="line"><span class="keyword">var</span> models = [a, b]</div><div class="line"><span class="comment">// Sort an array with custom-defined objects, ascending</span></div><div class="line">models.<span class="built_in">sort</span>(by: &#123;$<span class="number">0</span>.startTime &lt; $<span class="number">1</span>.startTime&#125;)</div><div class="line">models.<span class="built_in">sort</span>(by: &#123;$<span class="number">0</span>.timestamp &lt; $<span class="number">1</span>.timestamp&#125;)</div><div class="line">models.<span class="built_in">sort</span>(by: &#123;$<span class="number">0</span>.productName &lt; $<span class="number">1</span>.productName&#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>可以看出 Swift 提供的排序还是很强大的，提供了多种数据类型的支持。除此之外，我们可以对字典的 key 进行排序：</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**我的笔记*/</span></div><div class="line"><span class="keyword">var</span> dict = [<span class="string">"3"</span>:<span class="string">"3"</span>, <span class="string">"2"</span>:<span class="string">"2"</span>, <span class="string">"1"</span>:<span class="string">"1"</span>]</div><div class="line"><span class="keyword">let</span> keys = <span class="type">Array</span>(dict.keys)</div><div class="line"></div><div class="line"><span class="keyword">var</span> sortedKeys = keys.sorted() &#123;</div><div class="line">    <span class="keyword">let</span> value0 = dict[$<span class="number">0</span>]</div><div class="line">    <span class="keyword">let</span> value1 = dict[$<span class="number">1</span>]</div><div class="line">    <span class="keyword">return</span> value0! &lt; value1!</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(sortedKeys)	<span class="comment">//["1", "2", "3"]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>为什么没有对字典的排序呢？我想是因为字典并不是按位置取值，而是按 key 来取值的。当然，如果要实现的话，也并不困难，我们可以这样将字典的 value 进行排序：</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**我的笔记*/</span></div><div class="line"><span class="keyword">var</span> dict = [<span class="string">"3"</span>:<span class="string">"3"</span>, <span class="string">"2"</span>:<span class="string">"2"</span>, <span class="string">"1"</span>:<span class="string">"1"</span>]</div><div class="line"><span class="keyword">let</span> values = <span class="type">Array</span>(dict.values)</div><div class="line"><span class="keyword">var</span> sortedValues = values.sorted(by: &#123;$<span class="number">0</span> &lt; $<span class="number">1</span>&#125;)</div><div class="line"><span class="built_in">print</span>(sortedValues)		<span class="comment">//["1", "2", "3"]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>也可以像下面这样，将整个字典进行排序，得到一个字典数组：</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**我的笔记*/</span></div><div class="line"><span class="keyword">var</span> dict = [<span class="string">"4"</span>:<span class="string">"4"</span>, <span class="string">"3"</span>:<span class="string">"3"</span>, <span class="string">"2"</span>:<span class="string">"2"</span>, <span class="string">"1"</span>:<span class="string">"1"</span>]</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SortOption</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">KEY</span></div><div class="line">    <span class="keyword">case</span> <span class="type">VALUE</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">DictWithOption</span><span class="params">(dict : [String : String],option : SortOption)</span></span> -&gt;[(<span class="type">String</span>, <span class="type">String</span>)] &#123;</div><div class="line">    <span class="keyword">var</span> sortResult = [(<span class="type">String</span>,<span class="type">String</span>)]()</div><div class="line">    <span class="keyword">switch</span> option &#123;</div><div class="line">    <span class="keyword">case</span> .<span class="type">KEY</span>:</div><div class="line">        sortResult = dict.sorted &#123; $<span class="number">0.0</span> &lt; $<span class="number">1.0</span> &#125;</div><div class="line">    <span class="keyword">case</span> .<span class="type">VALUE</span>:</div><div class="line">        sortResult = dict.sorted &#123; $<span class="number">0.1</span> &lt; $<span class="number">1.1</span> &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sortResult</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sortedDict = <span class="type">DictWithOption</span>(dict: dict, option: .<span class="type">VALUE</span>)</div><div class="line"><span class="comment">//[("1", "1"), ("2", "2"), ("3", "3"), ("4", "4")]</span></div></pre></td></tr></table></figure>
<h2 id="活用Guard语句"><a href="#活用Guard语句" class="headerlink" title="活用Guard语句"></a>活用Guard语句</h2><blockquote>
<p>在原文中，原作者并未对代码进行注释，我为了更好的理解两种控制流，擅自在代码中添加了解释，如果显得杂乱的话，可以在文末找到原文的链接。</p>
</blockquote>
<p>使用 Guard 语句可以让逻辑变得非常清楚，尤其是在处理算法问题的时候，请看下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack: String, <span class="number">_</span> needle: String)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="comment">//字符串转为字符数组</span></div><div class="line">    <span class="keyword">var</span> hChars = [<span class="type">Character</span>](haystack.characters)</div><div class="line">    <span class="keyword">var</span> nChars = [<span class="type">Character</span>](needle.characters)</div><div class="line">    <span class="comment">//如果haystack的长度小于needle，说明haystack不包含needle。</span></div><div class="line">    <span class="keyword">if</span> hChars.<span class="built_in">count</span> &lt; nChars.<span class="built_in">count</span> &#123;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果haystack的长度等于0，说明haystack不包含needle。</span></div><div class="line">    <span class="keyword">if</span> hChars.<span class="built_in">count</span> == <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ... hChars.<span class="built_in">count</span> - nChars.<span class="built_in">count</span> &#123;</div><div class="line">        <span class="comment">//如果从hChars中找到nChars的首字母</span></div><div class="line">        <span class="keyword">if</span> hChars[i] == nChars[<span class="number">0</span>] &#123;</div><div class="line">            <span class="comment">//进入nChars循环</span></div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span> ..&lt; nChars.<span class="built_in">count</span> &#123;</div><div class="line">                <span class="comment">//如果hChars的下一位不等于nChars的下一位，中断nChars循环，再次进入hChars循环查找首字母。</span></div><div class="line">                <span class="keyword">if</span> hChars[i + j] != nChars[j] &#123;</div><div class="line">                    <span class="keyword">break</span></div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果nChars循环一直相等，且到达nChars尾节点，说明已全部匹配，输出i。</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">//如果达到尾节点，输出最后一次首字母相等时的i</span></div><div class="line">                    <span class="keyword">if</span> j == nChars.<span class="built_in">count</span> - <span class="number">1</span> &#123;</div><div class="line">                        <span class="keyword">return</span> i</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码是求字符串 needle 在字符串 haystack 里首次出现的位置。我们发现 for 循环中的嵌套非常繁琐，但是如果使用 guard 语句代码会变得清晰很多：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack: String, <span class="number">_</span> needle: String)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line"></div><div class="line">    <span class="comment">//字符串转为字符数组</span></div><div class="line">    <span class="keyword">var</span> hChars = [<span class="type">Character</span>](haystack.characters)</div><div class="line">    <span class="keyword">var</span> nChars = [<span class="type">Character</span>](needle.characters)</div><div class="line">    </div><div class="line">    <span class="comment">//保证hChars的长度大于nChars的长度，如不满足则说hChars不包含nChars。</span></div><div class="line">    <span class="keyword">guard</span> hChars.<span class="built_in">count</span> &gt;= nChars.<span class="built_in">count</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果nChars的长度等于0，说明nChars是空字符串。</span></div><div class="line">    <span class="keyword">if</span> nChars.<span class="built_in">count</span> == <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ... hChars.<span class="built_in">count</span> - nChars.<span class="built_in">count</span> &#123;</div><div class="line">        <span class="comment">//保证找到nChars的首字母时，才能进入nChars的循环，如不满足则继续查找首字母。</span></div><div class="line">        <span class="keyword">guard</span> hChars[i] == nChars[<span class="number">0</span>] <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span> ..&lt; nChars.<span class="built_in">count</span> &#123;</div><div class="line">            <span class="comment">//保证hChars的下一位等于nChars的下一位，如不满足则中断nChars循环，再次进入hChars循环查找首字母。</span></div><div class="line">            <span class="keyword">guard</span> hChars[i+j] == nChars[j] <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">break</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果nChars循环一直相等，且到达nChars尾节点，说明已全部匹配，输出i。</span></div><div class="line">            <span class="keyword">if</span> j == nChars.<span class="built_in">count</span> - <span class="number">1</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>guard 语句的好处是判断条件永远是我们希望的条件而不是特殊情况，且成功避免了大量的 if 嵌套。</p>
<p>另外在上面代码中，为何要将字符串转化成数组进行处理？因为 Swift 中没有方法能够以 O(1) 的时间复杂度取得字符串中的字符，我们常用的<code>string.startIndex.advancedBy(n)</code>方法，其时间复杂度为O(n)。所以笔者在这里以空间换时间的方法进行了优化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Swift 是一门独特的语言，本文对其基本知识和语法进行了适当归纳，文中提到的都是基本细节。下期我们会讨论更加进阶的内容。</p>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="http://www.jianshu.com/p/ee16bcf50a59" target="_blank" rel="external">Swift 算法实战之路：基本语法与技巧</a> - 故胤道长</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift 是苹果新推出的编程语言，也是苹果首个开源语言。相比于原来的 Objective-C，Swift 要更轻便和灵活。笔者最近使用 Swift 实践了大量的算法（绝大部分是硅谷各大公司的面试题），将心得体会总结于下。此文并不是纯粹讨论 Swift 如何实现某一个具体的算法或者数据结构，如冒泡排序、深度优先遍历，或是树和栈，而是总结归纳一些 Swift 常用的语法和技巧，以便大家在解决面试题中使用。&lt;/p&gt;
&lt;h2 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h2&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(chars:[Character],  p: Int, q: Int)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; temp = chars[p]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  chars[p] = chars[q]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  chars[q] = temp&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Assume array is a character array and it has enough elements&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;swap&lt;/span&gt;(array, p: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, q: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码实现了一个非常简单的功能，就是交换一个数组中的两个值。乍一看非常正确，实际上存在以下几个问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在第一个参数前应该加上 &lt;strong&gt;inout &lt;/strong&gt;关键字。因为在 Swift 中，struct 都是按值传递，class 是按引用传递；数组和字典都是 struct。所以要改变原来的 chars 数组，在其前部加入 inout 关键字，表示是按引用传递。&lt;/li&gt;
&lt;li&gt;p 和 q 之前应该加入下划线。Swift 默认函数的第一个参数是局部（local）变量，而后续参数都是外部（external）变量，外部变量必须声明。如果在 p 和 q 前加上下划线，则在调用函数时无需声明外部变量，这样调用起来更简便。&lt;/li&gt;
&lt;li&gt;temp 前的 var 应该改为 &lt;strong&gt;let&lt;/strong&gt;。let 用于声明常量（constant），var 用于声明变量（variable）。swap 函数中，temp 并未进行修改，所以应当视为常量，用let来声明。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;除原作者以上写出的 3 点问题之外，在我编译时，也有几个方面值得记录下来：&lt;/p&gt;
&lt;p&gt;swap 是自带的方法，API 文档描述如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**我的笔记*/&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// Exchange the values of `a` and `b`.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;///&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// - Precondition: `a` and `b` do not alias each other.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; a: &lt;span class=&quot;keyword&quot;&gt;inout&lt;/span&gt; T, &lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; b: &lt;span class=&quot;keyword&quot;&gt;inout&lt;/span&gt; T)&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;系统提供的 swap 方法和我们自定义的方法使用略有不同，可以说更加简洁一些：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**我的笔记*/&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;swap&lt;/span&gt;(&amp;amp;chars[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &amp;amp;chars[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;在我看到自定义 swap 方法时，最先想到的是在方法内部修改传入参数，需要使用 var 进行描述，而在 Swift 3 中，var 关键字被取消，&lt;strong&gt;强制要求我们使用 inout 关键字&lt;/strong&gt;，当然我们也可以在方法内部创建一个新的变量：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**我的笔记*/&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(chars: [String], &lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; p: Int, &lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; q: Int)&lt;/span&gt;&lt;/span&gt; -&amp;gt; [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;] &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; chars = chars&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; temp = chars[p]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    chars[p] = chars[q]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    chars[q] = temp&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; chars&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;但这样处理是交换新的变量，而传入的 chars 是不会被修改的，因此在我们需要一份新的拷贝时，也可以使用这种方式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发 - 在一个工程中开发多个APP</title>
    <link href="http://yoursite.com/2016/10/11/iOS%E5%BC%80%E5%8F%91%20-%20%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B%E4%B8%AD%E5%BC%80%E5%8F%91%E5%A4%9A%E4%B8%AAAPP/"/>
    <id>http://yoursite.com/2016/10/11/iOS开发 - 在一个工程中开发多个APP/</id>
    <published>2016-10-10T18:24:00.000Z</published>
    <updated>2016-10-10T16:49:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般情况下，我们是一个 App 应用对应一个<code>Xcode Project</code>，但是如果你需要同时开发多个产品，而这些产品 90% 的数据结构以及交互方式都一样，呈现在用户面前的这两个产品，最大的不一样就是UI元素以及某些配色时，如果这个时候还是一个 App 一个<code>Xcode Project</code>，普遍的做法是：</p>
<p>你会先开发完成一个产品，然后在复制到其他的产品中，非常的麻烦而且效率很低，你需要一个一个文件去比对。如果你使用模块的方式，开发完一个模块，然后再利用<code>Pod</code>的方式导入到其他产品中，虽然这样可行，但是涉及到产品的迭代开发以及产品的随时会变的交互，模块的细化分很难实现。</p>
<p>如果你也面临这样的问题，不放考虑一下下面讲的<code>一个工程来开发多个App</code>：</p>
   <a id="more"></a>
<h2 id="创建新的Target"><a href="#创建新的Target" class="headerlink" title="创建新的Target"></a>创建新的Target</h2><p> 如果现在你已经有个一个产品叫<code>ProjectOfApps</code>，如下图所示：</p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/QQ20161010-0.png" alt="http://oboehz2ag.bkt.clouddn.com/QQ20161010-0"></p>
<p>这时你想添加一个叫<code>ProjectOfApps_B</code>的产品，你需要做的是按如下的步奏进行创建： 选择<code>Project -&gt; Targets -&gt; 右击ProjectOfApps -&gt; 选择Duplicate</code>，这时我们就按照<code>ProjectOfApps</code>复制了一个产品<code>ProjectOfApps copy</code>，并且你会看到多出了一个文件<code>ProjectOfApps copy-Info.plist</code>，如下图所示： </p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/QQ20161010-1.png" alt="http://oboehz2ag.bkt.clouddn.com/QQ20161010-1"></p>
<p>双击<code>ProjectOfApps copy</code>或选中回车，将 Target 名改为 <code>ProjectOfApps_B</code>。</p>
<h2 id="编辑Plist文件"><a href="#编辑Plist文件" class="headerlink" title="编辑Plist文件"></a>编辑Plist文件</h2><p>当我们创建新的<code>Target</code>后会多出一个<code>ProjectOfApps copy-Info.plist</code>文件，这个<code>plist</code>文件就是控制<code>ProjectOfApps_B</code>的名称，版本等信息的文件，我们为了统一将他改为<code>ProjectOfApps_B-Info.plist</code>，在修改名字之前你需要在<code>ProjectOfApps_B</code>的<code>Build Settings</code>中找到<code>ProjectOfApps copy-Info.plist</code>一项，待会儿我们修改完这个<code>plist</code>文件以后，还需要在这里填入它正切的位置信息。这样程序执行时才能找到它，不然程序是不能通过编译的：</p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/QQ20161010-2.png" alt="http://oboehz2ag.bkt.clouddn.com/QQ20161010-2"></p>
<p>我们的原项目<code>ProjectOfApps</code>也可以这样修改，来达到命名的统一。如果有必要，我们也可以修改<code>plist</code>文件里面的选项以符合我们的预期，和<code>Info.plist</code>的使用并无不同。</p>
<h2 id="判断当前编译的-Target"><a href="#判断当前编译的-Target" class="headerlink" title="判断当前编译的 Target"></a>判断当前编译的 Target</h2><p>现在我们的工程里面同时包含了两个<code>Target</code>，现在工程里面的类是这两个<code>Target</code>公用的，如果你想在一个类里面区分是<code>ProjectOfApps_A</code>还是<code>ProjectOfApps_B</code>，根据开发语言的不同有两种方案：</p>
<h3 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective - C"></a>Objective - C</h3><p>Objective - C 需要设置<code>Preprocessor Macros</code>，它的定义很简单，选中一个<code>Target</code>，然后在<code>Build Settings</code>里面搜索<code>Preprocessor Macros</code>一项，然后在里面添加表明是<code>ProjectOfApps_A</code>的宏： </p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/QQ20161010-3.png" alt="http://oboehz2ag.bkt.clouddn.com/QQ20161010-3"></p>
<p>然后就可以判断当前编译的 Target 是哪一个了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)someFunction </div><div class="line">&#123;</div><div class="line">#ifdef ProjectOfApps_A</div><div class="line">    NSLog(@&quot;Build For Target ProjectOfApps_A!&quot;);</div><div class="line">#else</div><div class="line">    NSLog(@&quot;Build For Target ProjectOfApps_B!&quot;);</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><p>Swift 下的处理和 Objective - C 有所不同，需要设置<code>Custom Flags</code>，选中一个<code>Target</code>，然后在<code>Build Settings</code>里面搜索<code>Custom Flags</code>一项，然后在里面添加表明是<code>ProjectOfApps_A</code>的宏：</p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/QQ20161011-0.png" alt="http://oboehz2ag.bkt.clouddn.com/QQ20161011-0"></p>
<p>需要注意的是，这里要使用<code>－D</code>的格式。对应的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">()</span></span> &#123;</div><div class="line">    #<span class="keyword">if</span> <span class="type">ProjectOfApps_A</span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"Build For Target ProjectOfApps_A!"</span>)</div><div class="line">    #elseif <span class="type">ProjectOfApps_B</span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"Build For Target ProjectOfApps_B!"</span>)</div><div class="line">    #<span class="keyword">else</span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"Other"</span>)</div><div class="line">    #endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="修改Scheme"><a href="#修改Scheme" class="headerlink" title="修改Scheme"></a>修改Scheme</h2><p>现在的 Scheme 还是<code>ProjectOfApps copy</code>和<code>ProjectOfApps</code>，我们可以通过<code>Manage Schemes</code>将两个 Scheme 修改一下： </p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/QQ20161011-1.png" alt="http://oboehz2ag.bkt.clouddn.com/QQ20161011-1"></p>
<h2 id="资源文件和类文件"><a href="#资源文件和类文件" class="headerlink" title="资源文件和类文件"></a>资源文件和类文件</h2><p>如果需要为不同的 Target 区别不同的资源文件和类文件，可以使用 Xcode 的<code>Target Membership</code>功能，来选择该类属于哪个<code>Target</code>。Assets、控件也是如此。 </p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/QQ20161011-2.png" alt="http://oboehz2ag.bkt.clouddn.com/QQ20161011-2"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://summertreee.github.io/blog/2016/01/23/ioszhong-ru-he-zai-%5B%3F%5D-ge-gong-cheng-chuang-jian-duo-ge-app/" target="_blank" rel="external">iOS中如何在一个工程创建多个App</a> - 夏树正茂</p>
<p><a href="http://stackoverflow.com/questions/24003291/ifdef-replacement-in-swift-language" target="_blank" rel="external">#ifdef replacement in swift language</a> - stackoverflow</p>
<h2 id="Demo下载请点击这里"><a href="#Demo下载请点击这里" class="headerlink" title="Demo下载请点击这里"></a>Demo下载请<a href="https://github.com/tianziyao/ProjectOfApps" target="_blank" rel="external">点击这里</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般情况下，我们是一个 App 应用对应一个&lt;code&gt;Xcode Project&lt;/code&gt;，但是如果你需要同时开发多个产品，而这些产品 90% 的数据结构以及交互方式都一样，呈现在用户面前的这两个产品，最大的不一样就是UI元素以及某些配色时，如果这个时候还是一个 App 一个&lt;code&gt;Xcode Project&lt;/code&gt;，普遍的做法是：&lt;/p&gt;
&lt;p&gt;你会先开发完成一个产品，然后在复制到其他的产品中，非常的麻烦而且效率很低，你需要一个一个文件去比对。如果你使用模块的方式，开发完一个模块，然后再利用&lt;code&gt;Pod&lt;/code&gt;的方式导入到其他产品中，虽然这样可行，但是涉及到产品的迭代开发以及产品的随时会变的交互，模块的细化分很难实现。&lt;/p&gt;
&lt;p&gt;如果你也面临这样的问题，不放考虑一下下面讲的&lt;code&gt;一个工程来开发多个App&lt;/code&gt;：&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="Custom Flags" scheme="http://yoursite.com/tags/Custom-Flags/"/>
    
  </entry>
  
  <entry>
    <title>Xcode错误 - Pch file not found</title>
    <link href="http://yoursite.com/2016/09/26/Xcode%E9%94%99%E8%AF%AF%20-%20Pch%20file%20not%20found/"/>
    <id>http://yoursite.com/2016/09/26/Xcode错误 - Pch file not found/</id>
    <published>2016-09-25T21:46:00.000Z</published>
    <updated>2016-09-26T10:45:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>这种问题出现的原因大多是路径问题，当 Mac 拷贝了工程或是工程的位置发生了变化，导致 Pch 文件的路径出错，解决方法如下：</p>
<ol>
<li><code>Targets -&gt; Build Settings -&gt; Apple llvm - Language</code> ，将项目里的的 Pch 文件直接拖到这边，设置为 YES；</li>
<li><code>⌘ + ⇧ + K</code> 清除工程；</li>
<li><code>⌘ + B</code> 编译工程；</li>
</ol>
<p><img src="http://oboehz2ag.bkt.clouddn.com/pchnotfound.png" alt="pchnotfound"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://stackoverflow.com/questions/25840720/xcode-6-pch-file-not-found" target="_blank" rel="external">http://stackoverflow.com/questions/25840720/xcode-6-pch-file-not-found</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这种问题出现的原因大多是路径问题，当 Mac 拷贝了工程或是工程的位置发生了变化，导致 Pch 文件的路径出错，解决方法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Targets -&amp;gt; Build Settings -&amp;gt; Apple llvm - Langua
    
    </summary>
    
      <category term="Xcode错误" scheme="http://yoursite.com/categories/Xcode%E9%94%99%E8%AF%AF/"/>
    
    
      <category term="Xcode错误" scheme="http://yoursite.com/tags/Xcode%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式 - Notification</title>
    <link href="http://yoursite.com/2016/09/24/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20Notification/"/>
    <id>http://yoursite.com/2016/09/24/iOS设计模式 - Notification/</id>
    <published>2016-09-23T18:24:00.000Z</published>
    <updated>2016-09-23T18:14:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 中的观察者 Observer 模式包含了通知机制（Notification）和KVO（Key-Value-Observing）机制，我们知道对象之间的通讯有以下几种常见的方式：</p>
<blockquote>
<p>Delegate、Block、KVO、Notification；</p>
</blockquote>
<p>其中 Delegate 使用的是委托机制，是一对一的对象之间的通信；而 KVO 和 Notification 通知机制是广播，也就是一对多的对象之间的通信。那么对象之间的通讯又是做什么呢？简单来说就是在 A 类中创建的方法，在 B 类中执行，且 A 类可以传递数据给 B 类，我们知道当说起通知时，有以下几种：</p>
<blockquote>
<p>本地通知、推送通知、广播通知；</p>
</blockquote>
<p>这三种通知是不同的，本地通知使用的是 <code>UILocalNotification</code> 实现，是我们的 APP 运行时，给用户的通知；推送通知是使用 <code>UIUserNotification</code> 实现，是用户同意推送后，由我们的服务器提交给 APNS，再由 APNS 转发给用户的。</p>
<p>而我们本文要探讨的是，程序中的对象与对象之间的通知，也就是最后一项，广播通知。</p>
   <a id="more"></a>
<h2 id="Notification的概念"><a href="#Notification的概念" class="headerlink" title="Notification的概念"></a>Notification的概念</h2><p>Notification 是 iOS 提供的一种同步的消息通知机制，观察者只要向消息中心注册，即可接受其他对象发送来的消息，消息发送者和接收者两者可以互相一无所知，完全解耦。</p>
<p>它是 Foundation 框架的一个子系统，它向应用程序中注册为某个事件观察者的所有对象广播消息，也就是通知。该事件可以是发生在应用程序中的任何事情，例如进入后台状态，或者用户开始在文本栏中键入。Notification 告诉观察者，事件已经发生或即将发生，因此让观察者有机会以合适的方式响应。通过通知中心来传播通知，是增加应用程序对象间合作和内聚力的一种途径。</p>
<p>虽然任何对象都可以观察通知，但要做到这一点，该对象必须注册，以接收通知。在注册时，它必须指定选择器，以确定由通知传送所调用的方法，方法签名必须只有一个参数，也就是通知对象；注册后，观察者也可以指定发布对象。Notification 可以应用于任何对象，观察者可以有多个，所以消息具有广播的性质。</p>
<p>需要注意的是，观察者向消息中心注册以后，在不需要接收消息时需要从消息中心移除，这种消息传递机制是典型的观察者模式。</p>
<p>每一个应用都有一个通知中心（Notification）实例。当应用发生某一事件时，任何对象都可以向通知中心发布通知；同时，通知的监听者监听到该通知的发布后，根据通知传入的信息（UserInfo），进行对应的操作或处理。</p>
<h2 id="NotificationCenter的使用"><a href="#NotificationCenter的使用" class="headerlink" title="NotificationCenter的使用"></a>NotificationCenter的使用</h2><p>使用通知模式主要是以下三个步骤：</p>
<ol>
<li>获取通知中心的实例并指定发布者；</li>
<li>注册成为观察者以接收发布者通知的信息；</li>
<li>当观察者不再关注该通知的信息时，可以向通知中心发送解除注册的信息，之后都不再接收到通知。</li>
</ol>
<p>通知机制常常用于在向服务器端请求数据或者提交数据的场景，在和服务器端成功交互后，需要处理服务器端返回的数据，或发送响应消息等，就需要用到通知机制。</p>
<h3 id="获取通知中心"><a href="#获取通知中心" class="headerlink" title="获取通知中心"></a>获取通知中心</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span></div></pre></td></tr></table></figure>
<p>NotificationCenter 的原理是一个观察者模式，只有通过调用静态方法 <code>default</code> 才可以获取这个通知中心的对象。它同时也是一个单例，这个对象会一直存在于一个应用的生命周期。</p>
<p>发布、注册、解除通知都需要使用<strong>通知中心</strong>，它负责协助不同对象、不同类之间的消息通信。</p>
<p>NotificationCenter 提供了一个中心化的枢纽，通过它，应用的任何部分都可以向其他部分发送通知，或者接收来自别人的通知。</p>
<p>观察者通过在通知中心进行注册，并对特定的事件注册特定的响应动作。每次这个事件发生时，如果有必要，通知中心将通知进行分发之后，所有注册这个事件的观察者都会获得通知。</p>
<h3 id="指定发布者"><a href="#指定发布者" class="headerlink" title="指定发布者"></a>指定发布者</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">post</span><span class="params">(<span class="number">_</span> notification: Notification)</span></span></div><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">post</span><span class="params">(name aName: NSNotification.Name, object anObject: Any?)</span></span></div><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">post</span><span class="params">(name aName: NSNotification.Name, object anObject: Any?, userInfo aUserInfo: [AnyHashable : Any]? = <span class="literal">nil</span>)</span></span></div></pre></td></tr></table></figure>
<p>我们可以看到，这个3个方法实际并无区别，传入的都是一个 <code>NSNotification</code> 类型，它是消息携带的载体，通过它，我们才可以把消息内容传递给观察者，它的结构如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">open <span class="class"><span class="keyword">class</span> <span class="title">NSNotification</span> : <span class="title">NSObject</span>, <span class="title">NSCopying</span>, <span class="title">NSCoding</span> </span>&#123;</div><div class="line">    open <span class="keyword">var</span> name: <span class="type">NSNotification</span>.<span class="type">Name</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    open <span class="keyword">var</span> object: <span class="type">Any</span>? &#123; <span class="keyword">get</span> &#125;</div><div class="line">    open <span class="keyword">var</span> userInfo: [<span class="type">AnyHashable</span> : <span class="type">Any</span>]? &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>name：指定消息名称；</li>
<li>object：指定发消息者；</li>
<li>userInfo：通知中用于传递参数的载体；</li>
</ul>
<p>userInfo 里的键值应该定义成字符串常量，在文档中应该清晰地注明哪个键对应哪种类型的值，因为编译器不能像针对对象那样对字典类型中的值类型进行限制。name 和 object 用来控制通知分发的作用域，开发者们应当在对象发送通知和接收通知的方式上保持一致，而且把通知的行为在公共接口文档中进行清晰的说明。</p>
<p>由于通知分发是在发送通知的线程上进行的，所以可能会需要使用：</p>
<blockquote>
<p>dispatch_async     &amp;     dispatch_get_main_queue() </p>
</blockquote>
<p>来保证通知的处理是在主线程进行，大部分情况下我们不需要考虑这点，不过还是要把这一点记在心里。</p>
<h3 id="注册观察者"><a href="#注册观察者" class="headerlink" title="注册观察者"></a>注册观察者</h3><p>各种各样的通知车水马龙地通过 NotificationCenter，然而一个通知本身不会有任何实际作用，除非有人在监听着它，传统的添加观察者的方式是使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">addObserver</span><span class="params">(<span class="number">_</span> observer: Any, selector aSelector: Selector, name aName: NSNotification.Name?, object anObject: Any?)</span></span></div></pre></td></tr></table></figure>
<p>进行注册，一个对象（通常是 self）把自己添加进去，当某个通知发出时，通知中心就会把发布者发送的通知信息，广播给注册过该通知的观察者，执行自己特定的 selector，观察者只能接收到通知中心的信息，但无法知道通知是谁投送的，这也是通知的解耦性的体现之一，它的几个参数作用如下：</p>
<ul>
<li>observer：观察者的实例，通常是 self；</li>
</ul>
<ul>
<li><p>selector：回调方法，在本类中对通知进行相应的处理；它只有一个参数, 参数就是消息对象本身, 通过这个参数回调方法可以取得消息对象的成员变量(userinfo) 用于传值注册、取消通知的代码放在哪里等操作。</p>
</li>
<li><p>object：相对于发布者的 object，如果同时设置了 name 和 object 那么只有来自特定对象的对应名称的通知才会响应。如果为 nil，那么观察者将收到任何对象发出的通知消息；</p>
</li>
<li><p>name：相对于发布者的 name，如果设置了 name，那么只有对应名称的通知会触发。如果为 nil，那么观察者将接收到 object 对象的所有消息，但是无法确定接收这些消息的顺序；</p>
</li>
<li><p>如果 name 和 object 都为 nil，那么该观察者将收到所有对象的所有消息。</p>
</li>
</ul>
<p>需要注意的有两点：</p>
<ol>
<li><p>对于一个任意的观察者observer，如果不能保证其对应的selector有本类自定义的方法，可采用：</p>
<blockquote>
<p>observer.responds(to: NSSelectorFromString(“myFunc:”)) </p>
</blockquote>
<p>进行检查，判断其方法确实存在后再进行注册。</p>
</li>
<li><p>控制好我们的代码！一个普通的 iOS 应用在启动之后的几秒钟内就会发出几十个通知，其中的大部分我们可能都没有听说过，也不需要去关心。</p>
</li>
</ol>
<h4 id="Notification-Block"><a href="#Notification-Block" class="headerlink" title="Notification Block"></a>Notification Block</h4><p>现代的基于 block 的用于添加通知观察者的 API 是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">addObserver</span><span class="params">(forName name: NSNotification.Name?, object obj: Any?, queue: OperationQueue?, using block: @escaping <span class="params">(Notification)</span></span></span> -&gt; <span class="type">Swift</span>.<span class="type">Void</span>) -&gt; <span class="type">NSObjectProtocol</span></div></pre></td></tr></table></figure>
<p>它是 iOS 4.0之后，Apple 又提供了一个以 block 方式实现的添加观察者的方法，与前面提到的把一个已有的对象注册成观察者不同，这个方法创建一个匿名对象作为观察者。</p>
<p>当收到对应的通知时，它在指定的队列（如果队列参数为 nil 的话就在调用者的线程）里执行一个 block。另外一点和基于 selector 的方法不同的是，这个方法会返回构造出的观察者对象，此方法需要考虑 block 的循环引用问题，并不经常用到。</p>
<h3 id="移除观察者"><a href="#移除观察者" class="headerlink" title="移除观察者"></a>移除观察者</h3><p>由于通知中心不会 retain 观察者对象，因此注册过的对象必须在释放之前注销掉，如果不这样的话，当该通知再次出现时，通知中心会向已释放的观察者对象发送消息，从而导致应用崩溃。</p>
<p>在 ARC 下，系统会自动回收无用的通知对象内存，但是由于系统回收机制 ARC 有一定的延迟性，所以即使不会出错，也建议养成习惯，对无用的通知进行手动释放。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">removeObserver</span><span class="params">(<span class="number">_</span> observer: Any)</span></span>	</div><div class="line"><span class="comment">//释放所有的通知</span></div><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">removeObserver</span><span class="params">(<span class="number">_</span> observer: Any, name aName: NSNotification.Name?, object anObject: Any?)</span></span></div><div class="line"><span class="comment">//释放指定 name 或 object 的通知</span></div></pre></td></tr></table></figure>
<p>一般我们在对象的析构函数中将通知移除，我们可以选择将这个对象中的所有通知移除，也可以选择一个一个按照通知的 name 来移除，移除的时机和事件有关，如果是和视图相关的，比如键盘、UI事件等，可以使用：</p>
<blockquote>
<p>viewWillAppear    &amp;    viewWillDisappear</p>
</blockquote>
<p>如果是和 ViewController 相关的，比如和网络、异步IO等相关的通知，可以使用：</p>
<blockquote>
<p>viewDidLoad        &amp;    dealloc</p>
</blockquote>
<h2 id="KVO-NotificationCenter"><a href="#KVO-NotificationCenter" class="headerlink" title="KVO != NotificationCenter"></a>KVO != NotificationCenter</h2><p>有一点经常让我们犯糊涂，NotificationCenter 的方法签名和 Key-Value Observing 非常相似。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">addObserver</span><span class="params">(<span class="number">_</span> observer: Any, selector aSelector: Selector, name aName: NSNotification.Name?, object anObject: Any?)</span></span></div><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">addObserver</span><span class="params">(<span class="number">_</span> observer: NSObject, forKeyPath keyPath: String, options: NSKeyValueObservingOptions = [], context: UnsafeMutableRawPointer?)</span></span></div></pre></td></tr></table></figure>
<p><strong>Key-Value Observing 是在 keypaths 上添加观察者，而 NotificationCenter 是在通知上添加观察者。</strong>牢记这个区别，就可以自信地去使用这两套 API 了。</p>
<h2 id="Notification的栗子"><a href="#Notification的栗子" class="headerlink" title="Notification的栗子"></a>Notification的栗子</h2><blockquote>
<p>Talk is cheap. Show me the code.</p>
</blockquote>
<p>上面我们撸完概念，下面开始撸代码了，我们要做两个页面，在第二个页面中输入文字，在第一个页面中展示输入的文字。首先我们创建一个视图 FirstVC，添加一个 Label 属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> observerLabel: <span class="type">UILabel</span>!</div></pre></td></tr></table></figure>
<p>然后创建一个方法，在我们获得通知时，更新 Label 的文字：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">upDataForLabel</span><span class="params">(notification: NSNotification)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> dict = notification.userInfo!</div><div class="line">    <span class="keyword">let</span> str = dict[<span class="string">"toFirstVCLabel"</span>]</div><div class="line">    observerLabel.text = str <span class="keyword">as</span>? <span class="type">String</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 viewDidLoad 方法中，我们将 FirstVC 自己注册为观察者：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">    <span class="keyword">let</span> selector = <span class="type">NSSelectorFromString</span>(<span class="string">"upDataForLabelWithNotification:"</span>)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.responds(to: selector) &#123;</div><div class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>,</div><div class="line">                                               selector: selector,</div><div class="line">                                               name: <span class="type">NSNotification</span>.<span class="type">Name</span>(rawValue: <span class="string">"upDataForLabel"</span>),</div><div class="line">                                               object: <span class="literal">nil</span>)</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们创建第二个页面：SecondVC，添加一个 UITextField 用于用户输入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> posterTextField: <span class="type">UITextField</span>!</div></pre></td></tr></table></figure>
<p>添加一个 Button，点击时返回到 FirstVC，并且发送消息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">saveAndJumpButtonDidTouch</span><span class="params">(<span class="number">_</span> sender: AnyObject)</span></span> &#123;</div><div class="line">    <span class="keyword">self</span>.dismiss(animated: <span class="literal">true</span>) &#123; </div><div class="line">        <span class="keyword">let</span> str = <span class="keyword">self</span>.posterTextField.text</div><div class="line">        <span class="keyword">let</span> notification = <span class="type">Notification</span>(name: <span class="type">NSNotification</span>.<span class="type">Name</span>(rawValue: <span class="string">"upDataForLabel"</span>),</div><div class="line">                                        object: <span class="literal">nil</span>,</div><div class="line">                                        userInfo: [<span class="string">"toFirstVCLabel"</span>:str])</div><div class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(notification)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样前面的目标就完成了。从 FirstVC 跳转到 SecondVC，在 SecondVC 中输入文字，点击 Button 后跳转回 FirstVC，并显示之前输入的文字。</p>
<h3 id="NSNotification-Name"><a href="#NSNotification-Name" class="headerlink" title="NSNotification.Name"></a>NSNotification.Name</h3><p>NSNotification.Name 并不仅仅可以为我们自己的通知进行标识，它还具有很多 API，可以监控 APP 的运行状态，我们接着完善这个小程序，这次我们的目标是当程序进入非活动状态时，更改 FirstVC 的 Label 的背景颜色。我们在 FirstVC 的 viewDidLoad 中再注册一个观察者：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>,</div><div class="line">                                           selector: #selector(<span class="type">FirstVC</span>.colorChangeForAppState),</div><div class="line">                                           name: <span class="type">NSNotification</span>.<span class="type">Name</span>.<span class="type">UIApplicationWillResignActive</span>,</div><div class="line">                                           object: <span class="literal">nil</span>)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>NSNotification.Name.UIApplicationWillResignActive 代表的是一个程序进入后台运行的通知，然后实现对应通知的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">colorChangeForAppState</span><span class="params">()</span></span> &#123;</div><div class="line">    observerLabel.backgroundColor = <span class="type">UIColor</span>.<span class="keyword">init</span>(red: <span class="number">168</span>/<span class="number">255</span>, green: <span class="number">21</span>/<span class="number">255</span>, blue: <span class="number">42</span>/<span class="number">255</span>, alpha: <span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们按两次 Home 键，在任务管理中可以看到，Label 的颜色已经发生改变。最后，不要忘记移除观察者：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.didReceiveMemoryWarning()</div><div class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>每一个运行的 Cocoa 程序都有一个自己管理的默认通知中心 NotificationCenter；</p>
<p>NotificationCenter 可以有许多的通知消息发送者 NSNotification；</p>
<p>每一个发送者 NSNotification 可以有很多的观察者 Observer 来接收通知。</p>
<p>每一个 Notification 对象都必须具有有：</p>
<ul>
<li>name，它描述的是通知的名称；</li>
<li>object 对象，它表示是谁发布的通知；</li>
<li>userInfo，一个字典类型，包含发布者要传递给通知接收者的一些额外内容；</li>
</ul>
<p>举个例子，UITextField 在每次文本发生变化时，都会发出一个名为 <code>UITextFieldTextDidChangeNotification</code> 的 NSNotification，这个通知关联的对象就是文本框本身，对于 <code>UIKeyboardWillShowNotification</code> 这个通知来说，<code>userInfo</code> 中存入了 frame 的位置和动画时间，关联的 <code>object</code> 是 nil。</p>
<h2 id="Demo下载请点击这里"><a href="#Demo下载请点击这里" class="headerlink" title="Demo下载请点击这里"></a>Demo下载请<a href="https://github.com/tianziyao/MyNotification" target="_blank" rel="external">点击这里</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 中的观察者 Observer 模式包含了通知机制（Notification）和KVO（Key-Value-Observing）机制，我们知道对象之间的通讯有以下几种常见的方式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Delegate、Block、KVO、Notification；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中 Delegate 使用的是委托机制，是一对一的对象之间的通信；而 KVO 和 Notification 通知机制是广播，也就是一对多的对象之间的通信。那么对象之间的通讯又是做什么呢？简单来说就是在 A 类中创建的方法，在 B 类中执行，且 A 类可以传递数据给 B 类，我们知道当说起通知时，有以下几种：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本地通知、推送通知、广播通知；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这三种通知是不同的，本地通知使用的是 &lt;code&gt;UILocalNotification&lt;/code&gt; 实现，是我们的 APP 运行时，给用户的通知；推送通知是使用 &lt;code&gt;UIUserNotification&lt;/code&gt; 实现，是用户同意推送后，由我们的服务器提交给 APNS，再由 APNS 转发给用户的。&lt;/p&gt;
&lt;p&gt;而我们本文要探讨的是，程序中的对象与对象之间的通知，也就是最后一项，广播通知。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Notification" scheme="http://yoursite.com/tags/Notification/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式 - KVO原理和使用</title>
    <link href="http://yoursite.com/2016/09/23/KVO/"/>
    <id>http://yoursite.com/2016/09/23/KVO/</id>
    <published>2016-09-22T18:24:00.000Z</published>
    <updated>2016-09-22T16:28:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>KVO/KVC是观察者模式在Objective-C中的实现，以非正式协议（Category）的形式被定义在NSObject中。从协议的角度看，是定义了一套让开发者遵守的规范和使用的方法。</p>
<p>在Cocoa的MVC框架中，KVO架起ViewController和Model沟通的桥梁，例如：</p>
<blockquote>
<p>代码中，在模型类A创建属性数据，在控制器中创建观察者，一旦属性数据发生改变就收到观察者收到通知，通过KVO再在控制器使用回调方法处理实现视图B的更新。</p>
</blockquote>
   <a id="more"></a>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>当观察某对象A时，KVO机制动态创建一个对象A当前类的子类，并为这个新的子类重写了被观察属性keyPath的setter方法，setter方法随后负责通知观察对象属性的改变状况。Apple使用了：</p>
<blockquote>
<p>isa 混写（isa-swizzling）isa：is a kind of ； swizzling：混合，搅合；</p>
</blockquote>
<p>来实现 KVO，当观察对象A时，KVO机制动态创建一个新的名为：</p>
<blockquote>
<p>NSKVONotifying_A 的继承自对象A的子类，</p>
</blockquote>
<p>且KVO为<code>NSKVONotifying_A</code>重写了观察属性的setter方法，setter方法会负责在调用原setter方法之前和之后，通知所有观察对象属性值的更改情况。</p>
<h3 id="NSKVONotifying-A类剖析："><a href="#NSKVONotifying-A类剖析：" class="headerlink" title="NSKVONotifying_A类剖析："></a>NSKVONotifying_A类剖析：</h3><p>在观察到对象成员有变化时，被观察对象的isa指针从指向原来的A类，被KVO机制修改为指向：</p>
<blockquote>
<p>系统新创建的子类 NSKVONotifying_A类，</p>
</blockquote>
<p>通过<code>NSKVONotifying_A</code>的setter方法来实现当前类属性值改变的监听；</p>
<p>所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统隐瞒了对KVO的底层实现过程，让我们误以为还是原来的类。</p>
<p>但是此时如果我们创建一个新的名为<code>NSKVONotifying_A</code>的类，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候：</p>
<blockquote>
<p>动态的创建了名为NSKVONotifying_A的中间类，并指向这个中间类。</p>
</blockquote>
<p>因此由于类名的冲突，就会引起程序的崩溃。</p>
<h3 id="isa指针的作用："><a href="#isa指针的作用：" class="headerlink" title="isa指针的作用："></a>isa指针的作用：</h3><p>每个对象都有isa指针，指向该对象的类，它告诉Runtime系统这个对象的类是什么。所以对象注册为观察者时，isa指针指向新子类，那么：</p>
<blockquote>
<p>这个被观察的对象就神奇地变成新子类的对象或者说实例了。</p>
</blockquote>
<p>因此在该对象上对sette 的调用就会调用已重写的 setter，从而激活键值通知机制。</p>
<h3 id="子类setter方法剖析："><a href="#子类setter方法剖析：" class="headerlink" title="子类setter方法剖析："></a>子类setter方法剖析：</h3><p>KVO的键值观察通知依赖于NSObject 的两个方法：</p>
<blockquote>
<p>willChangeValueForKey:</p>
<p>didChangevlueForKey:</p>
</blockquote>
<ul>
<li><p>被观察属性发生<strong>改变之前</strong>，<code>willChangeValueForKey:</code>被调用，通知系统该 keyPath的属性值即将变更；</p>
<ul>
<li><p>当<strong>改变发生后</strong>， <code>didChangeValueForKey:</code>被调用，通知系统该keyPath的属性值已经变更；</p>
<ul>
<li><p>在上面的方法执行之后：</p>
<blockquote>
<p>observeValueForKey:ofObject:change:context: </p>
</blockquote>
<p>也会被调用。且重写观察属性的setter方法是在<strong>运行时</strong>而不是<strong>编译时</strong>实现的。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>KVO为子类的观察者属性重写调用存取方法的工作原理在代码中相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(void)setName:(NSString *)newName&#123; </div><div class="line">[self willChangeValueForKey:@&quot;name&quot;];    //KVO在调用存取方法之前总调用 </div><div class="line">[super setValue:newName forKey:@&quot;name&quot;]; //调用父类的存取方法 </div><div class="line">[self didChangeValueForKey:@&quot;name&quot;];     //KVO在调用存取方法之后总调用&#125;</div></pre></td></tr></table></figure>
<h2 id="KVO的主要方法"><a href="#KVO的主要方法" class="headerlink" title="KVO的主要方法"></a>KVO的主要方法</h2><p>KVO的主要方法有以下几个：</p>
<h3 id="addObserver调用方法"><a href="#addObserver调用方法" class="headerlink" title="addObserver调用方法"></a>addObserver调用方法</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">object.addObserver(observer, forKeyPath: <span class="string">"name"</span>, options: <span class="number">0</span>, context: &amp;context)</div></pre></td></tr></table></figure>
<p><code>addObserver</code>方法用于添加观察者，监听属性的变化，它的几个参数作用如下：</p>
<ul>
<li>object：是被观察者的实例；</li>
<li>observer：是观察者的实例，这个对象要实现下面的<code>observeValue</code>方法；</li>
<li>forKeyPath：是观察者实例要监听的键，如UIView的frame、center等；</li>
<li>options：有4个值，5种情况，具体请看下文；</li>
<li>context：它是一个C指针，会指向希望监听的属性。如：<code>&amp;object-&gt;name</code>，同时它也可以带入一些参数，可以是任意类型，需要自己强转。</li>
</ul>
<h3 id="observeValue处理方法"><a href="#observeValue处理方法" class="headerlink" title="observeValue处理方法"></a>observeValue处理方法</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">observeValue</span><span class="params">(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?)</span></span></div></pre></td></tr></table></figure>
<p><code>observeValue</code>方法用于监听属性的变化，使重写此方法的类具有监听的能力，它的几个参数作用如下：</p>
<ul>
<li>keyPath：对应forKeyPath</li>
<li>object：被观察的对象</li>
<li>change：对应options</li>
<li>context：对应context</li>
</ul>
<h3 id="removeObserver移除属性观察者"><a href="#removeObserver移除属性观察者" class="headerlink" title="removeObserver移除属性观察者"></a>removeObserver移除属性观察者</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">object.removeObserver(observer, forKeyPath: <span class="string">"name"</span>, context: &amp;context)</div><div class="line">object.removeObserver(observer, forKeyPath: <span class="string">"name"</span>)</div></pre></td></tr></table></figure>
<p>需要注意的是，如果注册observer时传入了<code>context</code>，之后一定要在合适的机会解除，否则会引发资源泄露。</p>
<h3 id="options参数"><a href="#options参数" class="headerlink" title="options参数"></a>options参数</h3><p>options参数是<code>OptionSet</code>类型，它是一个结构体，有以下四个类型属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">NSKeyValueObservingOptions</span> : <span class="title">OptionSet</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">UInt</span>)</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> new: <span class="type">NSKeyValueObservingOptions</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> old: <span class="type">NSKeyValueObservingOptions</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> initial: <span class="type">NSKeyValueObservingOptions</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> prior: <span class="type">NSKeyValueObservingOptions</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这四个值的含义如下：</p>
<h4 id="new："><a href="#new：" class="headerlink" title="new："></a>new：</h4><p>表明变化的字典应该提供新的属性值，接收方法中使用change参数传入变化后的新值，键为NSKeyValueChange.newKey；</p>
<h4 id="old："><a href="#old：" class="headerlink" title="old："></a>old：</h4><p>表明变化的字典应该包含旧的属性值，接收方法中使用change参数传入变化前的旧值；键为NSKeyValueChange.oldKey；</p>
<h4 id="initial："><a href="#initial：" class="headerlink" title="initial："></a>initial：</h4><p>把初始化的值提供给处理方法，一旦注册，马上就会调用一次，如果配置了new，change参数内容会包含新值；它是如何使用的呢？比如我们在进行UI相关的KVO操作时候，通常会遇到这样的需求：</p>
<blockquote>
<p>在添加通知后，立即发送一个改变通知告诉UI去更新界面。</p>
</blockquote>
<p>这会让我们的界面有一个初始状态。我们可以指定<code>Initial</code>选项，这样在我们添加完KVO监听后，属性改变的通知就会立即被执行一次：</p>
<h4 id="prior："><a href="#prior：" class="headerlink" title="prior："></a>prior：</h4><p>接收方法会在变化前后分别调用一次，共两次，change参数内容根据new和old的配置确定。这个选项可以让我们在被监听的属性改变的时候得到两个通知，一个是在属性值改变之前，一个是属性值改变之后。</p>
<p>然后就可以在 <code>observeValueForKeyPath</code>中的<code>change</code>字典中以<code>NSKeyValueChangeNotificationIsPriorKey</code>键来表示当前通知是不是在属性被修改之前发送的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">observeValueForKeyPath</span><span class="params">(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;)</span></span> &#123;</div><div class="line">        </div><div class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">_</span> = change?[<span class="type">NSKeyValueChangeNotificationIsPriorKey</span>] &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"old"</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"new"</span>)            </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，如果你只是想得到修改前和修改后的值，那么也可以用<code>change</code>字段中的<code>NSKeyValueChangeOldKey</code>和 <code>NSKeyValueChangeNewKey</code>来得到相应的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> newFirstName = change?[<span class="type">NSKeyValueChangeNewKey</span>] <span class="keyword">as</span>? <span class="type">String</span> &#123;</div><div class="line">                </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> oldFirstName = change?[<span class="type">NSKeyValueChangeOldKey</span>] <span class="keyword">as</span>? <span class="type">String</span> &#123;</div><div class="line">                </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="change参数"><a href="#change参数" class="headerlink" title="change参数"></a>change参数</h3><p>change参数是<code>NSKeyValueChangeKey</code>类型，它是一个结构体：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">NSKeyValueChangeKey</span> : <span class="title">RawRepresentable</span>, <span class="title">Equatable</span>, <span class="title">Hashable</span>, <span class="title">Comparable</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">String</span>)</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSKeyValueChangeKey</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> kindKey: <span class="type">NSKeyValueChangeKey</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> newKey: <span class="type">NSKeyValueChangeKey</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> oldKey: <span class="type">NSKeyValueChangeKey</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> indexesKey: <span class="type">NSKeyValueChangeKey</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> notificationIsPriorKey: <span class="type">NSKeyValueChangeKey</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的几个参数作用如下：</p>
<ul>
<li><p>kindKey：用于传递被监听属性的变化类型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">NSKeyValueChange</span> : <span class="title">UInt</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> setting</div><div class="line">    <span class="keyword">case</span> insertion</div><div class="line">    <span class="keyword">case</span> removal</div><div class="line">    <span class="keyword">case</span> replacement</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>setting：属性的值被重新设置；</li>
<li>insertion &amp; removal &amp; replacement：表示更改的是集合属性，分别代表插入、删除、替换操作。</li>
</ul>
</li>
<li><p>newKey：如果KindKey是setting，那么newKey对应的为新设置的值；</p>
</li>
<li><p>oldKey：如果KindKey是setting，那么oldkey对应的为上一个值；</p>
</li>
<li><p>indexesKey：如果kindkey是.insertion, .removal, .replacement，那么这个值对应的为NSIndexSet (包含相应操作的indexs)；</p>
</li>
<li><p>priorKey：表明收到的是值改变之前的通知，对应着addobserver中option的.prior；</p>
</li>
</ul>
<p>了解KVO的主要方法和参数后，我们就可以开始使用KVO进行编程了，下面我们开始进行：</p>
<h2 id="KVO的使用"><a href="#KVO的使用" class="headerlink" title="KVO的使用"></a>KVO的使用</h2><p>首先定义一个 <code>Persson</code> 类，当做被观察的对象：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> address: <span class="type">String</span>?</div><div class="line">    <span class="keyword">var</span> weight: <span class="type">Float</span>?</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</div><div class="line">    <span class="keyword">var</span> age: <span class="type">Int</span>?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再定义一个 <code>PersonObserving</code> 类并重写<code>observeValue</code>方法，用于观察<code>Person</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonObserving</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">observeValue</span><span class="params">(forKeyPath keyPath: String?,</span></span></div><div class="line">                               of object: Any?,</div><div class="line">                               change: [NSKeyValueChangeKey : Any]?,</div><div class="line">                               context: UnsafeMutableRawPointer?) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> newValue = change?[<span class="type">NSKeyValueChangeKey</span>.newKey]</div><div class="line">        <span class="keyword">let</span> oldValue = change?[<span class="type">NSKeyValueChangeKey</span>.oldKey]</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> person = object <span class="keyword">as</span>! <span class="type">Person</span></div><div class="line">        <span class="keyword">let</span> con = context?.load(<span class="keyword">as</span>: <span class="type">String</span>.<span class="keyword">self</span>)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"观察到<span class="subst">\(keyPath)</span>的变化，旧的值是<span class="subst">\(oldValue)</span>,新的值是<span class="subst">\(newValue)</span>"</span>)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"观察的类是<span class="subst">\(type(of: person)</span>)"</span>)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"接收的上下文是<span class="subst">\(con)</span>"</span>)</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>观察者和被观察者准备就绪，即可进行测试：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**执行*/</span></div><div class="line"><span class="keyword">let</span> person = <span class="type">Person</span>()</div><div class="line"><span class="keyword">let</span> personObserving = <span class="type">PersonObserving</span>()</div><div class="line"><span class="keyword">var</span> context = <span class="string">"this is a context"</span></div><div class="line"></div><div class="line">person.addObserver(personObserving,</div><div class="line">                   forKeyPath: <span class="string">"name"</span>,</div><div class="line">                   options: <span class="type">NSKeyValueObservingOptions</span>.new,</div><div class="line">                   context: &amp;context)</div><div class="line"></div><div class="line">person.setValue(<span class="string">"Jerk ass"</span>, forKey: <span class="string">"name"</span>)</div><div class="line"><span class="built_in">print</span>(person.value(forKey: <span class="string">"name"</span>))</div><div class="line"></div><div class="line">person.removeObserver(personObserving,</div><div class="line">                      forKeyPath: <span class="string">"name"</span>,</div><div class="line">                      context: &amp;context)</div><div class="line">                      </div><div class="line"><span class="comment">/**输出*/</span></div><div class="line">观察到<span class="type">Optional</span>(<span class="string">"name"</span>)的变化，旧的值是<span class="literal">nil</span>,新的值是<span class="type">Optional</span>(<span class="type">Jerk</span> ass)</div><div class="line">观察的类是<span class="type">Person</span></div><div class="line">接收的上下文是<span class="type">Optional</span>(<span class="string">"this is a context"</span>)</div><div class="line"><span class="type">Optional</span>(<span class="type">Jerk</span> ass)</div></pre></td></tr></table></figure>
<h2 id="KVO和keyPath"><a href="#KVO和keyPath" class="headerlink" title="KVO和keyPath"></a>KVO和keyPath</h2><p>如果<code>Person</code>类里面还有个再添加一个<code>Job</code>的属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> address: <span class="type">String</span>?</div><div class="line">    <span class="keyword">var</span> weight: <span class="type">Float</span>?</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</div><div class="line">    <span class="keyword">var</span> age: <span class="type">Int</span>?</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> job = <span class="type">Job</span>()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> companyName: <span class="type">String</span>?</div><div class="line">    <span class="keyword">var</span> salary: <span class="type">NSNumber</span>?</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**执行*/</span></div><div class="line">person.addObserver(personObserving, forKeyPath: <span class="string">"job.salary"</span>,</div><div class="line">                   options: <span class="type">NSKeyValueObservingOptions</span>.new,</div><div class="line">                   context: &amp;context)</div><div class="line">person.setValue(<span class="string">"20000.00"</span>, forKeyPath: <span class="string">"job.salary"</span>)</div><div class="line"><span class="built_in">print</span>(person.value(forKeyPath: <span class="string">"job.salary"</span>))</div><div class="line"></div><div class="line">person.removeObserver(personObserving,</div><div class="line">                      forKeyPath: <span class="string">"job.salary"</span>,</div><div class="line">                      context: &amp;context)</div><div class="line">                      </div><div class="line"><span class="comment">/**输出*/</span></div><div class="line">观察到<span class="type">Optional</span>(<span class="string">"job.salary"</span>)的变化，旧的值是<span class="literal">nil</span>,新的值是<span class="type">Optional</span>(<span class="number">20000.00</span>)</div><div class="line">观察的类是<span class="type">Person</span></div><div class="line">接收的上下文是<span class="type">Optional</span>(<span class="string">"this is a context"</span>)</div><div class="line"><span class="type">Optional</span>(<span class="number">20000.00</span>)</div></pre></td></tr></table></figure>
<p>要观察和设置<code>Person</code>的薪水，只要这么写就可以了。</p>
<h2 id="KVO属性依赖"><a href="#KVO属性依赖" class="headerlink" title="KVO属性依赖"></a>KVO属性依赖</h2><p>假如有个<code>Person</code>类，类里有三个属性，<code>fullName</code>、<code>firstName</code>、<code>lastName</code>。按照之前的知识，如果需要观察名字的变化，就要分别添加 <code>fullName</code>、<code>firstName</code>、<code>lastName</code> 三次观察，非常麻烦。</p>
<p>如果能够只观察 <code>fullName</code>，并建立<code>fullName</code> 和 <code>firstName</code>、<code>lastName</code> 的某种依赖关系，当发生变化时，也受到通知，那需要怎么做呢？KVC提供这种键之间的依赖方法，格式如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">keyPathsForValuesAffecting</span>&lt;<span class="title">Key</span>&gt;() -&gt; <span class="title">NSSet</span></span></div></pre></td></tr></table></figure>
<p>这方法使得Key之间能够建立依赖关系，为了便于说明，直接用<strong>属性依赖</strong>这个词代替Key之间的依赖。含义不同，结果一致，下面就使用这种方法解决 Key 之间的依赖关系，首先将<code>Person</code>类设置为被观察者：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> firstName: <span class="type">String</span>?</div><div class="line">    <span class="keyword">var</span> lastName: <span class="type">String</span>?</div><div class="line">    <span class="keyword">var</span> fullName: <span class="type">String</span>? &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">return</span> firstName! + lastName!</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">keyPathsForValuesAffectingValue</span>(<span class="title">forKey</span> <span class="title">key</span>: <span class="title">String</span>) -&gt; <span class="title">Set</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line">        <span class="built_in">print</span>(#function)</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> key == <span class="string">"fullName"</span> &#123;</div><div class="line">            </div><div class="line">            <span class="keyword">return</span> <span class="type">Set</span>&lt;<span class="type">String</span>&gt;(arrayLiteral: <span class="string">"firstName"</span>,<span class="string">"lastName"</span>)</div><div class="line">            </div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            </div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.keyPathsForValuesAffectingValue(forKey: key)</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将<code>ViewController</code> 类设置为观察者：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">   </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">observeValue</span><span class="params">(forKeyPath keyPath: String?,</span></span></div><div class="line">                               of object: Any?,</div><div class="line">                               change: [NSKeyValueChangeKey : Any]?,</div><div class="line">                               context: UnsafeMutableRawPointer?) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> newValue = change?[<span class="type">NSKeyValueChangeKey</span>.newKey]</div><div class="line">        <span class="keyword">let</span> oldValue = change?[<span class="type">NSKeyValueChangeKey</span>.oldKey]</div><div class="line">        <span class="built_in">print</span>(<span class="string">"观察到<span class="subst">\(keyPath)</span>的变化，旧的值是<span class="subst">\(oldValue)</span>,新的值是<span class="subst">\(newValue)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**执行*/</span></div><div class="line"><span class="keyword">let</span> person = <span class="type">Person</span>()</div><div class="line">person.lastName = <span class="string">"hoohoo"</span></div><div class="line"><span class="keyword">var</span> context = <span class="string">"this is a context"</span></div><div class="line">person.addObserver(<span class="keyword">self</span>,</div><div class="line">                   forKeyPath: <span class="string">"fullName"</span>,</div><div class="line">                   options: <span class="type">NSKeyValueObservingOptions</span>.new,</div><div class="line">                   context: &amp;context)</div><div class="line">person.setValue(<span class="string">"Bad ass "</span>, forKeyPath: <span class="string">"firstName"</span>)</div><div class="line">person.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"fullName"</span>, context: &amp;context)</div><div class="line"><span class="built_in">print</span>(person.value(forKeyPath: <span class="string">"fullName"</span>))</div><div class="line"></div><div class="line"><span class="comment">/**输出*/</span></div><div class="line">keyPathsForValuesAffectingValue(forKey:)</div><div class="line">keyPathsForValuesAffectingValue(forKey:)</div><div class="line">keyPathsForValuesAffectingValue(forKey:)</div><div class="line">keyPathsForValuesAffectingValue(forKey:)</div><div class="line">keyPathsForValuesAffectingValue(forKey:)</div><div class="line">观察到<span class="type">Optional</span>(<span class="string">"fullName"</span>)的变化，旧的值是<span class="literal">nil</span>,新的值是<span class="type">Optional</span>(<span class="type">Bad</span> ass hoohoo)</div><div class="line"><span class="type">Optional</span>(<span class="type">Bad</span> ass hoohoo)</div></pre></td></tr></table></figure>
<p>通过输出结果，我们可以判断出：发现虽然观察的是<code>fullName</code>，但是当修改<code>firstName</code>的时候，观察者也会收到<code>fullName</code>变化的通知，达到了我们的期望。</p>
<p>重写<code>keyPathsForValuesAffectingValueForKey</code>方法的时候有一点需要注意，这个方法在Objective-C中的签名是这样：</p>
<blockquote>
<p>(NSSet <em>)keyPathsForValuesAffectingValueForKey:(NSString </em>)key；</p>
</blockquote>
<p>如果照着这个逻辑，我们很可能在 Swift 中将这个方法的声明写成这样：</p>
<blockquote>
<p>override class func keyPathsForValuesAffectingValueForKey(key: NSString) -&gt; NSSet；</p>
</blockquote>
<p>如果这样写，编译器就会报错。因为Swift 中将Objective-C的一些基础类型都已经转变成了Swift的原生类型，所以我们这个方法签名要写成这样才可以通过编译：</p>
<blockquote>
<p>override class func keyPathsForValuesAffectingValueForKey(key: String) -&gt; Set。</p>
</blockquote>
<h2 id="KVO手动通知"><a href="#KVO手动通知" class="headerlink" title="KVO手动通知"></a>KVO手动通知</h2><p>KVO 在默认情况下，只要为某个属性添加了监听对象，在这个属性值改变的时候，就会自动的通知监听者。也有一些情况下，可能我们想手动的处理这些通知的发送， KVO 也是允许我们这样做的。我们可以通过重写</p>
<blockquote>
<p>class func automaticallyNotifiesObservers(forKey key:String) -&gt; Bool</p>
</blockquote>
<p>这个方法告诉KVO，哪些属性是我们想手动处理的，比如我们的Person类中，想对<code>firstName</code>进行处理，就在方法中对<code>firstName</code>这个key返回<code>false</code>：</p>
<h3 id="dynamic关键字"><a href="#dynamic关键字" class="headerlink" title="dynamic关键字"></a>dynamic关键字</h3><p>注意下面我们使用了<code>dynamic</code>标识。这个代表它支持Objective-C Runtime的动态分发机制，我们这里可以理解为 KVO需要使用Objective-C的Runtime机制来实现属性更改的监听。 </p>
<p>Swift中的属性处于性能等方面的考虑默认是关闭动态分发的，所以我们这里面要显式的将属性用<code>dynamic</code>关键字标识出来。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> firstName: <span class="type">String</span>? &#123;</div><div class="line">        <span class="keyword">willSet</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(#function)</span> 将要修改，现在的值是 <span class="subst">\(newValue)</span>"</span>)</div><div class="line">            <span class="keyword">self</span>.willChangeValue(forKey: <span class="string">"firstName"</span>)</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">didSet</span> &#123;</div><div class="line">            <span class="keyword">self</span>.didChangeValue(forKey: <span class="string">"firstName"</span>)</div><div class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(#function)</span> 已修改，原来的值是 <span class="subst">\(oldValue)</span>"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">willChangeValue</span><span class="params">(forKey key: String)</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(key)</span> 将要修改"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didChangeValue</span><span class="params">(forKey key: String)</span></span> &#123;</div><div class="line">         <span class="built_in">print</span>(<span class="string">"<span class="subst">\(key)</span> 已修改"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">automaticallyNotifiesObservers</span>(<span class="title">forKey</span> <span class="title">key</span>:<span class="title">String</span>) -&gt; <span class="title">Bool</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> key == <span class="string">"firstName"</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**执行*/</span></div><div class="line"><span class="keyword">let</span> person = <span class="type">Person</span>()</div><div class="line"><span class="keyword">var</span> context = <span class="string">"this is a context"</span></div><div class="line">person.addObserver(<span class="keyword">self</span>,</div><div class="line">                   forKeyPath: <span class="string">"firstName"</span>,</div><div class="line">                   options: <span class="type">NSKeyValueObservingOptions</span>.new,</div><div class="line">                   context: &amp;context)</div><div class="line">person.setValue(<span class="string">"Bad ass "</span>, forKeyPath: <span class="string">"firstName"</span>)</div><div class="line">person.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"firstName"</span>, context: &amp;context)</div><div class="line"><span class="built_in">print</span>(person.value(forKeyPath: <span class="string">"firstName"</span>))</div><div class="line"></div><div class="line"><span class="comment">/**输出*/</span></div><div class="line">keyPathsForValuesAffectingValue(forKey:)</div><div class="line">firstName 将要修改，现在的值是 <span class="type">Optional</span>(<span class="string">"Bad ass "</span>)</div><div class="line">firstName 将要修改</div><div class="line">firstName 已修改</div><div class="line">firstName 已修改，原来的值是 <span class="literal">nil</span></div><div class="line"><span class="type">Optional</span>(<span class="type">Bad</span> ass )</div></pre></td></tr></table></figure>
<p>这样，我们在修改了<code>fistName</code>属性值后，并不会触发KVO的默认通知行为，是我们自己来控制通知的发送，当然，这需要我们修改<code>firstName</code>属性的实现来进行手工的通知发送，手动通知能让我们对KVO通知进行更细节的控制。但并不常用，大多数情况下使用KVO的自动通知机制就足够了。</p>
<h2 id="KVO和线程"><a href="#KVO和线程" class="headerlink" title="KVO和线程"></a>KVO和线程</h2><p>一个需要注意的地方是，KVO 行为是同步的，并且发生与所观察的值发生变化的同样的线程上。没有队列或者 Run-loop 的处理。手动或者自动调用<code>-didChange...</code>会触发 KVO 通知。</p>
<p>所以，当我们试图从其他线程改变属性值的时候我们应当十分小心，除非能确定所有的观察者都用线程安全的方法处理 KVO 通知。通常来说，我们不推荐把KVO和多线程混起来。如果我们要用多个队列和线程，我们不应该在它们互相之间用 KVO。</p>
<p>KVO是同步运行的这个特性非常强大，只要我们在单一线程上面运行（比如主队列 main queue），KVO会保证下列两种情况的发生：</p>
<ul>
<li><p>首先，如果我们调用一个支持KVO的setter方法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.name = &quot;conqueror&quot;</div></pre></td></tr></table></figure>
<p>KVO能保证所有<code>name</code>的观察者在<code>setter</code>方法返回前被通知到。</p>
</li>
<li><p>其次，如果某个键被观察的时候附上了<code>NSKeyValueObservingOptionPrior</code>这个选项，直到</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">observeValue</span><span class="params">(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?)</span></span></div></pre></td></tr></table></figure>
<p>被调用之前， <code>name</code>的<code>getter</code>方法都会返回同样的值。</p>
<p>​</p>
</li>
</ul>
<h2 id="理解KVO的实现"><a href="#理解KVO的实现" class="headerlink" title="理解KVO的实现"></a>理解KVO的实现</h2><p>基本的流程就是编译器自动为被观察对象创造一个派生类，并将被观察对象的isa指向这个派生类。如果用户注册了对某此目标对象的某一个属性的观察，那么此派生类会重写这个方法，并在其中添加进行通知的代码。</p>
<p>Objective-C在发送消息的时候，会通过isa指针找到当前对象所属的类对象。而类对象中保存着当前对象的实例方法，因此在向此对象发送消息时候，实际上是发送到了派生类对象的方法。</p>
<p>由于编译器对派生类的方法进行了override，并添加了通知代码，因此会向注册的对象发送通知。注意派生类只重写注册了观察者的属性方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>KVO是Cocoa提供的一个很强大的特性，但同时它也有很多坑需要我们注意，比如添加完监听后，要在不需要的时候删除掉监听，否则就会造成意外崩溃。对于有依赖关系的属性需要通过：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">keyPathsForValuesAffectingValue</span>(<span class="title">forKey</span> <span class="title">key</span>: <span class="title">String</span>) -&gt; <span class="title">Set</span></span></div></pre></td></tr></table></figure>
<p>这个方法将依赖关系声明到实体类中。还有各个监听选项的作用不同组合也有不同的作用；</p>
<p>另外需要注意的是观察者观察的是属性，只有遵循KVO变更属性值的方式才会执行KVO的回调方法，<strong>例如是否执行了setter方法、或者是否使用了KVC赋值。</strong></p>
<p>如果赋值没有通过setter方法或者KVC，而是直接修改属性对应的成员变量，例如：仅调用<code>person.name =  &quot;newName&quot;</code>，这时是不会触发KVO机制，所以使用KVO机制的前提是遵循 KVO 的属性设置方式来变更属性值。</p>
<p>对比其他的回调方式，KVO机制的运用的实现，更多的由系统支持，相比Notification、Delegate等更简洁些，并且能够提供观察属性的最新值以及原始值；但是相应的在创建子类、重写方法等等方面的内存消耗是很巨大的。</p>
<p>由于KVO对被观察者的继承和重写是在运行时而不是编译时实现的，如果给定的实例没有观察者，那么KVO不会有任何开销，因为此时根本就没有KVO代码存在。但是即使没有观察者，Delegate和NSNotification还是得工作，这也是KVO此处零开销观察的优势。</p>
<p>所以对于两个类之间的通信，我们可以根据实际开发的环境采用不同的方法，使得开发的项目更加简洁实用。 </p>
<h3 id="KVC与KVO的区别"><a href="#KVC与KVO的区别" class="headerlink" title="KVC与KVO的区别"></a>KVC与KVO的区别</h3><p>KVC(键值编码)，即Key-Value Coding，一个非正式的Protocol，使用字符串(键)访问一个对象实例变量的机制。而不是通过调用Setter、Getter方法等显式的存取方式去访问。<br>KVO(键值监听)，即Key-Value Observing，它提供一种机制，当指定的对象的属性被修改后，对象就会接受到通知，前提是执行了Setter方法、或者使用了KVC赋值。</p>
<h3 id="KVO与Notification的区别"><a href="#KVO与Notification的区别" class="headerlink" title="KVO与Notification的区别"></a>KVO与Notification的区别</h3><p>Notification比KVO多了发送通知的一步，两者都是一对多，但是对象之间直接的交互，Notification需要NotificationCenter来做为中间交互。而KVO如我们介绍的，设置观察者-&gt;处理属性变化，至于中间通知这一环，则隐秘多了。</p>
<p>Notification的优点是监听不局限于属性的变化，还可以对多种多样的状态变化进行监听，监听范围广，例如键盘、前后台等系统通知的使用也更显灵活方便。</p>
<h3 id="KVO与Delegate的区别"><a href="#KVO与Delegate的区别" class="headerlink" title="KVO与Delegate的区别"></a>KVO与Delegate的区别</h3><p>和Delegate一样，KVO和NSNotification的作用都是类与类之间的通信。</p>
<p>但是KVO和NSNotification与Delegate不同的是，KVO和NSNotification都是负责发送接收通知，剩下的事情由系统处理，所以不用返回值；</p>
<p>而Delegate则需要通信的对象通过变量(代理)联系；Delegate一般是一对一，而KVO和NSNotification可以一对多。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.objccn.io/issue-7-3/" target="_blank" rel="external">KVC和KVO</a> -  卢思豪</p>
<p><a href="http://www.jianshu.com/p/e59bb8f59302" target="_blank" rel="external">iOS–KVO的实现原理与具体应用</a> - 啊左</p>
<p><a href="http://swiftcafe.io/2016/01/03/kvc/" target="_blank" rel="external">漫谈 KVC 与 KVO</a> - SwiftCafe</p>
<h2 id="Demo下载请点击这里"><a href="#Demo下载请点击这里" class="headerlink" title="Demo下载请点击这里"></a>Demo下载请<a href="https://github.com/tianziyao/KeyValueObserving" target="_blank" rel="external">点击这里</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;KVO/KVC是观察者模式在Objective-C中的实现，以非正式协议（Category）的形式被定义在NSObject中。从协议的角度看，是定义了一套让开发者遵守的规范和使用的方法。&lt;/p&gt;
&lt;p&gt;在Cocoa的MVC框架中，KVO架起ViewController和Model沟通的桥梁，例如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码中，在模型类A创建属性数据，在控制器中创建观察者，一旦属性数据发生改变就收到观察者收到通知，通过KVO再在控制器使用回调方法处理实现视图B的更新。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="KVO" scheme="http://yoursite.com/tags/KVO/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式 - KVC内部机制&amp;使用场景</title>
    <link href="http://yoursite.com/2016/09/21/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20KVC%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2016/09/21/iOS设计模式 - KVC内部机制/</id>
    <published>2016-09-20T18:24:00.000Z</published>
    <updated>2016-09-21T09:27:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两天面试在KVC的问题上有所欠缺，对于底层了解不够，因此写下这篇文章。这篇文章主要是使用KVC对Key的搜索原理，自己写代码来实现KVC。</p>
<p>关于Apple是如何实现KVC这个问题：</p>
<blockquote>
<p>🙃 🙃 我也不知道…… </p>
</blockquote>
<p>因为没有办法打印出调用过的函数，所以KVC背后的一切还是很神秘的，只能通过几个有限的API来猜想，</p>
<p>对于<code>setValue:forKey:</code> ，在setter存在的情况，KVC 会直接发送<code>set&lt;Key&gt;:</code> 消息赋值；</p>
<p>在setter不在的情况下，且<code>accessInstanceVariablesDirectly</code>方法是true的情况下，会按<code>（_&lt;key&gt;, _&lt;isKey&gt;, &lt;key&gt;, is&lt;Key&gt;）</code>的顺序去查找实例变量，检查其是否存在之后通过<code>object_setIvar</code>给它赋值。</p>
<p>如果都没有就调用<code>setValue:forUNdefinedKey:</code>抛出错误。</p>
<p>对于<code>setValue:forKeyPath:</code>，递归地检查keyPath中的属性是否存在，到达目标路径时再调用<code>setValue:forKey:</code> 完成赋值。</p>
<p>大致上我准备按上面的执行顺序进行实现，由于集合、字典和模型、KeyPath的情况比较复杂，所以我只实现了最普通的存值和取值，下面进入正题：</p>
   <a id="more"></a>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MyError</span>: <span class="title">ErrorType</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">NotExist</span></div><div class="line">    <span class="keyword">case</span> <span class="type">NotNSObjectType</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSObject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setMyValue</span><span class="params">(value value: AnyObject?, forKey key: String?)</span></span> <span class="keyword">throws</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">/**判断Key是否是空值*/</span></div><div class="line">        <span class="keyword">if</span> key!.isEmpty &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="type">MyError</span>.<span class="type">NotExist</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**判断Value是否是空值*/</span></div><div class="line">        <span class="keyword">if</span> value == <span class="literal">nil</span>  &#123;</div><div class="line">            <span class="keyword">self</span>.setMyNilValue(key!)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**判断Value是否是NSObject类型*/</span></div><div class="line">        <span class="keyword">if</span> !(value <span class="keyword">is</span> <span class="type">NSObject</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="type">MyError</span>.<span class="type">NotNSObjectType</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**判断是否存在setKey方法，如果有执行这个方法*/</span></div><div class="line">        <span class="keyword">let</span> funcName = <span class="string">"set"</span> + (key?.capitalizedString)! + <span class="string">":"</span></div><div class="line">        </div><div class="line">        <span class="keyword">let</span> selector = <span class="type">NSSelectorFromString</span>(funcName)</div><div class="line">        <span class="comment">//let selector = Selector.init(funcName)</span></div><div class="line">        <span class="comment">//let selector = #selector(Address.setCity(_:))</span></div><div class="line">        <span class="comment">//print(self.respondsToSelector(selector))</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.respondsToSelector(selector)&#123;</div><div class="line">            <span class="keyword">self</span>.performSelector((selector), withObject: value)</div><div class="line">            <span class="comment">//print("执行setKey方法")</span></div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/**判断该类中是否存在 key、_key、iskey成员，如果有给这个成员赋值*/</span></div><div class="line">        <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">UInt32</span> = <span class="number">0</span></div><div class="line">        <span class="keyword">var</span> flag: <span class="type">Bool</span> = <span class="literal">false</span></div><div class="line">        <span class="keyword">let</span> iVars = class_copyIvarList(<span class="keyword">self</span>.<span class="keyword">dynamicType</span>, &amp;<span class="built_in">count</span>)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</div><div class="line">            <span class="keyword">let</span> iVar = iVars[<span class="type">Int</span>(i)]</div><div class="line">            <span class="keyword">let</span> keyName = <span class="type">NSString</span>(<span class="type">CString</span>: ivar_getName(iVar), encoding: <span class="type">NSUTF8StringEncoding</span>)</div><div class="line">            <span class="keyword">if</span> keyName == key! || keyName == <span class="string">"_"</span> + key! || keyName == <span class="string">"is"</span> + key!&#123;</div><div class="line">                flag = <span class="literal">true</span></div><div class="line">                </div><div class="line">                object_setIvar(<span class="keyword">self</span>, iVar, value)</div><div class="line">                <span class="comment">//print("\(self) \(iVar) \(value)")</span></div><div class="line">                <span class="comment">//print("给\(keyName)赋值")</span></div><div class="line">                <span class="keyword">break</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/**如果以上的成员和方法都不存在，调用未找到key的方法*/</span></div><div class="line">        <span class="keyword">if</span> !flag &#123;</div><div class="line">            <span class="keyword">self</span>.setMyValue(value!, forUndefinedKey: key!)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setMyNilValue</span><span class="params">(key: String?)</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"无法修改<span class="subst">\(key)</span>的值，因为传入的是空值"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setMyValue</span><span class="params">(value: AnyObject, forUndefinedKey key: String)</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"无法将<span class="subst">\(key)</span>的值修改为，因为传入的是空值"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myValueForKey</span><span class="params">(key: String?)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">AnyObject</span>? &#123;</div><div class="line">        </div><div class="line">        <span class="comment">/**判断Key是否是空值*/</span></div><div class="line">        <span class="keyword">if</span> key!.isEmpty &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="type">MyError</span>.<span class="type">NotExist</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**判断是否存在getKey方法，如果有执行这个方法*/</span></div><div class="line">        <span class="keyword">let</span> funcName = <span class="string">"get"</span> + (key?.capitalizedString)! + <span class="string">":"</span></div><div class="line">        <span class="keyword">let</span> selector = <span class="type">NSSelectorFromString</span>(funcName)</div><div class="line">        <span class="comment">//let selector = Selector.init(funcName)</span></div><div class="line">        <span class="comment">//let selector = #selector(Address.setCity(_:))</span></div><div class="line">        <span class="comment">//print(self.respondsToSelector(selector))</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.respondsToSelector(selector)&#123;</div><div class="line">            <span class="keyword">let</span> result =  <span class="keyword">self</span>.performSelector(selector)</div><div class="line">            <span class="comment">//print("执行getKey方法")</span></div><div class="line">            <span class="keyword">return</span> result <span class="keyword">as</span>? <span class="type">AnyObject</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/**判断该类中是否存在 key、_key、iskey成员，如果有给这个成员赋值*/</span></div><div class="line">        <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">UInt32</span> = <span class="number">0</span></div><div class="line">        <span class="keyword">var</span> flag: <span class="type">Bool</span> = <span class="literal">false</span></div><div class="line">        <span class="keyword">let</span> iVars = class_copyIvarList(<span class="keyword">self</span>.<span class="keyword">dynamicType</span>, &amp;<span class="built_in">count</span>)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</div><div class="line">            <span class="keyword">let</span> iVar = iVars[<span class="type">Int</span>(i)]</div><div class="line">            <span class="keyword">let</span> keyName = <span class="type">NSString</span>(<span class="type">CString</span>: ivar_getName(iVar), encoding: <span class="type">NSUTF8StringEncoding</span>)</div><div class="line">            <span class="keyword">if</span> keyName == key! || keyName == <span class="string">"_"</span> + key! || keyName == <span class="string">"is"</span> + key!&#123;</div><div class="line">                flag = <span class="literal">true</span></div><div class="line">                <span class="built_in">print</span>(<span class="string">"取出<span class="subst">\(keyName)</span>的值"</span>)</div><div class="line">                <span class="comment">//print("\(self) \(iVar) \(value)")</span></div><div class="line">                <span class="keyword">return</span> object_getIvar(<span class="keyword">self</span>, iVar)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/**如果以上的成员和方法都不存在，调用未找到key的方法*/</span></div><div class="line">        <span class="keyword">if</span> !flag &#123;</div><div class="line">            <span class="keyword">self</span>.myValueForUndefinedKey(key!)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myValueForUndefinedKey</span><span class="params">(key: String)</span></span> -&gt; <span class="type">AnyObject</span>?&#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"无法取出<span class="subst">\(key)</span>的值，因为属性不存在"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**执行*/</span></div><div class="line"><span class="keyword">let</span> add = <span class="type">Address</span>()</div><div class="line"></div><div class="line">add._country = <span class="string">"China"</span></div><div class="line">add._province = <span class="string">"HeBei"</span></div><div class="line">add._city = <span class="string">"ShiJiaZhuang"</span></div><div class="line">add._province = <span class="string">"ChangAnQu"</span></div><div class="line"></div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">try</span> add.setMyValue(value: <span class="string">"BeiJing"</span>, forKey: <span class="string">"city"</span>)</div><div class="line">    <span class="keyword">try</span> add.setMyValue(value: <span class="string">"USA"</span>, forKey: <span class="string">"country"</span>)</div><div class="line">    <span class="keyword">try</span> add.setMyValue(value: <span class="string">"South"</span>, forKey: <span class="string">""</span>)</div><div class="line">    <span class="keyword">try</span> add.setMyValue(value: <span class="string">"300169"</span>, forKey: <span class="string">"postCode"</span>)</div><div class="line">    <span class="built_in">print</span>(<span class="string">"country:<span class="subst">\(add._country)</span> city:<span class="subst">\(add._city)</span> province:<span class="subst">\(add._province)</span> district<span class="subst">\(add._district)</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> <span class="type">MyError</span>.<span class="type">NotExist</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"key是空的"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> <span class="type">MyError</span>.<span class="type">NotNSObjectType</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"value不是NSObject类型"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"传值出错"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">let</span> country = <span class="keyword">try</span> add.myValueForKey(<span class="string">"country"</span>)</div><div class="line">    <span class="keyword">let</span> city = <span class="keyword">try</span> add.myValueForKey(<span class="string">"city"</span>)</div><div class="line">    <span class="built_in">print</span>(<span class="string">"----------------/n <span class="subst">\(country)</span> <span class="subst">\(city)</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> <span class="type">MyError</span>.<span class="type">NotExist</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"key是空的"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"取值出错"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是根据KVC执行顺序自定义的一段代码，当然也省略了一些功能，总体上的逻辑还是比较清楚的，但是有一点问题，在使用<code>object_setIvar</code>和<code>object_getIvar</code>这两个runtime函数时，程序会频繁崩溃，而自己对runtime认识不足，以后再完整这段代码吧。</p>
<p>关于KVC，除去存取方法，底层执行顺序，错误处理以外，还有几点需要了解：</p>
<h2 id="Value合法性校验"><a href="#Value合法性校验" class="headerlink" title="Value合法性校验"></a>Value合法性校验</h2><p>KVC提供了校验key对应的value是否合法的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">validateValue</span><span class="params">(ioValue: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, forKey inKey: String)</span></span> <span class="keyword">throws</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">validateValue</span><span class="params">(ioValue: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, forKeyPath inKeyPath: String)</span></span> <span class="keyword">throws</span></div></pre></td></tr></table></figure>
<p>如果使用这个方法，需要进行重写，它的使用方法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> _country: <span class="type">String</span>?</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">validateValue</span><span class="params">(ioValue: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, forKey inKey: String)</span></span> <span class="keyword">throws</span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> country = ioValue.memory <span class="keyword">as</span>! <span class="type">String</span></div><div class="line">        <span class="keyword">if</span> country == <span class="string">"Janpan"</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="type">MyError</span>.<span class="type">NotExist</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="type">MyError</span>.<span class="type">Nothing</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**执行*/</span></div><div class="line"><span class="keyword">let</span> add = <span class="type">Address</span>()</div><div class="line"><span class="keyword">var</span> value: <span class="type">AnyObject</span>? = <span class="string">"Janpan"</span></div><div class="line"></div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">try</span> add.validateValue(&amp;value, forKey: <span class="string">"_country"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> <span class="type">MyError</span>.<span class="type">NotExist</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"输入有误，请重新输入"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> <span class="type">MyError</span>.<span class="type">Nothing</span> &#123;</div><div class="line">    add.setValue(value, forKey: <span class="string">"_country"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> &#123;&#125;</div><div class="line"><span class="built_in">print</span>(add._country)</div><div class="line"></div><div class="line"><span class="comment">/**当 var value: AnyObject? = "Janpan" 时输出*/</span></div><div class="line">输入有误，请重新输入</div><div class="line"><span class="literal">nil</span></div><div class="line"><span class="comment">/**当 var value: AnyObject? = "Chain" 时输出*/</span></div><div class="line"><span class="type">Optional</span>(<span class="string">"China"</span>)</div></pre></td></tr></table></figure>
<p>这样就实现了先对传入值的合法性进行校验，无误后再进行赋值，如上面的代码，当我们需要验证能不能用KVC设定某个值时，可以将其重写后调用</p>
<blockquote>
<p><code>validateValue: forKey:</code></p>
</blockquote>
<p>这个方法来验证，那么KVC就会直接调用这个方法来返回。<strong>需要注意的是即使重写了该方法，如果我们没有主动进行调用，KVC也不会主动去做验证，所以这个方法需要手动调用。</strong></p>
<h2 id="KVC的应用场景"><a href="#KVC的应用场景" class="headerlink" title="KVC的应用场景"></a>KVC的应用场景</h2><p>作为iOS平台的知名黑魔法，KVC有很多奇特的作用，KVC在iOS开发中是绝不可少的利器，这种基于运行时的编程方式极大地提高了灵活性，简化了代码，它的常见作用有以下几点：</p>
<h2 id="动态的存值和取值"><a href="#动态的存值和取值" class="headerlink" title="动态的存值和取值"></a>动态的存值和取值</h2><p>🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 </p>
<h2 id="访问和修改私有的成员"><a href="#访问和修改私有的成员" class="headerlink" title="访问和修改私有的成员"></a>访问和修改私有的成员</h2><p>对于类里的私有属性，无论Swift还是Objective-C都是无法直接访问的，但是KVC是可以的。</p>
<h2 id="Model和字典的互相转换"><a href="#Model和字典的互相转换" class="headerlink" title="Model和字典的互相转换"></a>Model和字典的互相转换</h2><p>这是KVC又一个强大之处，只需要很少的代码量即可完成很多功能。</p>
<h2 id="修改控件的内部属性"><a href="#修改控件的内部属性" class="headerlink" title="修改控件的内部属性"></a>修改控件的内部属性</h2><p>这也是iOS开发中必不可少的小技巧。众所周知很多UI控件都由很多内部UI控件组合而成的，但是Apple没有提供这访问这些控件的API，这样我们就无法正常地访问和修改这些控件的样式。</p>
<p>而KVC在大多数情况可下可以解决这个问题。比如个性化UITextField中的placeHolderText，一般情况下可以运用runtime来获取Apple不想开放的属性名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**执行*/</span></div><div class="line"><span class="keyword">let</span> <span class="built_in">count</span>:<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">UInt32</span>&gt; =  <span class="literal">nil</span></div><div class="line"><span class="keyword">var</span> properties = class_copyIvarList(<span class="type">UITextField</span>.<span class="keyword">self</span>, <span class="built_in">count</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span> properties.memory.debugDescription !=  <span class="string">"0x0000000000000000"</span>&#123;</div><div class="line">    <span class="keyword">let</span> t = ivar_getName(properties.memory)</div><div class="line">    <span class="keyword">let</span> n = <span class="type">NSString</span>(<span class="type">CString</span>: t, encoding: <span class="type">NSUTF8StringEncoding</span>)</div><div class="line">    <span class="built_in">print</span>(n)</div><div class="line">    properties = properties.successor()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**输出*/</span></div><div class="line">......</div><div class="line"><span class="type">Optional</span>(_background)</div><div class="line"><span class="type">Optional</span>(_disabledBackground)</div><div class="line"><span class="type">Optional</span>(_clearButtonMode)</div><div class="line"><span class="type">Optional</span>(_leftView)</div><div class="line"><span class="type">Optional</span>(_leftViewMode)</div><div class="line"><span class="type">Optional</span>(_rightView)</div><div class="line"><span class="type">Optional</span>(_rightViewMode)</div><div class="line"><span class="type">Optional</span>(_traits)</div><div class="line"><span class="type">Optional</span>(_nonAtomTraits)</div><div class="line"><span class="type">Optional</span>(_fullFontSize)</div><div class="line"><span class="type">Optional</span>(_padding)</div><div class="line"><span class="type">Optional</span>(_selectionRangeWhenNotEditing)</div><div class="line">......</div></pre></td></tr></table></figure>
<p>可以从里面看到其他还有很多东西可以修改，运用KVC设值可以获得自己想要的效果。</p>
<h2 id="KVC操作集合"><a href="#KVC操作集合" class="headerlink" title="KVC操作集合"></a>KVC操作集合</h2><p>Apple对KVC的<code>valueForKey:</code>方法作了一些特殊的实现，比如说NSArray和NSSet这样的容器类就实现了这些方法，所以可以用KVC很方便地操作集合。</p>
<h3 id="高阶信息传递"><a href="#高阶信息传递" class="headerlink" title="高阶信息传递"></a>高阶信息传递</h3><p>当对容器类使用KVC时，<code>valueForKey:</code>将会被传递给容器中的每一个对象，而不是容器本身进行操作。结果会被添加进返回的容器中，这样，开发者可以很方便的操作集合来返回另一个集合：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**执行*/</span></div><div class="line"><span class="keyword">let</span> arrStr: <span class="type">NSArray</span> = [<span class="string">"english"</span>, <span class="string">"franch"</span>, <span class="string">"chinese"</span>]</div><div class="line"><span class="keyword">let</span> arrCapStr = arrStr.value(forKey: <span class="string">"capitalizedString"</span>)</div><div class="line"><span class="built_in">print</span>(arrCapStr <span class="keyword">as</span>! <span class="type">NSArray</span>)</div><div class="line"></div><div class="line"><span class="keyword">let</span> arrStrLength = arrStr.value(forKeyPath: <span class="string">"capitalizedString.length"</span>)</div><div class="line"><span class="built_in">print</span>(arrStrLength! <span class="keyword">as</span>! <span class="type">NSArray</span>)</div><div class="line"></div><div class="line"><span class="comment">/**输出*/</span></div><div class="line">(</div><div class="line">    <span class="type">English</span>,</div><div class="line">    <span class="type">Franch</span>,</div><div class="line">    <span class="type">Chinese</span></div><div class="line">)</div><div class="line">(</div><div class="line">    <span class="number">7</span>,</div><div class="line">    <span class="number">6</span>,</div><div class="line">    <span class="number">7</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>方法<code>capitalizedString</code>被传递到NSArray中的每一项，这样，NSArray的每一员都会执行<code>capitalizedString</code>并返回一个包含结果的新的NSArray。从打印结果可以看出，所有String都成功以转成了大写。<br>同样如果要执行多个方法也可以用<code>valueForKeyPath:</code>方法。它先会对每一个成员调用 <code>capitalizedString</code>方法，然后再调用length，因为lenth方法返回是一个数字，所以返回结果以NSNumber的形式保存在新数组里。</p>
<h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p>当然了，KVC除了传值取值，访问和修改私有变量，修改控件属性，操作集合、字典和模型，更重要的就是KVO了。</p>
<h2 id="Demo下载请点击这里"><a href="#Demo下载请点击这里" class="headerlink" title="Demo下载请点击这里"></a>Demo下载请<a href="https://github.com/tianziyao/MyCustomKVC" target="_blank" rel="external">点击这里</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天面试在KVC的问题上有所欠缺，对于底层了解不够，因此写下这篇文章。这篇文章主要是使用KVC对Key的搜索原理，自己写代码来实现KVC。&lt;/p&gt;
&lt;p&gt;关于Apple是如何实现KVC这个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙃 🙃 我也不知道…… &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为没有办法打印出调用过的函数，所以KVC背后的一切还是很神秘的，只能通过几个有限的API来猜想，&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;setValue:forKey:&lt;/code&gt; ，在setter存在的情况，KVC 会直接发送&lt;code&gt;set&amp;lt;Key&amp;gt;:&lt;/code&gt; 消息赋值；&lt;/p&gt;
&lt;p&gt;在setter不在的情况下，且&lt;code&gt;accessInstanceVariablesDirectly&lt;/code&gt;方法是true的情况下，会按&lt;code&gt;（_&amp;lt;key&amp;gt;, _&amp;lt;isKey&amp;gt;, &amp;lt;key&amp;gt;, is&amp;lt;Key&amp;gt;）&lt;/code&gt;的顺序去查找实例变量，检查其是否存在之后通过&lt;code&gt;object_setIvar&lt;/code&gt;给它赋值。&lt;/p&gt;
&lt;p&gt;如果都没有就调用&lt;code&gt;setValue:forUNdefinedKey:&lt;/code&gt;抛出错误。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;setValue:forKeyPath:&lt;/code&gt;，递归地检查keyPath中的属性是否存在，到达目标路径时再调用&lt;code&gt;setValue:forKey:&lt;/code&gt; 完成赋值。&lt;/p&gt;
&lt;p&gt;大致上我准备按上面的执行顺序进行实现，由于集合、字典和模型、KeyPath的情况比较复杂，所以我只实现了最普通的存值和取值，下面进入正题：&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="KVC" scheme="http://yoursite.com/tags/KVC/"/>
    
  </entry>
  
  <entry>
    <title>iOS Socket通讯 - Socket C/S实例</title>
    <link href="http://yoursite.com/2016/09/18/iOS%E9%80%9A%E8%AE%AF%20-%20Socket%20CS%E5%AE%9E%E4%BE%8B/"/>
    <id>http://yoursite.com/2016/09/18/iOS通讯 - Socket CS实例/</id>
    <published>2016-09-17T18:24:00.000Z</published>
    <updated>2016-09-20T05:29:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS提供的Socket网络编程的接口有CFSocket，BSD Socket，比较著名的第三方库是AsyncSocket。</p>
<ul>
<li><strong>BSD Socket</strong> 是UNIX系统中通用的网络接口，它不仅支持各种不同的网络类型，而且也是一种内部进程之间的通信机制。而iOS系统其实本质就是UNIX，所以可以用，但是比较复杂。</li>
<li><strong>CFSocket</strong> 是苹果提供给我们的使用Socket的方式。</li>
<li><strong>AsyncSocket</strong> 是一个应用比较广泛的开源库。</li>
</ul>
<p>下面我们用代码来演示如何使用AsyncSocket来创建一个服务器和客户端。</p>
<p>AsyncSocket全名是<strong>CocoaAsyncSocket</strong>，它的GitHub地址<a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="external">点此访问</a>。AsyncSocket使用CocoaPods安装和拖放安装有所不同。CocoaPods上的版本只有GCDAsyncSocket，GItHub上多了RunloopAsyncSocket，而后者现在已经弃用，建议直接使用CocoaPods安装。</p>
<p><strong>缺点是<code>onsocketWillDisconnect</code>这个代理方法在GCD的版本里暂时没有，也没有找到替代方法。</strong></p>
<p>下面开始使用AsyncSocket编写服务器端的程序，首先说一下要实现的目的：</p>
<ol>
<li>用户输入昵称，将昵称发送给服务器，服务器返回在线名单；</li>
<li>客户端收到在线名单，利用在线名单生成联系人列表；</li>
<li>点击联系人列表，用户和服务器进行对话；</li>
</ol>
<p>下面开始进入正题：</p>
   <a id="more"></a>
<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p>这里创建的是Mac的Application，首先创建：</p>
<h3 id="Socket单例类"><a href="#Socket单例类" class="headerlink" title="Socket单例类"></a>Socket单例类</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySocket</span>: <span class="title">GCDAsyncSocketDelegate</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> listener: <span class="type">GCDAsyncSocket</span>!</div><div class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedSocket = <span class="type">MySocket</span>()</div><div class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</div><div class="line">        <span class="keyword">let</span> globalQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</div><div class="line">        listener = <span class="type">GCDAsyncSocket</span>(delegate: <span class="keyword">self</span>,delegateQueue: globalQueue)</div><div class="line">        listener.delegate = <span class="keyword">self</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>添加3个属性，创建监听的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> isRuning: <span class="type">Bool</span> = <span class="literal">false</span></div><div class="line"><span class="keyword">var</span> port: <span class="type">UInt16</span>!</div><div class="line"><span class="keyword">var</span> host: <span class="type">String</span>!</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">startListen</span><span class="params">()</span></span> &#123;</div><div class="line"><span class="keyword">if</span> !isRuning &#123;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">try</span> listener.acceptOnPort(port)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"开始监听 <span class="subst">\(host)</span> <span class="subst">\(port)</span>"</span>)</div><div class="line">        isRuning = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"服务开启失败"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"重新监听"</span>)</div><div class="line">    listener.disconnect()</div><div class="line">    <span class="keyword">for</span> connectionSocket <span class="keyword">in</span> connectionSockets &#123;</div><div class="line">        connectionSocket.disconnect()</div><div class="line">    &#125;</div><div class="line">    isRuning = <span class="literal">false</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>添加一个属性，创建发送方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> currentSocket: <span class="type">GCDAsyncSocket</span>!</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMessage</span><span class="params">(message: NSData)</span></span> &#123;</div><div class="line">    currentSocket.writeData(message, withTimeout: -<span class="number">1</span>, tag: <span class="number">0</span>)</div><div class="line">    <span class="built_in">print</span>(<span class="string">"发送消息"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>添加发送消息成功和连接成功两个代理方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> connectionSockets: [<span class="type">GCDAsyncSocket</span>] = []</div><div class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">socket</span><span class="params">(sock: GCDAsyncSocket, didWriteDataWithTag tag: Int)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"发送消息成功之后回调"</span>)</div><div class="line">    listener.readDataWithTimeout(-<span class="number">1</span>, tag: tag)</div><div class="line">&#125;</div><div class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">socket</span><span class="params">(sock: GCDAsyncSocket, didAcceptNewSocket newSocket: GCDAsyncSocket)</span></span> &#123;</div><div class="line">    newSocket.readDataWithTimeout(-<span class="number">1</span>, tag: <span class="number">0</span>)</div><div class="line">    connectionSockets.append(newSocket)</div><div class="line">    <span class="built_in">print</span>(<span class="string">"收到新的socket"</span>)</div><div class="line">    <span class="built_in">print</span>(sock.userData)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>添加收到消息的代理事件方法，并处理收到的消息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> currentHost: <span class="type">String</span>!</div><div class="line"><span class="keyword">var</span> recivieMessage: (<span class="type">String</span> -&gt; ())!</div><div class="line"><span class="keyword">var</span> userStates: [[<span class="type">String</span>!]] = []</div><div class="line"></div><div class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">socket</span><span class="params">(sock: GCDAsyncSocket, didReadData data: NSData, withTag tag: Int)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> msg = <span class="type">String</span>(data: data, encoding: <span class="type">NSUTF8StringEncoding</span>)</div><div class="line">    recivieMessage(msg!)</div><div class="line">    <span class="keyword">let</span> tmpMsg = msg?.componentsSeparatedByString(<span class="string">":"</span>)</div><div class="line">    <span class="keyword">if</span> tmpMsg?.first == <span class="string">"user"</span> &#123;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            currentHost = <span class="string">"<span class="subst">\(sock.connectedHost!)</span>"</span></div><div class="line">            <span class="keyword">let</span> tmpArr = [currentHost, <span class="string">"<span class="subst">\(tmpMsg![<span class="number">1</span>])</span>"</span>, <span class="string">"1"</span>]</div><div class="line">            userStates.append(tmpArr)</div><div class="line">            <span class="keyword">let</span> json = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.dataWithJSONObject(userStates, options: .<span class="type">PrettyPrinted</span>)</div><div class="line">            sock.writeData(json, withTimeout: -<span class="number">1</span>, tag: <span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"传输出错"</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    sock.readDataWithTimeout(-<span class="number">1</span>, tag: <span class="number">0</span>)</div><div class="line">    currentSocket = sock</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>添加断开连接的代理事件方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">socketDidDisconnect</span><span class="params">(sock: GCDAsyncSocket, withError err: NSError?)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"socket连接已经关闭 <span class="subst">\(err)</span>"</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;userStates.<span class="built_in">count</span> &#123;</div><div class="line">        <span class="keyword">if</span> userStates[i][<span class="number">0</span>] == currentHost &#123;</div><div class="line">            userStates[i][<span class="number">2</span>] = <span class="string">"0"</span></div><div class="line">            <span class="keyword">let</span> msg = <span class="string">"<span class="subst">\(userStates[i][<span class="number">1</span>])</span>已下线"</span></div><div class="line">            sendMessages(msg, sockets: connectionSockets)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时服务器的Socket封装已经做好了，下面是：</p>
<h3 id="Server-UI"><a href="#Server-UI" class="headerlink" title="Server UI"></a>Server UI</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">NSViewController</span>, <span class="title">GCDAsyncSocketDelegate</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> messageField: <span class="type">NSTextField</span>!</div><div class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> receiveField: <span class="type">NSTextField</span>!</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> socket: <span class="type">MySocket</span>!</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        socket = <span class="type">MySocket</span>.sharedSocket</div><div class="line">        socket.port = <span class="number">1234</span></div><div class="line">        socket.host = <span class="string">"127.0.0.1"</span></div><div class="line">        socket.startListen()</div><div class="line">        socket.recivieMessage = &#123; msg <span class="keyword">in</span></div><div class="line">            <span class="keyword">self</span>.receiveField.stringValue = msg</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="keyword">var</span> representedObject: <span class="type">AnyObject</span>? &#123;</div><div class="line">        <span class="keyword">didSet</span> &#123;</div><div class="line">            <span class="comment">// Update the view, if already loaded.</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">sendButtonDidTouch</span><span class="params">(sender: AnyObject)</span></span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> messageField.stringValue.isEmpty &#123;</div><div class="line">            receiveField.stringValue = <span class="string">"请输入消息"</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            socket.sendMessage((<span class="string">"msg:"</span> + messageField.stringValue).dataUsingEncoding(<span class="type">NSUTF8StringEncoding</span>)!)</div><div class="line">            messageField.stringValue = <span class="string">""</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是客户端的制作，这里是iOS的Application：</p>
<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p>同样首先封装一个Socket单例类：</p>
<h3 id="Socket单例类-1"><a href="#Socket单例类-1" class="headerlink" title="Socket单例类"></a>Socket单例类</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySocket</span>: <span class="title">GCDAsyncSocketDelegate</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> port: <span class="type">UInt16</span>!</div><div class="line">    <span class="keyword">var</span> host: <span class="type">String</span>!</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> listener: <span class="type">GCDAsyncSocket</span>!</div><div class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedSocket = <span class="type">MySocket</span>()</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</div><div class="line">        <span class="keyword">let</span> globalQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</div><div class="line">        listener = <span class="type">GCDAsyncSocket</span>(delegate: <span class="keyword">self</span>,delegateQueue: globalQueue)</div><div class="line">    &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>客户端和服务器的区别是不需要监听，但需要连接，所以创建连接服务器的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectToServer</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">try</span> listener.connectToHost(host, onPort: port)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"连接服务器出错"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建消息发送的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMessage</span><span class="params">(message: NSData)</span></span> &#123;</div><div class="line">    listener.writeData(message, withTimeout: -<span class="number">1</span>, tag: <span class="number">0</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>添加消息发送成功后的代理方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">socket</span><span class="params">(sock: GCDAsyncSocket, didWriteDataWithTag tag: Int)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"发送消息成功之后回调"</span>)</div><div class="line">    listener.readDataWithTimeout(-<span class="number">1</span>, tag: tag)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建两个闭包，添加接收消息的代理方法，并处理接收的数据：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> receiveMessage: (<span class="type">String</span> -&gt; ())!</div><div class="line">   <span class="keyword">var</span> receuveUserStates: (<span class="type">NSArray</span> -&gt; <span class="type">Void</span>)!</div><div class="line">   </div><div class="line">   <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">socket</span><span class="params">(sock: GCDAsyncSocket, didReadData data: NSData, withTag tag: Int)</span></span> &#123;</div><div class="line">       </div><div class="line">       <span class="keyword">let</span> receive = <span class="type">String</span>(data: data, encoding: <span class="type">NSUTF8StringEncoding</span>)</div><div class="line">       <span class="keyword">let</span> tmpMsg = receive?.componentsSeparatedByString(<span class="string">":"</span>)</div><div class="line">       </div><div class="line">       <span class="keyword">if</span> tmpMsg?.first == <span class="string">"msg"</span> &#123;</div><div class="line">           receiveMessage(receive!)</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">do</span> &#123;</div><div class="line">               <span class="keyword">let</span> receive = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(data, options: .<span class="type">MutableLeaves</span>) <span class="keyword">as</span>! <span class="type">NSArray</span></div><div class="line">               receuveUserStates(receive)</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">catch</span> &#123;</div><div class="line">               <span class="built_in">print</span>(<span class="string">"读取Json出错"</span>)</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       sock.readDataWithTimeout(-<span class="number">1</span>, tag: <span class="number">0</span>)</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这样客户端的Socket就封装好了，下面是客户端的UI部分：</p>
<h3 id="Client-UI"><a href="#Client-UI" class="headerlink" title="Client UI"></a>Client UI</h3><p>客户端的UI比较复杂，分为3层，第一层是用户输入自己的昵称，将昵称发送到服务器，服务器返回在线名单，利用在线名单进入下一层。</p>
<h4 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h4><p>搭建UI，点击发送时连接服务器并发送格式消息，利用闭包将传回的数据并打开第二层：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainVC</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> nicenameField: <span class="type">UITextField</span>!</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> userStates: <span class="type">NSArray</span>!</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        <span class="type">MySocket</span>.sharedSocket.receuveUserStates = &#123; arr <span class="keyword">in</span></div><div class="line">            <span class="keyword">self</span>.userStates = arr</div><div class="line">            <span class="keyword">let</span> tableVC = <span class="type">TableVC</span>()</div><div class="line">            <span class="built_in">print</span>(<span class="keyword">self</span>.userStates)</div><div class="line">            tableVC.userStates = <span class="keyword">self</span>.userStates</div><div class="line">            dispatch_async(dispatch_get_main_queue(), &#123; </div><div class="line">                <span class="keyword">self</span>.presentViewController(tableVC, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">            &#125;)</div><div class="line">            <span class="built_in">print</span>(<span class="string">"闭包userStates"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">submitButtonClicked</span><span class="params">(sender: AnyObject)</span></span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> nicenameField.text == <span class="string">""</span> &#123;</div><div class="line">            <span class="keyword">let</span> alert = <span class="type">UIAlertController</span>(title: <span class="string">"提示"</span>, message: <span class="string">"请输入昵称"</span>, preferredStyle: .<span class="type">Alert</span>)</div><div class="line">            <span class="keyword">let</span> action = <span class="type">UIAlertAction</span>(title: <span class="string">"好的"</span>, style: .<span class="type">Default</span>, handler: &#123; (action) <span class="keyword">in</span></div><div class="line">                <span class="built_in">print</span>(<span class="string">"提示框被点击"</span>)</div><div class="line">            &#125;)</div><div class="line">            alert.addAction(action)</div><div class="line">            <span class="keyword">self</span>.presentViewController(alert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">let</span> socket = <span class="type">MySocket</span>.sharedSocket</div><div class="line">            socket.host = <span class="string">"127.0.0.1"</span></div><div class="line">            socket.port = <span class="number">1234</span></div><div class="line">            socket.connectToServer()</div><div class="line">            socket.sendMessage(<span class="string">"user:<span class="subst">\(nicenameField.text!)</span>"</span>.dataUsingEncoding(<span class="type">NSUTF8StringEncoding</span>)!)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h4><p>利用收到的在线名单，创建TableView列表，点击列表项时打开第三层：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableVC</span>: <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> nickname: <span class="type">String</span>!</div><div class="line">    <span class="keyword">var</span> myNavigationBar: <span class="type">UINavigationBar</span>!</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> userStates: <span class="type">NSArray</span>!</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        installUI()</div><div class="line">        <span class="built_in">print</span>(userStates)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">44</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">numberOfSectionsInTableView</span><span class="params">(tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> userStates.<span class="built_in">count</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(indexPath.row)</div><div class="line">        <span class="keyword">let</span> ioVC = <span class="type">IOVC</span>()</div><div class="line">        <span class="keyword">let</span> tmpArr = userStates[indexPath.row] <span class="keyword">as</span>! <span class="type">NSArray</span></div><div class="line">        ioVC.nickname = tmpArr[<span class="number">1</span>] <span class="keyword">as</span>! <span class="type">String</span></div><div class="line">        <span class="keyword">self</span>.presentViewController(ioVC, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(<span class="string">"TableCell"</span>, forIndexPath: indexPath) <span class="keyword">as</span>! <span class="type">TableCell</span></div><div class="line">        <span class="keyword">let</span> tmpArr = userStates[indexPath.row] <span class="keyword">as</span>! <span class="type">NSArray</span></div><div class="line">        cell.nicknameLabel.text = (tmpArr[<span class="number">1</span>] <span class="keyword">as</span>? <span class="type">String</span>)!</div><div class="line">        <span class="built_in">print</span>(tmpArr[<span class="number">1</span>] <span class="keyword">as</span>? <span class="type">String</span>)</div><div class="line">        <span class="keyword">if</span> tmpArr[<span class="number">2</span>] <span class="keyword">as</span>! <span class="type">String</span> == <span class="string">"1"</span> &#123;</div><div class="line">            cell.stateView.backgroundColor = <span class="type">UIColor</span>.greenColor()</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cell</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">installUI</span><span class="params">()</span></span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> nib = <span class="type">UINib</span>(nibName: <span class="string">"TableCell"</span>, bundle: <span class="literal">nil</span>)</div><div class="line">        <span class="keyword">self</span>.tableView.registerNib(nib, forCellReuseIdentifier: <span class="string">"TableCell"</span>)</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> screenRect = <span class="type">UIScreen</span>.mainScreen().bounds</div><div class="line">        myNavigationBar = <span class="type">UINavigationBar</span>(frame: <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, screenRect.size.width, <span class="number">64</span>))</div><div class="line">        myNavigationBar.tintColor = <span class="type">UIColor</span>.redColor()</div><div class="line">        <span class="keyword">let</span> navigationTitleItem = <span class="type">UINavigationItem</span>(title: <span class="string">"当前在线"</span>)</div><div class="line">        myNavigationBar.pushNavigationItem(navigationTitleItem, animated: <span class="literal">true</span>)</div><div class="line">        myNavigationBar.barStyle = .<span class="type">Black</span></div><div class="line">        <span class="keyword">self</span>.tableView.tableHeaderView = myNavigationBar</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="第三层"><a href="#第三层" class="headerlink" title="第三层"></a>第三层</h4><p>点击发送对话到服务器，利用闭包将服务器返回的消息显示在这里：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOVC</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> nickname: <span class="type">String</span>!</div><div class="line">    <span class="keyword">var</span> messageField: <span class="type">UITextField</span>!</div><div class="line">    <span class="keyword">var</span> submitButton: <span class="type">UIButton</span>!</div><div class="line">    <span class="keyword">var</span> receiveView: <span class="type">UITextView</span>!</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">        installUI(nickname)</div><div class="line">        <span class="type">MySocket</span>.sharedSocket.receiveMessage = &#123; receive <span class="keyword">in</span></div><div class="line">            </div><div class="line">            dispatch_async(dispatch_get_main_queue(), &#123; </div><div class="line">                <span class="keyword">self</span>.receiveView.text = receive</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">submitButtonDidTouch</span><span class="params">()</span></span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> messageField.text == <span class="string">""</span> &#123;</div><div class="line">            <span class="keyword">let</span> alert = <span class="type">UIAlertController</span>(title: <span class="string">"提示"</span>, message: <span class="string">"发送消息不能为空"</span>, preferredStyle: .<span class="type">Alert</span>)</div><div class="line">            <span class="keyword">let</span> action = <span class="type">UIAlertAction</span>(title: <span class="string">"好的"</span>, style: .<span class="type">Default</span>, handler: &#123; (action) <span class="keyword">in</span></div><div class="line">                <span class="built_in">print</span>(<span class="string">"提示框被点击"</span>)</div><div class="line">            &#125;)</div><div class="line">            alert.addAction(action)</div><div class="line">            <span class="keyword">self</span>.presentViewController(alert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">let</span> message = (<span class="string">"<span class="subst">\(nickname)</span>:"</span>+messageField.text!).dataUsingEncoding(<span class="type">NSUTF8StringEncoding</span>)</div><div class="line">            <span class="keyword">let</span> socket = <span class="type">MySocket</span>.sharedSocket</div><div class="line">            socket.sendMessage(message!)</div><div class="line">            messageField.text = <span class="string">""</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">installUI</span><span class="params">(nickname: String)</span></span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">self</span>.view.backgroundColor = <span class="type">UIColor</span>(red: <span class="number">0</span>/<span class="number">255</span>, green: <span class="number">204</span>/<span class="number">255</span>, blue: <span class="number">102</span>/<span class="number">255</span>, alpha: <span class="number">1</span>)</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> screenBouns = <span class="type">UIScreen</span>.mainScreen().bounds</div><div class="line">        <span class="keyword">let</span> navigationBar = <span class="type">UINavigationBar</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: screenBouns.size.width, height: <span class="number">64</span>))</div><div class="line">        <span class="keyword">let</span> navigationTitle = <span class="type">UINavigationItem</span>(title: nickname)</div><div class="line">        navigationBar.pushNavigationItem(navigationTitle, animated: <span class="literal">true</span>)</div><div class="line">        navigationBar.barStyle = .<span class="type">Black</span></div><div class="line">        <span class="keyword">self</span>.view.addSubview(navigationBar)</div><div class="line">        </div><div class="line">        messageField = <span class="type">UITextField</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: screenBouns.size.width, height: <span class="number">30</span>))</div><div class="line">        messageField.center = <span class="keyword">self</span>.view.center</div><div class="line">        messageField.center.y = messageField.center.y + <span class="number">30</span></div><div class="line">        messageField.borderStyle = .<span class="type">None</span></div><div class="line">        messageField.textAlignment = .<span class="type">Center</span></div><div class="line">        messageField.font = <span class="type">UIFont</span>.systemFontOfSize(<span class="number">14</span>)</div><div class="line">        messageField.textColor = <span class="type">UIColor</span>.whiteColor()</div><div class="line">        <span class="keyword">self</span>.view.addSubview(messageField)</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> topCutLine = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">20</span>, y: <span class="number">0</span>, width: screenBouns.size.width - <span class="number">40</span>, height: <span class="number">1</span>))</div><div class="line">        topCutLine.backgroundColor = <span class="type">UIColor</span>.whiteColor()</div><div class="line">        topCutLine.center = messageField.center</div><div class="line">        topCutLine.center.y = messageField.center.y - <span class="number">20</span></div><div class="line">        <span class="keyword">self</span>.view.addSubview(topCutLine)</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> bottomCutLine = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">20</span>, y: <span class="number">0</span>, width: screenBouns.size.width - <span class="number">40</span>, height: <span class="number">1</span>))</div><div class="line">        bottomCutLine.backgroundColor = <span class="type">UIColor</span>.whiteColor()</div><div class="line">        bottomCutLine.center = messageField.center</div><div class="line">        bottomCutLine.center.y = messageField.center.y + <span class="number">20</span></div><div class="line">        <span class="keyword">self</span>.view.addSubview(bottomCutLine)</div><div class="line">        </div><div class="line">        submitButton = <span class="type">UIButton</span>(frame: <span class="type">CGRect</span>(x: <span class="number">20</span>, y: <span class="number">0</span>, width: screenBouns.size.width - <span class="number">40</span>, height: <span class="number">44</span>))</div><div class="line">        submitButton.backgroundColor = <span class="type">UIColor</span>.darkGrayColor()</div><div class="line">        submitButton.layer.cornerRadius = <span class="number">5</span></div><div class="line">        submitButton.setTitle(<span class="string">"发送到服务器"</span>, forState: .<span class="type">Normal</span>)</div><div class="line">        submitButton.titleLabel?.font = <span class="type">UIFont</span>.systemFontOfSize(<span class="number">15</span>)</div><div class="line">        submitButton.setTitleColor(<span class="type">UIColor</span>.whiteColor(), forState: .<span class="type">Normal</span>)</div><div class="line">        submitButton.center = <span class="keyword">self</span>.view.center</div><div class="line">        submitButton.center.y = <span class="keyword">self</span>.view.frame.size.height - <span class="number">68</span></div><div class="line">        submitButton.addTarget(<span class="keyword">self</span>, action: #selector(<span class="type">IOVC</span>.submitButtonDidTouch), forControlEvents: .<span class="type">TouchUpInside</span>)</div><div class="line">        <span class="keyword">self</span>.view.addSubview(submitButton)</div><div class="line">        </div><div class="line">        receiveView = <span class="type">UITextView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">20</span>, y: <span class="number">0</span>, width: screenBouns.size.width - <span class="number">40</span>, height: <span class="number">88</span>))</div><div class="line">        receiveView.textAlignment = .<span class="type">Center</span></div><div class="line">        receiveView.backgroundColor = <span class="type">UIColor</span>.clearColor()</div><div class="line">        receiveView.text = <span class="string">"等待回复"</span></div><div class="line">        receiveView.textColor = <span class="type">UIColor</span>.whiteColor()</div><div class="line">        receiveView.font = <span class="type">UIFont</span>.systemFontOfSize(<span class="number">14</span>)</div><div class="line">        receiveView.center = <span class="keyword">self</span>.view.center</div><div class="line">        receiveView.center.y = <span class="number">120</span></div><div class="line">        <span class="keyword">self</span>.view.addSubview(receiveView)</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Demo下载请点击这里"><a href="#Demo下载请点击这里" class="headerlink" title="Demo下载请点击这里"></a>Demo下载请<a href="https://github.com/tianziyao/Socket-C-S" target="_blank" rel="external">点击这里</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS提供的Socket网络编程的接口有CFSocket，BSD Socket，比较著名的第三方库是AsyncSocket。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;BSD Socket&lt;/strong&gt; 是UNIX系统中通用的网络接口，它不仅支持各种不同的网络类型，而且也是一种内部进程之间的通信机制。而iOS系统其实本质就是UNIX，所以可以用，但是比较复杂。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CFSocket&lt;/strong&gt; 是苹果提供给我们的使用Socket的方式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AsyncSocket&lt;/strong&gt; 是一个应用比较广泛的开源库。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们用代码来演示如何使用AsyncSocket来创建一个服务器和客户端。&lt;/p&gt;
&lt;p&gt;AsyncSocket全名是&lt;strong&gt;CocoaAsyncSocket&lt;/strong&gt;，它的GitHub地址&lt;a href=&quot;https://github.com/robbiehanson/CocoaAsyncSocket&quot;&gt;点此访问&lt;/a&gt;。AsyncSocket使用CocoaPods安装和拖放安装有所不同。CocoaPods上的版本只有GCDAsyncSocket，GItHub上多了RunloopAsyncSocket，而后者现在已经弃用，建议直接使用CocoaPods安装。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点是&lt;code&gt;onsocketWillDisconnect&lt;/code&gt;这个代理方法在GCD的版本里暂时没有，也没有找到替代方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面开始使用AsyncSocket编写服务器端的程序，首先说一下要实现的目的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户输入昵称，将昵称发送给服务器，服务器返回在线名单；&lt;/li&gt;
&lt;li&gt;客户端收到在线名单，利用在线名单生成联系人列表；&lt;/li&gt;
&lt;li&gt;点击联系人列表，用户和服务器进行对话；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面开始进入正题：&lt;/p&gt;
    
    </summary>
    
      <category term="网络通讯" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/"/>
    
    
      <category term="网络通讯" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/"/>
    
      <category term="Socket通讯" scheme="http://yoursite.com/tags/Socket%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>iOS Socket通讯 - Socket编程头文件</title>
    <link href="http://yoursite.com/2016/09/18/iOS%E9%80%9A%E8%AE%AF%20-%20Socket%E9%80%9A%E8%AE%AF%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2016/09/18/iOS通讯 - Socket通讯头文件/</id>
    <published>2016-09-17T18:24:00.000Z</published>
    <updated>2016-09-18T07:39:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>建议：在编写网络程序时，可以直接使用下面这段头文件代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">include &lt;unistd.h&gt;</div><div class="line">include &lt;sys/types.h&gt;</div><div class="line">include &lt;sys/socket.h&gt;</div><div class="line">include &lt;netdb.h&gt;</div><div class="line">include &lt;stdio.h&gt;</div><div class="line">include &lt;stdlib.h&gt;</div><div class="line">include &lt;string.h&gt;</div><div class="line">include &lt;ctype.h&gt;</div><div class="line">include &lt;errno.h&gt;</div><div class="line">include &lt;malloc.h&gt;</div><div class="line">include &lt;netinet/in.h&gt;</div><div class="line">include &lt;arpa/inet.h&gt;</div><div class="line">include &lt;sys/ioctl.h&gt;</div><div class="line">include &lt;stdarg.h&gt;</div><div class="line">include &lt;fcntl.h&gt;</div><div class="line">include &lt;fcntl.h&gt;</div></pre></td></tr></table></figure>
   <a id="more"></a>
<p>在Socket编程中需要用到的头文件比较多，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sys/types.h：数据类型定义</div><div class="line">sys/socket.h：提供socket函数及数据结构</div><div class="line">netinet/in.h：定义数据结构sockaddr_in</div><div class="line">arpa/inet.h：提供IP地址转换函数</div><div class="line">netdb.h：提供设置及获取域名的函数</div><div class="line">sys/ioctl.h：提供对I/O控制的函数</div><div class="line">sys/poll.h：提供socket等待测试机制的函数</div></pre></td></tr></table></figure>
<p>其他在网络程序中常见的头文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">unistd.h：提供通用的文件、目录、程序及进程操作的函数</div><div class="line">errno.h：提供错误号errno的定义，用于错误处理</div><div class="line">fcntl.h：提供对文件控制的函数</div><div class="line">time.h：提供有关时间的函数</div><div class="line">crypt.h：提供使用DES加密算法的加密函数</div><div class="line">pwd.h：提供对/etc/passwd文件访问的函数</div><div class="line">shadow.h：提供对/etc/shadow文件访问的函数</div><div class="line">pthread.h：提供多线程操作的函数</div><div class="line">signal.h：提供对信号操作的函数</div><div class="line">sys/wait.h、sys/ipc.h、sys/shm.h：提供进程等待、进程间通讯（IPC）及共享内存的函数</div></pre></td></tr></table></figure>
<p>涉及到用户权限及密码验证问题时加入如下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">include &lt;shadow.h&gt;</div><div class="line">include &lt;crypt.h&gt;</div><div class="line">include &lt;pwd.h&gt;</div></pre></td></tr></table></figure>
<p>需要注意的是，应该在编译时链接加密算法库，即增加编译选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-lcrypt</div></pre></td></tr></table></figure>
<p>涉及到文件及时间操作加入如下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">include &lt;sys/time.h&gt;</div><div class="line">include &lt;utime.h&gt;</div><div class="line">include &lt;time.h&gt;</div><div class="line">include &lt;sys/stat.h&gt;</div><div class="line">include &lt;sys/file.h&gt;</div></pre></td></tr></table></figure>
<p>涉及到多进程操作时加入如下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">include &lt;sys/wait.h&gt;</div><div class="line">include &lt;sys/ipc.h&gt;</div><div class="line">include &lt;sys/shm.h&gt;</div><div class="line">include &lt;signal.h&gt;</div><div class="line">include &lt;pthread.h&gt;</div><div class="line">include &lt;sys/poll.h&gt;</div></pre></td></tr></table></figure>
<p>需要注意的是，应该在编译时链接线程库，即增加编译选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-lthread</div></pre></td></tr></table></figure>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="http://staff.ustc.edu.cn/~mengning/np/linux_socket/new_page_4.htm" target="_blank" rel="external">Socket编程中需要用到的头文件</a> - 中国科大教工FTP</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;建议：在编写网络程序时，可以直接使用下面这段头文件代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;include &amp;lt;unistd.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;include &amp;lt;sys/types.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;include &amp;lt;sys/socket.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;include &amp;lt;netdb.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;include &amp;lt;stdio.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;include &amp;lt;stdlib.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;include &amp;lt;string.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;include &amp;lt;ctype.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;include &amp;lt;errno.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;include &amp;lt;malloc.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;include &amp;lt;netinet/in.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;include &amp;lt;arpa/inet.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;include &amp;lt;sys/ioctl.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;include &amp;lt;stdarg.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;include &amp;lt;fcntl.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;include &amp;lt;fcntl.h&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="网络通讯" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/"/>
    
    
      <category term="网络通讯" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/"/>
    
      <category term="Socket通讯" scheme="http://yoursite.com/tags/Socket%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>iOS Socket通讯 - BSD Socket</title>
    <link href="http://yoursite.com/2016/09/15/iOS%20Socket%E9%80%9A%E8%AE%AF%20-%20BSD%20Socket/"/>
    <id>http://yoursite.com/2016/09/15/iOS Socket通讯 - BSD Socket/</id>
    <published>2016-09-14T18:24:00.000Z</published>
    <updated>2016-09-18T05:15:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>套接字（Socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p>
<p>Socket描述了一个IP、端口对。它简化了程序员的操作，知道对方的IP以及PORT就可以给对方发送消息，再由服务器端来处理发送的这些消息。所以，Socket一定包含了通信的双发，即客户端（Client）与服务端（server）。</p>
<p>每一个应用或者说服务，都有一个端口。比如DNS的53端口，http的80端口。我们能由DNS请求到查询信息，是因为DNS服务器时时刻刻都在监听53端口，当收到我们的查询请求以后，就能够返回我们想要的IP信息。所以，从程序设计上来讲，应该包含以下步骤：</p>
<ol>
<li><p>服务端利用Socket监听端口；</p>
<p>服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</p>
</li>
<li><p>客户端发起连接；</p>
<p>指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</p>
</li>
<li><p>服务端返回信息，建立连接，开始通信；</p>
<p>当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p>
</li>
</ol>
<p>总结如下：Socket是对TCP/IP协议的封装，Socket本身并不是协议，没有规定计算机应当怎么样传递消息，只是给程序员提供了一个发送消息的调用接口（API），程序员使用这个接口提供的方法，发送与接收消息。通过Socket我们才能使用TCP/IP协议。</p>
   <a id="more"></a>
<h2 id="iOS网络编程层次结构"><a href="#iOS网络编程层次结构" class="headerlink" title="iOS网络编程层次结构"></a>iOS网络编程层次结构</h2><p>Cocoa层是最上层的基于 Objective-C 的 API，比如 URL访问，NSStream，Bonjour，GameKit等，这是大多数情况下我们常用的 API。Cocoa 层是基于 Core Foundation 实现的。</p>
<p>Core Foundation层：因为直接使用Socket需要更多的编程工作，所以苹果对OS层的Socket进行简单的封装以简化编程任务。该层提供了CFNetwork和CFNetServices两个类，其中CFNetwork又是基于CFStream和CFSocket。</p>
<p>OS层：最底层的BSD Socket提供了对网络编程最大程度的控制，但是编程工作也是最多的，但是编程工作也是最多的。因此，苹果建议我们使用 Core Foundation 及以上层的 API 进行编程。关于BSD Socket的介绍请查看它的维基词条，<a href="https://zh.wikipedia.org/wiki/Berkeley%E5%A5%97%E6%8E%A5%E5%AD%97" target="_blank" rel="external">传送门</a>。</p>
<ul>
<li>Cocoa层<ul>
<li>NSURL</li>
<li>NSURLRequest</li>
<li>NSURLResponse</li>
<li>NSURLConnection</li>
<li>NSURLSession</li>
<li>GameKit</li>
<li>WebKit</li>
</ul>
</li>
<li>Core Foundation层<ul>
<li>基于C语言的CFNetworking和CFNetServices</li>
</ul>
</li>
<li>OS层<ul>
<li>基于C语言的BSD Socket</li>
</ul>
</li>
</ul>
<p>iOS提供的Socket网络编程的接口有CFSocket，BSD Socket，比较著名的第三方库是AsyncSocket。</p>
<p><strong>BSD Socket</strong> 是UNIX系统中通用的网络接口，它不仅支持各种不同的网络类型，而且也是一种内部进程之间的通信机制。而iOS系统其实本质就是UNIX，所以可以用，但是比较复杂。</p>
<p><strong>CFSocket</strong> 是苹果提供给我们的使用Socket的方式。</p>
<p><strong>AsyncSocket</strong> 是一个应用比较广泛的开源库。</p>
<h2 id="Socket和HTTP的区别"><a href="#Socket和HTTP的区别" class="headerlink" title="Socket和HTTP的区别"></a>Socket和HTTP的区别</h2><p>HTTP是应用层的协议，而Socket是传输层的协议。两者建立在TCP/IP协议之上，其中TCP协议是传输层的协议，IP协议是网络层的协议。</p>
<p>HTTP连接是短连接，客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。</p>
<p>HTTP如果要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即使不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。</p>
<p>Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用 中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。</p>
<p>而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。</p>
<p>很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给 客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。</p>
<p>Socket的作用是提供点对点的网络通讯，比如我们平时浏览网页，访问服务器，用到的是HTTP通讯，而QQ，网络直播这样的，需要单点对单点，单点对多点这种情况下就会使用到Socket。</p>
<h2 id="Socket位置"><a href="#Socket位置" class="headerlink" title="Socket位置"></a>Socket位置</h2><p>Socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用，也就是说，我们并不能直接使用运输层的东西，而是通过使用Socket提供的API去间接使用。下图是Socket所在的位置：</p>
<p> <img src="http://oboehz2ag.bkt.clouddn.com//Socket.jpg" alt="Socket"></p>
<h2 id="BSD-Socket-API"><a href="#BSD-Socket-API" class="headerlink" title="BSD Socket API"></a>BSD Socket API</h2><p><strong>socket</strong> 创建并初始化socket，返回该socket的文件描述符，如果描述符为-1表示创建失败。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> socketFileDescriptor = socket(<span class="keyword">int</span> addressFamily, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</div></pre></td></tr></table></figure>
<ul>
<li><p>addressFamily </p>
<p>通常参数是IPv4(AF_INET) 或IPv6(AF_INET6)。</p>
</li>
</ul>
<ul>
<li><p>type </p>
<p>表示socket的类型，通常是流stream(SOCK_STREAM) 或数据报文datagram(SOCK_DGRAM)。</p>
</li>
<li><p>protocol </p>
<p>参数通常设置为0，以便让系统自动为选择我们合适的协议，对于stream socket来说会是TCP协议(IPPROTO_TCP)，而对于datagram来说会是UDP协议(IPPROTO_UDP)。</p>
</li>
</ul>
<p><strong>close</strong> 关闭socket。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> socketFileDescriptor)</span></span></div></pre></td></tr></table></figure>
<p><strong>bind 只在服务器端使用</strong>，它将socket与特定主机IP地址与端口号绑定，成功绑定返回0，失败返回-1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> socketFileDescriptor, sockaddr *addressToBind, <span class="keyword">int</span> addressStructLength)</span></span></div></pre></td></tr></table></figure>
<ul>
<li>addressToBind 是一个描述要绑定的IP+Port的结构体。</li>
<li>addressStructLength 描述这个结构体的长度。</li>
</ul>
<p>成功绑定之后，根据协议（TCP/UDP）的不同，我们可以对socket进行不同的操作：</p>
<ul>
<li>UDP：因为UDP是无连接的，绑定之后就可以利用UDP socket传送数据了。</li>
<li>TCP：而TCP是需要建立端到端连接的，为了建立TCP连接服务器必须调用listen。</li>
</ul>
<p><strong>listen 只在服务器端使用</strong>，设置服务器的缓冲区队列以接收客户端的连接请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> socketFileDescriptor, <span class="keyword">int</span> backlogSize)</span></span></div></pre></td></tr></table></figure>
<ul>
<li>backlogSize 表示客户端连接请求缓冲区队列的大小。</li>
</ul>
<p>当调用listen设置之后，服务器等待客户端请求，然后调用下面的accept来接受客户端的连接请求。</p>
<p><strong>accept 只在服务器端使用</strong>，接受客户端连接请求并将客户端的网络地址信息保存到clientAddress中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> socketFileDescriptor, sockaddr *clientAddress, <span class="keyword">int</span> clientAddressStructLength)</span></span></div></pre></td></tr></table></figure>
<ul>
<li><p><strong>sockaddr 结构体</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sockaddr &#123;</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sa_family;<span class="comment">/*addressfamily,AF_xxx*/</span></div><div class="line"><span class="keyword">char</span> sa_data[<span class="number">14</span>];<span class="comment">/*14bytesofprotocoladdress*/</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>sa_family是通信类型，最常用的值是 “AF_INET”；</li>
<li>sa_data14字节，包含套接字中的目标地址和端口信息；</li>
<li>sockaddr的缺陷是sa_data把目标地址和端口信息混在一起了。</li>
</ul>
</li>
<li><p><strong>sockaddr_in 结构体</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sockaddr_in &#123;</div><div class="line"><span class="keyword">short</span> sin_family;<span class="comment">/*Address */</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sin_port;<span class="comment">/*Port number*/</span></div><div class="line"><span class="keyword">struct</span> in_addr sin_addr;<span class="comment">/*IP address*/</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];<span class="comment">/*Same size as struct sockaddr*/</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><p>sin_family 指代协议族，一般来说是AF_INET（地址族）PF_INET（协议族），在socket编程中只能是AF_INET；</p>
</li>
<li><p>sin_port 存储端口号，在linux下，端口号的范围0~65535，同时0~1024范围的端口号已经被系统使用或保留。要采用网络数据格式，普通数字可以用<code>htons()</code>函数转换成网络数据格式的数字；</p>
</li>
<li><p>sin_addr 是用来表示一个32位的IPv4地址的结构体；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> in_addr &#123;</div><div class="line">    <span class="keyword">in_addr_t</span> s_addr;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>in_addr_t 一般为 32位的unsigned int，其字节顺序为网络顺序（network byte ordered)，其中每8位代表一个IP地址位中的一个数值。</li>
<li>例如192.168.3.144记为0x9003a8c0，其中 c0=192 ，a8=168，03=3，90=144。打印的时候可以调用inet_ntoa()函数将其转换为char *类型。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>sin_zero 没有实际意义，是为了让sockaddr与sockaddr_in两个数据结构在内存中保持大小相同而保留的空字节。</p>
</li>
<li><p>sockaddr_in和sockaddr是并列的结构，指向sockaddr_in的结构体的指针也可以指向sockaddr的结构体，并代替它。当客户端连接请求被服务器接受之后，客户端和服务器之间的链路就建立好了，两者就可以通信了。</p>
</li>
</ul>
<p><strong>注意：accept是一个阻塞函数，因此在调用时需要放在子线程中，以免主线程卡死。</strong></p>
<p><strong>connect</strong> 客户端向特定网络地址的服务器发送连接请求，连接成功返回0，失败返回 -1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> socketFileDescriptor, sockaddr *serverAddress, <span class="keyword">int</span> serverAddressLength)</span></span></div></pre></td></tr></table></figure>
<p>当服务器建立好之后，客户端通过调用该接口向服务器发起建立连接请求。</p>
<ul>
<li>对于UDP来说，该接口是可选的，如果调用了该接口，表明设置了该 UDP socket 默认的网络地址。</li>
<li>对TCP socket来说这就是传说中三次握手建立连接发生的地方。</li>
</ul>
<p><strong>注意：该接口调用会阻塞当前线程，直到服务器返回。</strong></p>
<p><strong>gethostbyname</strong> 使用 DNS 查找特定主机名字对应的 IP 地址。如果找不到对应的 IP 地址则返回 NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">hostent* <span class="title">gethostbyname</span><span class="params">(<span class="keyword">char</span> *hostname)</span></span></div></pre></td></tr></table></figure>
<p><strong>send</strong> 通过socket发送数据，发送成功返回成功发送的字节数，否则返回 -1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> socketFileDescriptor, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> bufferLength, <span class="keyword">int</span> flags)</span></span></div></pre></td></tr></table></figure>
<p>一旦连接建立好之后，就可以通过send/receive接口发送或接收数据了。UDP socket 也可以调用该接口来接收数据。</p>
<p><strong>receive</strong> 从socket中读取数据，读取成功返回成功读取的字节数，否则返回 -1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">receive</span><span class="params">(<span class="keyword">int</span> socketFileDescriptor, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> bufferLength, <span class="keyword">int</span> flags)</span></span></div></pre></td></tr></table></figure>
<p><strong>sendto 只在UDP协议下使用</strong>，通过UDP socket 发送数据到特定的网络地址，发送成功返回成功发送的字节数，否则返回 -1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> socketFileDescriptor, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> bufferLength, <span class="keyword">int</span> flags, sockaddr *destinationAddress, <span class="keyword">int</span> destinationAddressLength)</span></span></div></pre></td></tr></table></figure>
<p>由于 UDP 可以向多个网络地址发送数据，所以可以指定特定网络地址，以向其发送数据。</p>
<p><strong>recvfrom 只在UDP协议下使用</strong>，从UDP socket中读取数据，并保存发送者的网络地址信息，读取成功返回成功读取的字节数，否则返回 -1 。</p>
<p><strong>注意：recvfrom是一个阻塞函数，因此在调用时需要放在子线程中，以免主线程卡死。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> socketFileDescriptor, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> bufferLength, <span class="keyword">int</span> flags, sockaddr *fromAddress, <span class="keyword">int</span> *fromAddressLength)</span></span></div></pre></td></tr></table></figure>
<p>由于UDP可以接收来自多个网络地址的数据，所以需要提供额外的参数，以保存该数据的发送者身份。</p>
<h2 id="Socket-C-S"><a href="#Socket-C-S" class="headerlink" title="Socket C/S"></a>Socket C/S</h2><p>Socket通信就是一种确定了端口号的TCP/IP通信，或者说Socket通信与IP通信差别就是端口确定，协议确定。</p>
<p>端口的打开是双方的，在C/S（Client&amp;&amp;Server）结构的TCP连接中不仅仅要注意到S的端（监听的），实际上C也开了一个端口，而C端的端口是动态端口，TCP连接建立的时候，C端的端口会在三次握手结束后确定，动态打开一个,这个端口不受用户/程序员的控制。</p>
<h3 id="Socket-C-端书写步骤"><a href="#Socket-C-端书写步骤" class="headerlink" title="Socket C 端书写步骤"></a>Socket C 端书写步骤</h3><ul>
<li>创建客户端Socket，例如使用<code>socket(...)</code>；</li>
<li>连接到服务器(Socket编程)，例如使用<code>connect(...)</code>；</li>
<li>发送数据给服务器，例如使用<code>send(...)</code>；</li>
<li>接收服务器返回的数据，例如使用<code>receive(...)</code>；</li>
<li>关闭Socket : 例如使用<code>close(socketFileDescriptor)</code>；</li>
</ul>
<h3 id="Socket-C-S-常见框架"><a href="#Socket-C-S-常见框架" class="headerlink" title="Socket C/S 常见框架"></a>Socket C/S 常见框架</h3><table>
<thead>
<tr>
<th style="text-align:center">TCP CS框架</th>
<th style="text-align:center">UDP CS框架</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://oboehz2ag.bkt.clouddn.com/%E5%B8%B8%E8%A7%81Socket%20TCP%E6%A1%86%E6%9E%B6.gif" alt="常见Socket TCP框架"></td>
<td style="text-align:center"><img src="http://oboehz2ag.bkt.clouddn.com/%E5%B8%B8%E8%A7%81Socket%20UDP%E6%A1%86%E6%9E%B6.gif" alt="常见Socket UDP框架"></td>
</tr>
</tbody>
</table>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="http://www.jianshu.com/p/6b64d8ac62e3" target="_blank" rel="external">iOS开发网络篇—Socket编程</a> - 牵左手不离</p>
<p><a href="http://blog.csdn.net/baihuaxiu123/article/details/51560320" target="_blank" rel="external">谈谈iOS网络编程之socket编程技术及应用</a> - 刘玉刚</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;套接字（Socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。&lt;/p&gt;
&lt;p&gt;Socket描述了一个IP、端口对。它简化了程序员的操作，知道对方的IP以及PORT就可以给对方发送消息，再由服务器端来处理发送的这些消息。所以，Socket一定包含了通信的双发，即客户端（Client）与服务端（server）。&lt;/p&gt;
&lt;p&gt;每一个应用或者说服务，都有一个端口。比如DNS的53端口，http的80端口。我们能由DNS请求到查询信息，是因为DNS服务器时时刻刻都在监听53端口，当收到我们的查询请求以后，就能够返回我们想要的IP信息。所以，从程序设计上来讲，应该包含以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;服务端利用Socket监听端口；&lt;/p&gt;
&lt;p&gt;服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;客户端发起连接；&lt;/p&gt;
&lt;p&gt;指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务端返回信息，建立连接，开始通信；&lt;/p&gt;
&lt;p&gt;当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结如下：Socket是对TCP/IP协议的封装，Socket本身并不是协议，没有规定计算机应当怎么样传递消息，只是给程序员提供了一个发送消息的调用接口（API），程序员使用这个接口提供的方法，发送与接收消息。通过Socket我们才能使用TCP/IP协议。&lt;/p&gt;
    
    </summary>
    
      <category term="网络通讯" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/"/>
    
    
      <category term="网络通讯" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/"/>
    
      <category term="Socket通讯" scheme="http://yoursite.com/tags/Socket%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>Xcode错误 - Expected a type</title>
    <link href="http://yoursite.com/2016/09/15/Xcode%E9%94%99%E8%AF%AF%20-%20Expected%20a%20type%20/"/>
    <id>http://yoursite.com/2016/09/15/Xcode错误 - Expected a type /</id>
    <published>2016-09-14T18:24:00.000Z</published>
    <updated>2016-09-16T06:22:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>需要自己手动导入库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div></pre></td></tr></table></figure>
<p>参考链接：<a href="http://stackoverflow.com/questions/26412635/ios-8-expected-a-type" target="_blank" rel="external">http://stackoverflow.com/questions/26412635/ios-8-expected-a-type</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;需要自己手动导入库：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;p
    
    </summary>
    
      <category term="Xocde错误" scheme="http://yoursite.com/categories/Xocde%E9%94%99%E8%AF%AF/"/>
    
    
      <category term="Xocde错误" scheme="http://yoursite.com/tags/Xocde%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>网络通讯结构 - OSI&amp;TCP/IP</title>
    <link href="http://yoursite.com/2016/09/14/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%BB%93%E6%9E%84%20-%20OSI&amp;TCP:IP/"/>
    <id>http://yoursite.com/2016/09/14/网络通讯结构 - OSI&amp;TCP:IP/</id>
    <published>2016-09-13T18:24:00.000Z</published>
    <updated>2016-09-14T03:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>两个应用程序之间的通信，我们可以理解为进程之间的通信，而进程之间进行通信的前提是我们能够找到某个进程，因此，我们需要给进程添加唯一的标示，在本地进程通信中我们可以使用PID来标示一个进程，但PID只在本地唯一，网络中的多个计算机之间的进程标示并不能保证唯一性，冲突的几率很大。</p>
<p>这时候我们需要另辟蹊径，TCP/IP协议族已为我们解决了这个问题，IP层的IP地址可以标示主机，而TCP层协议和端口号可以标示某个主机的某个进程，于是我们采取<strong>IP地址＋协议＋端口号</strong>作为唯一标示的这种形式，来确定网络中的一个进程，从而进行进程之间的通讯，这种方式就是我们Socket使用的通讯方式。</p>
<p>在学习Socket通讯之前，首先需要了解<strong>网络通讯结构、TCP和UPD</strong>，以下是这这两个知识点的简要介绍。</p>
   <a id="more"></a>
<h2 id="OSI模型-七层模型"><a href="#OSI模型-七层模型" class="headerlink" title="OSI模型/七层模型"></a>OSI模型/七层模型</h2><p>网络通信结构是有一套标准模型的，由国际标准化组织ISO提出，被称为OSI模型，又称为七层模型。它的层次划分如下：</p>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;margin:0px auto;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:11px 20px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:11px 20px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;}
.tg .tg-7uzy{vertical-align:top}
.tg .tg-yw4l{vertical-align:top}
th.tg-sort-header::-moz-selection { background:transparent; }th.tg-sort-header::selection      { background:transparent; }th.tg-sort-header { cursor:pointer; }table th.tg-sort-header:after {  content:'';  float:right;  margin-top:7px;  border-width:0 4px 4px;  border-style:solid;  border-color:#404040 transparent;  visibility:hidden;  }table th.tg-sort-header:hover:after {  visibility:visible;  }table th.tg-sort-desc:after,table th.tg-sort-asc:after,table th.tg-sort-asc:hover:after {  visibility:visible;  opacity:0.4;  }table th.tg-sort-desc:after {  border-bottom:none;  border-width:4px 4px 0;  }</style>
<table id="tfhover" class="tftable" border="1">
  <tr>

<th class="tg-031e" style="width:5%"></th>
<th class="tg-yw4l" style="width:12%">数据单元</th>
<th class="tg-yw4l" style="width:15%">层</th>
<th class="tg-yw4l">功能</th>

  </tr>
  <tr>

<td class="tg-6wtj" rowspan="4">主机层</td>
<td class="tg-7uzy" rowspan="3">Data<br>数据</td>
<td class="tg-7uzy">7-应用层</td>
<td class="tg-7uzy">提供为应用软件而设的界面，以设置与另一应用软件之间的通信。例如: HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等。</td>

  </tr>
  <tr>

<td class="tg-yw4l">6-表示层</td>
<td class="tg-yw4l">把数据转换为能与接收者的系统格式兼容并适合传输的格式。</td>

  </tr>
  <tr>

<td class="tg-7uzy">5-会话层</td>
<td class="tg-7uzy">负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接。</td>

  </tr>
  <tr>

<td class="tg-yw4l">Segments<br>数据段</td>
<td class="tg-yw4l">4-传输层</td>
<td class="tg-yw4l">把传输表头(TH)加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议义(TCP) 等。</td>

  </tr>
  <tr>

<td class="tg-6wtj" rowspan="3">媒介层</td>
<td class="tg-6wtj">网络分组<br>数据报文</td>
<td class="tg-6wtj">3-网络层</td>
<td class="tg-6wtj">决定数据的路径选择和转寄，将网络表头(NH)加至数据包，以形成分组。网络表头包含了网络数据。例如:互联网协议(IP) 等。</td>

  </tr>
  <tr>


<td class="tg-031e">Bit/Frame<br>数据帧</td>
<td class="tg-031e">2-数据链路层</td>
<td class="tg-031e">负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成了帧。数据链表头(DLH)是包含了物理地址和错误侦测及改错的方法。数据链表尾(DLT)是一串指示数据包末端的字符串。例如以太网、无线局域网(Wi-Fi)和通用分组无线服务(GPRS)等。</td>


  </tr>
  <tr>


<td class="tg-6wtj">Bit<br>比特</td>
<td class="tg-6wtj">1-物理层</td>
<td class="tg-6wtj">在局部局域网上传送帧，它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机适配器等。</td>


  </tr>
</table>
<script type="text/javascript" charset="utf-8">var TgTableSort=window.TgTableSort||function(n,t){"use strict";function r(n,t){for(var e=[],o=n.childNodes,i=0;i<o.length;++i){var u=o[i];if("."==t.substring(0,1)){var a=t.substring(1);f(u,a)&&e.push(u)}else u.nodeName.toLowerCase()==t&&e.push(u);var c=r(u,t);e=e.concat(c)}return e}function e(n,t){var e=[],o=r(n,"tr");return o.forEach(function(n){var o=r(n,"td");t>=0&&t<o.length&&e.push(o[t])}),e}function o(n){return n.textContent||n.innerText||""}function i(n){return n.innerHTML||""}function u(n,t){var r=e(n,t);return r.map(o)}function a(n,t){var r=e(n,t);return r.map(i)}function c(n){var t=n.className||"";return t.match(/\S+/g)||[]}function f(n,t){return-1!=c(n).indexOf(t)}function s(n,t){f(n,t)||(n.className+=" "+t)}function d(n,t){if(f(n,t)){var r=c(n),e=r.indexOf(t);r.splice(e,1),n.className=r.join(" ")}}function v(n){d(n,L),d(n,E)}function l(n,t,e){r(n,"."+E).map(v),r(n,"."+L).map(v),e==T?s(t,E):s(t,L)}function g(n){return function(t,r){var e=n*t.str.localeCompare(r.str);return 0==e&&(e=t.index-r.index),e}}function h(n){return function(t,r){var e=+t.str,o=+r.str;return e==o?t.index-r.index:n*(e-o)}}function m(n,t,r){var e=u(n,t),o=e.map(function(n,t){return{str:n,index:t}}),i=e&&-1==e.map(isNaN).indexOf(!0),a=i?h(r):g(r);return o.sort(a),o.map(function(n){return n.index})}function p(n,t,r,o){for(var i=f(o,E)?N:T,u=m(n,r,i),c=0;t>c;++c){var s=e(n,c),d=a(n,c);s.forEach(function(n,t){n.innerHTML=d[u[t]]})}l(n,o,i)}function x(n,t){var r=t.length;t.forEach(function(t,e){t.addEventListener("click",function(){p(n,r,e,t)}),s(t,"tg-sort-header")})}var T=1,N=-1,E="tg-sort-asc",L="tg-sort-desc";return function(t){var e=n.getElementById(t),o=r(e,"tr"),i=o.length>0?r(o[0],"td"):[];0==i.length&&(i=r(o[0],"th"));for(var u=1;u<o.length;++u){var a=r(o[u],"td");if(a.length!=i.length)return}x(e,i)}}(document);document.addEventListener("DOMContentLoaded",function(n){TgTableSort("tg-Qvv0j")});</script>

<style type="text/css">
  table.tftable {font-size:12px;color:#333333;width:100%;border-width: 1px;border-color: #729ea5;border-collapse: collapse;}
  table.tftable th {font-size:12px;background-color:#acc8cc;border-width: 1px;padding: 8px;border-style: solid;border-color: #729ea5;text-align:left;}
  table.tftable tr {background-color:#d4e3e5;}
  table.tftable td {font-size:12px;border-width: 1px;padding: 8px;border-style: solid;border-color: #729ea5;}
  </style>

<p>七层模型中数据的传输过程如下：</p>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;margin:0px auto;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:11px 20px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:11px 20px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;}
.tg .tg-7uzy{vertical-align:top}
.tg .tg-yw4l{vertical-align:top}
th.tg-sort-header::-moz-selection { background:transparent; }th.tg-sort-header::selection      { background:transparent; }th.tg-sort-header { cursor:pointer; }table th.tg-sort-header:after {  content:'';  float:right;  margin-top:7px;  border-width:0 4px 4px;  border-style:solid;  border-color:#404040 transparent;  visibility:hidden;  }table th.tg-sort-header:hover:after {  visibility:visible;  }table th.tg-sort-desc:after,table th.tg-sort-asc:after,table th.tg-sort-asc:hover:after {  visibility:visible;  opacity:0.4;  }table th.tg-sort-desc:after {  border-bottom:none;  border-width:4px 4px 0;  }</style>
<table id="tfhover" class="tftable" border="1">
  <tr>


<th style="width:13%" class="tg-yw4l">层</th>
<th class="tg-yw4l">主机A</th>
<th class="tg-yw4l">主机B</th>


  </tr>
  <tr>


<td class="tg-031e">应用层</td>
<td class="tg-031e">标记1，用的什么软件发送</td>
<td class="tg-031e">用什么软件打开</td>


  </tr>
  <tr>


<td class="tg-031e">表示层</td>
<td class="tg-031e">标记2，是什么类型数据（文本，图片，声音）</td>
<td class="tg-031e">数据的类型</td>


  </tr>
  <tr>


<td class="tg-031e">会话层</td>
<td class="tg-031e">标记3，传输给谁？</td>
<td class="tg-031e">发给谁</td>


  </tr>
  <tr>


<td class="tg-031e">传输层</td>
<td class="tg-031e">标记4，同过怎么样的传输方式（协议，端口）</td>
<td class="tg-031e">用的什么协议发送给哪个端口</td>


  </tr>
  <tr>


<td class="tg-031e">网络层</td>
<td class="tg-031e">标记5，发给哪一个IP地址？</td>
<td class="tg-031e">是否是发送给此IP地址</td>


  </tr>
  <tr>


<td class="tg-031e">数据链路层</td>
<td class="tg-031e">标记6，找到IP对应的MAC地址</td>
<td class="tg-031e">是否是发送给此MAC地址的帧</td>


  </tr>
  <tr>


<td class="tg-031e">物理层</td>
<td class="tg-031e">1010101010010101010</td>
<td class="tg-031e">10100101010100101</td>


  </tr>
</table>
<script type="text/javascript" charset="utf-8">var TgTableSort=window.TgTableSort||function(n,t){"use strict";function r(n,t){for(var e=[],o=n.childNodes,i=0;i<o.length;++i){var u=o[i];if("."==t.substring(0,1)){var a=t.substring(1);f(u,a)&&e.push(u)}else u.nodeName.toLowerCase()==t&&e.push(u);var c=r(u,t);e=e.concat(c)}return e}function e(n,t){var e=[],o=r(n,"tr");return o.forEach(function(n){var o=r(n,"td");t>=0&&t<o.length&&e.push(o[t])}),e}function o(n){return n.textContent||n.innerText||""}function i(n){return n.innerHTML||""}function u(n,t){var r=e(n,t);return r.map(o)}function a(n,t){var r=e(n,t);return r.map(i)}function c(n){var t=n.className||"";return t.match(/\S+/g)||[]}function f(n,t){return-1!=c(n).indexOf(t)}function s(n,t){f(n,t)||(n.className+=" "+t)}function d(n,t){if(f(n,t)){var r=c(n),e=r.indexOf(t);r.splice(e,1),n.className=r.join(" ")}}function v(n){d(n,L),d(n,E)}function l(n,t,e){r(n,"."+E).map(v),r(n,"."+L).map(v),e==T?s(t,E):s(t,L)}function g(n){return function(t,r){var e=n*t.str.localeCompare(r.str);return 0==e&&(e=t.index-r.index),e}}function h(n){return function(t,r){var e=+t.str,o=+r.str;return e==o?t.index-r.index:n*(e-o)}}function m(n,t,r){var e=u(n,t),o=e.map(function(n,t){return{str:n,index:t}}),i=e&&-1==e.map(isNaN).indexOf(!0),a=i?h(r):g(r);return o.sort(a),o.map(function(n){return n.index})}function p(n,t,r,o){for(var i=f(o,E)?N:T,u=m(n,r,i),c=0;t>c;++c){var s=e(n,c),d=a(n,c);s.forEach(function(n,t){n.innerHTML=d[u[t]]})}l(n,o,i)}function x(n,t){var r=t.length;t.forEach(function(t,e){t.addEventListener("click",function(){p(n,r,e,t)}),s(t,"tg-sort-header")})}var T=1,N=-1,E="tg-sort-asc",L="tg-sort-desc";return function(t){var e=n.getElementById(t),o=r(e,"tr"),i=o.length>0?r(o[0],"td"):[];0==i.length&&(i=r(o[0],"th"));for(var u=1;u<o.length;++u){var a=r(o[u],"td");if(a.length!=i.length)return}x(e,i)}}(document);document.addEventListener("DOMContentLoaded",function(n){TgTableSort("tg-Qvv0j")});</script>

<style type="text/css">
  table.tftable {font-size:12px;color:#333333;width:100%;border-width: 1px;border-color: #729ea5;border-collapse: collapse;}
  table.tftable th {font-size:12px;background-color:#acc8cc;border-width: 1px;padding: 8px;border-style: solid;border-color: #729ea5;text-align:left;}
  table.tftable tr {background-color:#d4e3e5;}
  table.tftable td {font-size:12px;border-width: 1px;padding: 8px;border-style: solid;border-color: #729ea5;}
  </style>



<p>​                  </p>
<h2 id="TCP-IP模型-四层模型"><a href="#TCP-IP模型-四层模型" class="headerlink" title="TCP/IP模型/四层模型"></a>TCP/IP模型/四层模型</h2><p>而我们在开发中广泛应用的是四层模型，也就是TCP/IP参考模型，这四层分别是硬件层、网络层、传输层、应用层。以下是OSI模型和IP/TCP模型的层次对比：</p>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;margin:0px auto;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:11px 20px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:11px 20px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;}
.tg .tg-7uzy{vertical-align:top}
.tg .tg-yw4l{vertical-align:top}
th.tg-sort-header::-moz-selection { background:transparent; }th.tg-sort-header::selection      { background:transparent; }th.tg-sort-header { cursor:pointer; }table th.tg-sort-header:after {  content:'';  float:right;  margin-top:7px;  border-width:0 4px 4px;  border-style:solid;  border-color:#404040 transparent;  visibility:hidden;  }table th.tg-sort-header:hover:after {  visibility:visible;  }table th.tg-sort-desc:after,table th.tg-sort-asc:after,table th.tg-sort-asc:hover:after {  visibility:visible;  opacity:0.4;  }table th.tg-sort-desc:after {  border-bottom:none;  border-width:4px 4px 0;  }</style>
<table id="tfhover" class="tftable" border="1">
<tr>


<th class="tg-031e" style="width:15%">OSI七层模型</th>
<th class="tg-031e" style="width:18%">TCP/IP四层模型</th>
<th class="tg-yw4l">对应网络协议</th>
<th class="tg-yw4l" style="width:13%">数据单元</th>


  </tr>
  <tr>


<td class="tg-031e">应用层</td>
<td class="tg-031e" rowspan="3">应用层</td>
<td class="tg-yw4l" rowspan="3">FTP（文件传输协议）<br>HTTP（超文本传输协议）<br>DNS（域名服务器协议）<br>SMTP（简单邮件传输协议）<br>NFS（网络文件系统协议）</td>
<td class="tg-yw4l" rowspan="3">数据</td>


  </tr>
  <tr>


<td class="tg-031e">表示层</td>


  </tr>
  <tr>


<td class="tg-031e">会话层</td>


  </tr>
  <tr>


<td class="tg-031e">传输层</td>
<td class="tg-031e">传输层</td>
<td class="tg-yw4l">TCP（控制传输协议）<br>UDP（用户数据报协议）</td>
<td class="tg-yw4l">数据包</td>


  </tr>
  <tr>


<td class="tg-031e">网络层</td>
<td class="tg-031e">网络层</td>
<td class="tg-yw4l">IP（网际协议）<br>ICMP（网际控制消息协议）<br>ARP（地址解析协议）<br>RARP（反向地址解析协议）</td>
<td class="tg-yw4l">数据帧</td>


  </tr>
  <tr>


<td class="tg-yw4l">数据链路层</td>
<td class="tg-yw4l" rowspan="2">硬件层</td>
<td class="tg-yw4l" rowspan="2">HDLC（高级链路控制协议）<br>PPP（点对点协议）<br>SLIP（串行线路接口协议）</td>
<td class="tg-yw4l" rowspan="2">比特</td>


  </tr>
  <tr>


<td class="tg-yw4l">物理层</td>


  </tr>
</table>

<script type="text/javascript" charset="utf-8">var TgTableSort=window.TgTableSort||function(n,t){"use strict";function r(n,t){for(var e=[],o=n.childNodes,i=0;i<o.length;++i){var u=o[i];if("."==t.substring(0,1)){var a=t.substring(1);f(u,a)&&e.push(u)}else u.nodeName.toLowerCase()==t&&e.push(u);var c=r(u,t);e=e.concat(c)}return e}function e(n,t){var e=[],o=r(n,"tr");return o.forEach(function(n){var o=r(n,"td");t>=0&&t<o.length&&e.push(o[t])}),e}function o(n){return n.textContent||n.innerText||""}function i(n){return n.innerHTML||""}function u(n,t){var r=e(n,t);return r.map(o)}function a(n,t){var r=e(n,t);return r.map(i)}function c(n){var t=n.className||"";return t.match(/\S+/g)||[]}function f(n,t){return-1!=c(n).indexOf(t)}function s(n,t){f(n,t)||(n.className+=" "+t)}function d(n,t){if(f(n,t)){var r=c(n),e=r.indexOf(t);r.splice(e,1),n.className=r.join(" ")}}function v(n){d(n,L),d(n,E)}function l(n,t,e){r(n,"."+E).map(v),r(n,"."+L).map(v),e==T?s(t,E):s(t,L)}function g(n){return function(t,r){var e=n*t.str.localeCompare(r.str);return 0==e&&(e=t.index-r.index),e}}function h(n){return function(t,r){var e=+t.str,o=+r.str;return e==o?t.index-r.index:n*(e-o)}}function m(n,t,r){var e=u(n,t),o=e.map(function(n,t){return{str:n,index:t}}),i=e&&-1==e.map(isNaN).indexOf(!0),a=i?h(r):g(r);return o.sort(a),o.map(function(n){return n.index})}function p(n,t,r,o){for(var i=f(o,E)?N:T,u=m(n,r,i),c=0;t>c;++c){var s=e(n,c),d=a(n,c);s.forEach(function(n,t){n.innerHTML=d[u[t]]})}l(n,o,i)}function x(n,t){var r=t.length;t.forEach(function(t,e){t.addEventListener("click",function(){p(n,r,e,t)}),s(t,"tg-sort-header")})}var T=1,N=-1,E="tg-sort-asc",L="tg-sort-desc";return function(t){var e=n.getElementById(t),o=r(e,"tr"),i=o.length>0?r(o[0],"td"):[];0==i.length&&(i=r(o[0],"th"));for(var u=1;u<o.length;++u){var a=r(o[u],"td");if(a.length!=i.length)return}x(e,i)}}(document);document.addEventListener("DOMContentLoaded",function(n){TgTableSort("tg-Qvv0j")});</script>

<style type="text/css">
  table.tftable {font-size:12px;color:#333333;width:100%;border-width: 1px;border-color: #729ea5;border-collapse: collapse;}
  table.tftable th {font-size:12px;background-color:#acc8cc;border-width: 1px;padding: 8px;border-style: solid;border-color: #729ea5;text-align:left;}
  table.tftable tr {background-color:#d4e3e5;}
  table.tftable td {font-size:12px;border-width: 1px;padding: 8px;border-style: solid;border-color: #729ea5;}
  </style>

<p>TCP/IP协议被组织成四个概念层，其中有三层对应于ISO参考模型中的相应层。ICP/IP协议族并不包含物理层和数据链路层，因此它不能独立完成整个计算机网络系统的功能，必须与许多其他的协议协同工作。 TCP/IP分层模型的四个协议层分别完成以下的功能： </p>
<h3 id="硬件层"><a href="#硬件层" class="headerlink" title="硬件层"></a>硬件层</h3><p>硬件层与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。</p>
<p><strong>TCP/IP参考模型只是要求能够提供给其上层-网络互连层一个访问接口，以便在其上传递IP分组。</strong></p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层是整个TCP/IP协议栈的核心。对应于OSI七层参考模型的网络层。本层包含</p>
<ul>
<li>IP协议（Internet Protocol，网际协议）</li>
<li>RIP协议（Routing Information Protocol，路由信息协议）</li>
<li>ARP协议（Address Resolution Protocol，地址解析协议）</li>
</ul>
<p><strong>IP协议</strong>是网际互联层最重要的协议，它提供的是一个可靠、无连接的数据报传递服务。IP层接收由更低层（硬件层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层也就是传输层，例如TCP或UDP层；</p>
<p>相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。</p>
<p>IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。高层的TCP和UDP服务在接收数据包时，通常假设包中的源地址是有效的。</p>
<p><strong>ARP协议</strong>其基本功能为通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。它是IPv4中网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。</p>
<p>网络层负责数据的包装、寻址和路由。它的功能是把分组发往目标网络或主机。同时，为了尽快地发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。</p>
<p>网络层定义了分组格式和协议，即IP协议，网络互连层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，网络互连层还需要完成拥塞控制的功能。</p>
<p>它同时还包含</p>
<ul>
<li>Internet控制消息协议（Internet Control Message Protocol，ICMP）</li>
</ul>
<p><strong>ICMP协议</strong>是网络协议族的核心协议之一。它用于TCP/IP网络中发送控制消息，提供可能发生在通信环境中的各种问题反馈，通过这些信息，令管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。</p>
<p>ICMP依靠IP协议来完成它的任务，它是IP协议的主要部分。它与传输协议如TCP和UDP显著不同：它一般不用于在两点间传输数据，通常不由网络程序直接使用，除了ping和traceroute这两个特别的例子。 IPv4中的ICMP被称作ICMPv4，IPv6中的ICMP则被称作ICMPv6。</p>
<p>网络层协议管理离散的计算机间的数据传输，如IP协议为用户和远程计算机提供了信息包的传输方法，确保信息包能正确地到达目的机器。这一过程中，IP和其他网络层的协议共同用于数据传输，如果没有使用一些监视系统进程的工具，用户是看不到在系统里的IP的。</p>
<p>网络嗅探器Sniffers是能看到这些过程的一个装置（它可以是软件，也可以是硬件），它能读取通过网络发送的每一个包，即能读取发生在网络层协议的任何活动，因此网络嗅探器Sniffers会对安全造成威胁重要的网络层协议包括ARP、ICMP和IP协议等。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>在TCP/IP模型中，传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。</p>
<p>传输层对应于OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：</p>
<ul>
<li>传输控制协议 TCP（transmission control protocol）</li>
<li>用户数据报协议 UDP（user datagram protocol）</li>
</ul>
<p><strong>传输层</strong>对应OSI概念模型的传输层。传输层提供应用程序间的通信。其功能包括：</p>
<ul>
<li>格式化信息流</li>
<li>提供可靠传输。</li>
</ul>
<p>为实现后者，传输层协议规定接收端必须发回确认信息，如果分组丢失，必须重新发送。</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>TCP/IP概念模型中的应用层对应OSI的应用层、表示层和会话层，应用层协议主要包括：</p>
<ul>
<li>邮局协议（Post Office Protocol，缩写：POP）</li>
<li>域名系统（Domain Name System，缩写：DNS）</li>
<li>文件传输协议（File Transfer Protocol，缩写：FTP）</li>
<li>超文本传输协议（HyperText Transfer Protocol，缩写：HTTP）</li>
<li>简单邮件传输协议 (Simple Mail Transfer Protocol，缩写：SMTP)</li>
<li>实时传输协议（Real-time Transport Protocol，缩写：RTP）</li>
<li>安全壳协议（Secure Shell，缩写：SSH）</li>
<li>传输层安全协议（Transport Layer Security，缩写：TLS）</li>
<li>安全套接层（Secure Sockets Layer，缩写：SSL）</li>
</ul>
<p>应用层位于协议栈的顶端，它的主要任务是应用。一般是可见的，如利用FTP（文件传输协议）传输一个文件，请求一个和目标计算机的连接，在传输文件的过程中，用户和远程计算机交换的一部分是能看到的。</p>
<p>应用层是Linux网络设定最关键的一层。Linux服务器的配置文档主要针对应用层中的协议。</p>
<h2 id="TCP和UPD"><a href="#TCP和UPD" class="headerlink" title="TCP和UPD"></a>TCP和UPD</h2><p>TCP 协议是面向连接的协议，类似于打电话，在开始传输数据之前，必须先建立明确的连接。</p>
<p>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的， TCP提供全双工通信。数据在两个方向上独立的进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。</p>
<p>它将一台主机发出的字节流无差错地发往互联网上的其他主机。在发送端，它负责把上层传送下来的字节流分成报文段并传递给下层。在接收端，它负责把收到的报文进行重组后递交给上层。</p>
<p><strong>面向字节流的含义</strong>：虽然应用程序和TCP交互是一次一个数据块，但TCP把应用程序交下来的数据仅仅是一连串的无结构的字节流。</p>
<p><strong>面向连接的含义：</strong>面向连接是指两台主机在通讯的过程中，必须要先建立通讯关系，然后再去发送数据，也就是客户端首先向服务器发送数据，服务器给到客户端回应，具有通讯过程后再进行真正的数据传输。它是有两台固定的主机在通讯。</p>
<p><strong>因此TCP协议是一个面向连接的、可靠的协议。</strong>它的可靠性表现在：</p>
<ul>
<li>保证数据正确性</li>
<li>保证数据顺序</li>
</ul>
<p>它的缺点在于：</p>
<ul>
<li>传输速度慢</li>
<li>建立连接需要时间的系统资源较多</li>
</ul>
<p>TCP协议还要处理端到端的流量控制，以避免缓慢接收的接收方没有足够的缓冲区接收发送方发送的大量数据。</p>
<p>TCP建立在IP之上，定义了网络上程序到程序的数据传输格式和规则，提供了IP数据包的传输确认、丢失数据包的重新请求、将收到的数据包按照它们的发送次序重新装配的机制。</p>
<p><strong>UDP协议</strong>是一种面向非连接、不保证可靠的数据传输服务，主要适用于不需要对报文进行排序和流量控制的场合。 它的优点在于：</p>
<ul>
<li>用于传输少量数据(数据包模式)</li>
<li>资源消耗小，处理速度快</li>
</ul>
<p>UDP也建立在IP之上，但它是一种无连接协议，两台计算机之间的传输类似于传递邮件：消息从一台计算机发送到另一台计算机，两者之间没有明确的连接。</p>
<p>UDP不保证数据的传输，也不提供重新排列次序或重新请求的功能，所以说它是不可靠的。虽然UDP的不可靠性限制了它的应用场合，但它比TCP具有更好的传输效率，UDP的缺点在于：</p>
<ul>
<li>不提供数据包分组、组装</li>
<li>不能对数据包进行排序</li>
</ul>
<p>也就是说，当报文发送之后，是无法得知其是否安全完整到达的。在网络质量令人十分不满意的环境下，UDP协议数据包丢失会比较严重。但是由于UDP的特性：它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。比如我们聊天用的ICQ和QQ就是使用的UDP协议。</p>
<h3 id="TCP和UDP的总结"><a href="#TCP和UDP的总结" class="headerlink" title="TCP和UDP的总结"></a>TCP和UDP的总结</h3><p>TCP是一种流模式的协议，UDP是一种数据包模式的协议。</p>
<p>TCP是面向连接的，也就是说在连接持续的过程中，Socket中收到的数据都是由同一台主机发出的，因此只要保证数据是有序的到达就可以了，至于每次读取多少数据可以自己决定。</p>
<p>UDP是无连接的协议，也就是说，只要知道接收端的IP和端口，且网络是可达的，任何主机都可以向接收端发送数据。</p>
<p>UDP没有固定的主机，它在通讯之前不会测试这台主机是否存在，而直接发送数据。</p>
<h2 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h2><p>TCP是一种面向连接连接导向的、可靠的基于字节流的传输层通信协议。TCP将用户数据打包成报文段，它发送后启动一个定时器，另一端收到的数据进行确认、对失序的数据重新排序、丢弃重复数据。</p>
<p>报文是网络中交换与传输的数据单元，即一次性要发送的数据块，包含了将要发送的完整的数据信息，会不断的封装成分组、包、帧来传输。TCP报文的格式如下：</p>
<p> <img src="http://oboehz2ag.bkt.clouddn.com/TCP报文EN.jpg" alt="TCP报文EN"></p>
<p>固定首部长度为20字节，可变部分0~40字节，各字段解释：</p>
<ol>
<li>Source Port Number：源端口，范围0~65525。</li>
<li>Target Port Number：目的端口，范围同上。</li>
<li>Sequence Number：顺序号码，由发送方使用，TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</li>
<li>Acknowledgement Number：确认序号，是接收数据方期望收到发送方的下一个报文段的序号，因此确认序号应当是上次已成功收到数据字节序号加1。</li>
<li>Header Length：首部长度，它指出报文数据距TCP 报头的起始处有多远。一般首部长度为20字节。</li>
<li>Reserved：保留字段（图中，包含CWR，ECE）保留今后使用，默认是0。</li>
<li>URG：紧急比特，当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送，相当于表示高优先级的数据。</li>
<li>ACK：确认比特，只有当 ACK=1 时确认序号字段才有效。当 ACK=0 时，确认序号无效。</li>
<li>PSH：推送比特，接收方 TCP 收到推送比特置1的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。</li>
<li>RST：复位比特，当 RST=1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</li>
<li>SYN：同步比特，在建立连接时用来同步序号。SYN=1， ACK=0表示一个连接请求报文段。SYN=1，ACK=1表示同意建立连接。</li>
<li>FIN：终止比特，用来释放一个连接。当FIN=1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</li>
<li>Window Size：窗口大小，16bits，窗口字段用来控制对方发送的数据量，单位为字节。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限。</li>
<li>Checksum：检验和，16bits，该字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。由发端计算和存储，并由收端进行验证。</li>
<li>Urgent Pointer：紧急指针字段，16bits，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号。</li>
<li>Options：选项字段，长度可变。用于把附加信息传递给终点，或用来对齐其它选项。 这部分最多包含40字节，因为TCP头部最长是60字节，其中还包含上面的20字节的固定部分。</li>
</ol>
<p>Wireshark捕获到的TCP包报文下图所示：</p>
<p> <img src="http://oboehz2ag.bkt.clouddn.com/TCP抓包.png" alt="TCP抓包"></p>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>TCP建立连接和断开连接的过程称为三次握手和四次挥手， 所谓三次握手（Three-way Handshake），是指客户端和服务器之间建立连接的过程。</p>
<p>如下图所示，Wireshark截获到了三次握手的三个数据包。第四个包才是HTTP的，说明HTTP的确是使用TCP建立连接的。</p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/三次握手.png" alt="三次握手"></p>
<p>三次握手的流程图如下：</p>
<p> <img src="http://oboehz2ag.bkt.clouddn.com/三次握手流程.jpg" alt="三次握手流程"></p>
<p>第一次握手：Client发送位码为 SYN = 1，随机产生 seq = x 的数据包到服务器，Server由 SYN = 1 知道Client要求建立连接；</p>
<p>第二次握手：Server收到请求后要确认连接信息，向Client发送ack number = x + 1（PS: Client的seq + 1），SYN = 1，ACK=1，随机产生 seq = y 的包；</p>
<p>第三次握手：Client收到后检查ack number是否正确，即第一次发送的 seq + 1，以及位码ACK是否为1，若正确，Client会再发送 ack number = y + 1 （PS: Sever的seq + 1），ACK = 1，Server收到后确认seq值与 ACK = 1 则连接建立成功。</p>
<p>完成三次握手，Client与Server开始传送数据。</p>
<p>下面使用Wireshark逐步分析三次握手过程：</p>
<p>第一次握手：客户端向服务器发送连接请求包，标志位SYN（同步序号）为1，序号为X=0</p>
<p> <img src="http://oboehz2ag.bkt.clouddn.com/第一次握手.png" alt="第一次握手"></p>
<p>第二次握手：服务器收到客户端发过来报文，由SYN=1知道客户端要求建立联机。向客户端发送一个SYN和ACK都置为1的TCP报文，设置初始序号Y=0，将确认序号(Acknowledgement Number)设置为客户的序列号加1，即X+1 = 0+1=1, 如下图：</p>
<p> <img src="http://oboehz2ag.bkt.clouddn.com/第二次握手.png" alt="第二次握手"></p>
<p>第三次握手：客户端收到服务器发来的包后检查确认序号(Acknowledgement Number)是否正确，即第一次发送的序号加1（X+1=1）。以及标志位ACK是否为1。若正确，服务器再次发送确认包，ACK标志位为1，SYN标志位为0。确认序号（Acknowledgement Number）=Y+1=0+1=1，发送序号为X+1=1。客户端收到后确认序号值与ACK=1则连接建立成功，可以传送数据了。</p>
<p> <img src="http://oboehz2ag.bkt.clouddn.com/第三次握手.png" alt="第三次握手"></p>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://zhangbinalan.gitbooks.io/protocol/content/tcpbao_wen_ge_shi.html" target="_blank" rel="external">TCP介绍</a> - ZhangBinalan</p>
<p><a href="http://eiwodetianna.com/2015/11/30/iOS%E5%BC%80%E5%8F%91-Socket%E9%80%9A%E4%BF%A1/" target="_blank" rel="external">iOS开发-Socket通信</a> - Eiwodetianna.</p>
<p><a href="http://book.51cto.com/art/200906/127291.htm" target="_blank" rel="external">Linux服务器安全策略详解（第二版）</a>- 曹江华</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两个应用程序之间的通信，我们可以理解为进程之间的通信，而进程之间进行通信的前提是我们能够找到某个进程，因此，我们需要给进程添加唯一的标示，在本地进程通信中我们可以使用PID来标示一个进程，但PID只在本地唯一，网络中的多个计算机之间的进程标示并不能保证唯一性，冲突的几率很大。&lt;/p&gt;
&lt;p&gt;这时候我们需要另辟蹊径，TCP/IP协议族已为我们解决了这个问题，IP层的IP地址可以标示主机，而TCP层协议和端口号可以标示某个主机的某个进程，于是我们采取&lt;strong&gt;IP地址＋协议＋端口号&lt;/strong&gt;作为唯一标示的这种形式，来确定网络中的一个进程，从而进行进程之间的通讯，这种方式就是我们Socket使用的通讯方式。&lt;/p&gt;
&lt;p&gt;在学习Socket通讯之前，首先需要了解&lt;strong&gt;网络通讯结构、TCP和UPD&lt;/strong&gt;，以下是这这两个知识点的简要介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="网络通讯" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/"/>
    
    
      <category term="网络通讯" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/"/>
    
      <category term="TCP/IP协议" scheme="http://yoursite.com/tags/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>iOS调试 - 单元测试</title>
    <link href="http://yoursite.com/2016/09/12/iOS%E8%B0%83%E8%AF%95%20-%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2016/09/12/iOS调试 - 单元测试/</id>
    <published>2016-09-11T18:24:00.000Z</published>
    <updated>2016-09-26T09:52:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>每个 iOS 程序员都要时不时的为他们的 APP 做 Debug。除非你是那种超级大牛，否则你肯定体验过查了无数个小时的 Bug 最后才发现那仅仅是个简单的语法错误时那种油然而生的绝望感。或者更糟：你根本就没发现那些 Bug。无论你是编程新手，还是开发过很多 APP 的老司机，例行的写写单元测试会让你的代码更可靠，更安全，更容易 Debug！</p>
<p>你很走运，Xcode 7 和 Swift 支持单元测试。尽管单元测试不保证（有了它你就会写出）绝对没有 Bug 的 APP，它还是一种能让你验证每段代码是否如期工作，并让 debug 过程更加便利。</p>
<p>正如其名，在单元测试中你要为某段代码单元创建一些小规模的、针对其某个特性的测试，然后确保每个代码单元都能通过这些测试。如果通过的话，它的旁边会出现一个绿色小标志，而如果因故测试不通过， Xcode 会把该测试标记为 “failed”。这就提示你去查看代码，找出失败原因。</p>
<p>这篇教程将简要介绍如何在 Swift 项目中使用<code>XCTest.framework</code>进行代码单元测试。那么我们为什么需要做单元测试呢？单元测试对于我们有以下几点帮助：</p>
   <a id="more"></a>
<ul>
<li><p>帮助理解需求，单元测试应该反映 Use Case，把被测单元当成黑盒测试其外部行为。</p>
</li>
<li><p>提高实现质量，单元测试不保证程序做正确的事，但能帮助保证程序正确地做事，从而提高实现质量。</p>
</li>
<li><p>测试成本低，相比集成测试、验收测试，单元测试所依赖的外部环境少，自动化程度高，时间短，节约了测试成本。</p>
</li>
<li><p>反馈速度快，单元测试提供快速反馈，把 Bug 消灭在开发阶段，减少问题流到集成测试、验收测试和用户，降低了软件质量控制的成本。</p>
</li>
<li><p>利于重构，由于有单元测试作为回归测试用例，有助于预防在重构过程中引入 Bug。</p>
</li>
<li><p>文档作用，单元测试提供了被测单元的使用场景，起到了使用文档的作用。</p>
</li>
<li><p>对设计的反馈，一个模块很难进行单元测试通常是不良设计的信号，单元测试可以反过来指导设计出高内聚、低耦合的模块。</p>
</li>
</ul>
<p>  ​</p>
<h2 id="默认测试类"><a href="#默认测试类" class="headerlink" title="默认测试类"></a>默认测试类</h2><p>首先我们新建一个项目<code>SwiftUnitTest</code>，它将在<code>SwiftUnitTestTests</code>目录下自动创建出一个默认测试类（文件）<code>SwiftUnitTestTests.swift</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> XCTest</div><div class="line"><span class="meta">@testable</span> <span class="keyword">import</span> SwiftUnitTest</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwiftUnitTestTests</span>: <span class="title">XCTestCase</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.setUp()</div><div class="line">        <span class="comment">// Put setup code here. This method is called before the invocation of each test method in the class.</span></div><div class="line">        <span class="comment">//在此可以定义测试中用到的属性</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tearDown</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">// Put teardown code here. This method is called after the invocation of each test method in the class.</span></div><div class="line">        <span class="comment">//在此添加准备代码。此方法在每个测试用例执行前执行</span></div><div class="line">        <span class="keyword">super</span>.tearDown()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testExample</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">// This is an example of a functional test case.</span></div><div class="line">        <span class="comment">//这是一个测试用例</span></div><div class="line">        <span class="comment">// Use XCTAssert and related functions to verify your tests produce the correct results.</span></div><div class="line">        <span class="comment">//使用XCTAssert和相关方法测试结果是否正确</span></div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testPerformanceExample</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">// This is an example of a performance test case.</span></div><div class="line">        <span class="comment">//这是一个测试用例</span></div><div class="line">        <span class="keyword">self</span>.measure &#123;</div><div class="line">            <span class="comment">// Put the code you want to measure the time of here.</span></div><div class="line">            <span class="comment">//在此填写需要测量运行时间的代码</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个文件中定义了一个测试类<code>SwiftUnitTestTests</code>，它里面包含了一个<code>setUp()</code>方法和<code>tearDown()</code>方法，分别用来在每个测试方法运行之前做初始化准备，和在测试方法运行之后做清理工作。此外，它还包含了以<code>test</code>开头命名的2个测试方法：<code>testExample()</code>和<code>testPerformanceExample()</code>。</p>
<p>我们需要注意：</p>
<ul>
<li>任何以<code>test</code>开头命名的的方法都是一个测试方法，在每次单元测试执行时自动执行，它没有返回值；</li>
<li>在测试方法中，可以使用<code>self.measureBlock() { }</code>来测量代码的运行时间；</li>
<li>测试方法执行的顺序跟测试方法名有关，比如<code>test01()</code>会优先于<code>test02()</code>执行</li>
</ul>
<p>通过快捷键<code>CMD+U</code>即可运行当前的单元测试。可以看到所有测试方法已通过。同样，使用<code>CMD+SHIFT+Y</code>打开<code>Console</code>也能看到相应测试方法的运行提示。</p>
<h2 id="定制测试类"><a href="#定制测试类" class="headerlink" title="定制测试类"></a>定制测试类</h2><p>为了更好的管理测试用例，我们建议为某个需要测试的类单独创建一个测试类（文件），在这之前，我们先创建一个简单的类用来测试：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span>!</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</div><div class="line">        name = <span class="string">"Children"</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">transfrom</span><span class="params">()</span></span> &#123;</div><div class="line">        name = <span class="string">"GrownMan"</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类定义了一种<code>Person</code>类型，它有一个属性叫<code>name</code>，其初始状态为Children。我们可以对其调用<code>transform</code>方法，之后它就变成了GrownMan。</p>
<p>然后我们新建一个针对<code>Person</code>类做测试的测试类：新建文件，选择<code>Test Case Class</code>, 为此类取名为<code>PersonTest</code>（建议使用<code>&lt;待测试类名&gt;Tests</code>的形式）：</p>
<p>然后我们删除原来的<code>testExample</code>测试方法，并新建方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">testPersonTransformation</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> person = <span class="type">Person</span>()</div><div class="line">    person.transfrom()</div><div class="line">    <span class="type">XCTAssert</span>(person.name == <span class="string">"GrownMan"</span>, <span class="string">"Test result is correct"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果此时Xcode提示无法找到<code>Person</code>的类定义，请在顶部加上 <code>@testable import SwiftUnitTest</code>。里面的<code>SwiftUnitTest</code>是当前项目的名称。</p>
</blockquote>
<p>在此测试方法中，我们创建出了一个新的<code>Person</code>实例，然后对其调用<code>transform()</code>方法。这时我们使用断言<code>XCTAssert</code>来判断<code>person</code>目前的<code>name</code>属性值是否为<code>GrownMan</code>。<code>XCTAssert</code>是一个全局函数，它的第一个参数为布尔表达式，如果为<code>true</code>表示断言通过；它的第二个参数为断言的描述。</p>
<blockquote>
<p>注意：如果实例创建比较复杂，并且需要在多个测试方法中使用。你可以在类中定义对应的实例属性，并且在<code>setUp()</code>方法中进行初始化，在<code>tearDown()</code>方法中进行资源清理。</p>
</blockquote>
<h2 id="运行单元测试"><a href="#运行单元测试" class="headerlink" title="运行单元测试"></a>运行单元测试</h2><p>此时执行<code>CMD+U</code>运行单元测试，可以看到单元测试都已通过： <img src="http://oboehz2ag.bkt.clouddn.com/test.png" alt="test"></p>
<p>然后我们再修改原有测试方法<code>testPerformanceExample()</code>中的内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">testPerformanceExample</span><span class="params">()</span></span> &#123;</div><div class="line">       <span class="keyword">self</span>.measure &#123;</div><div class="line">           <span class="keyword">var</span> sum: <span class="type">Double</span> = <span class="number">0</span></div><div class="line">           <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...<span class="number">1000000</span> &#123;</div><div class="line">               sum += <span class="type">Double</span>(i)</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>再次<code>CMD+U</code>执行单元测试，等待几秒钟，可以看到所有测试用例都已通过，打开<code>console</code>可以看到<code>testPerformanceExample()</code>中代码的运行时间：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="type">Test</span> <span class="type">Case</span> '-[<span class="type">SwiftUnitTestUITests</span>.<span class="type">SwiftUnitTestUITests</span> testExample]' started.</div><div class="line">    t =     <span class="number">0</span>.00s     <span class="type">Start</span> <span class="type">Test</span> at <span class="number">2016</span>-<span class="number">09</span>-<span class="number">26</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">54.905</span></div><div class="line">    t =     <span class="number">0</span>.00s     <span class="type">Set</span> <span class="type">Up</span></div><div class="line">    t =     <span class="number">0</span>.01s         <span class="type">Launch</span> space.tianziyao.<span class="type">SwiftUnitTest</span></div><div class="line">    t =     <span class="number">3</span>.99s             <span class="type">Waiting</span> <span class="keyword">for</span> accessibility to load</div><div class="line">    t =     <span class="number">5</span>.63s             <span class="type">Wait</span> <span class="keyword">for</span> app to idle</div><div class="line">    t =     <span class="number">6</span>.85s     <span class="type">Tear</span> <span class="type">Down</span></div><div class="line"><span class="type">Test</span> <span class="type">Case</span> '-[<span class="type">SwiftUnitTestUITests</span>.<span class="type">SwiftUnitTestUITests</span> testExample]' passed (<span class="number">7.061</span> seconds).</div><div class="line"><span class="type">Test</span> <span class="type">Suite</span> '<span class="type">SwiftUnitTestUITests'</span> passed at <span class="number">2016</span>-<span class="number">09</span>-<span class="number">26</span> <span class="number">15</span>:<span class="number">06</span>:<span class="number">01.967</span>.<span class="type">Executed</span> <span class="number">1</span> test, with <span class="number">0</span> failures (<span class="number">0</span> unexpected) <span class="keyword">in</span> <span class="number">7.061</span> (<span class="number">7.063</span>) seconds</div><div class="line"><span class="type">Test</span> <span class="type">Suite</span> '<span class="type">SwiftUnitTestUITests</span>.xctest' passed at <span class="number">2016</span>-<span class="number">09</span>-<span class="number">26</span> <span class="number">15</span>:<span class="number">06</span>:<span class="number">01.968</span>.<span class="type">Executed</span> <span class="number">1</span> test, with <span class="number">0</span> failures (<span class="number">0</span> unexpected) <span class="keyword">in</span> <span class="number">7.061</span> (<span class="number">7.065</span>) seconds</div><div class="line"><span class="type">Test</span> <span class="type">Suite</span> '<span class="type">All</span> tests' passed at <span class="number">2016</span>-<span class="number">09</span>-<span class="number">26</span> <span class="number">15</span>:<span class="number">06</span>:<span class="number">01.969</span>.<span class="type">Executed</span> <span class="number">1</span> test, with <span class="number">0</span> failures (<span class="number">0</span> unexpected) <span class="keyword">in</span> <span class="number">7.061</span> (<span class="number">7.067</span>) seconds</div></pre></td></tr></table></figure>
<h2 id="断言测试API列表"><a href="#断言测试API列表" class="headerlink" title="断言测试API列表"></a>断言测试API列表</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="type">XCTFail</span>(format…)</div><div class="line"><span class="comment">//生成一个失败的测试；</span></div><div class="line"><span class="type">XCTAssertNil</span>(a1, format...)</div><div class="line"><span class="comment">//为空判断，a1为空时通过，反之不通过；</span></div><div class="line"><span class="type">XCTAssertNotNil</span>(a1, format…)</div><div class="line"><span class="comment">//不为空判断，a1不为空时通过，反之不通过；</span></div><div class="line"><span class="type">XCTAssert</span>(expression, format...)</div><div class="line"><span class="comment">//当expression求值为TRUE时通过；</span></div><div class="line"><span class="type">XCTAssertTrue</span>(expression, format...)</div><div class="line"><span class="comment">//当expression求值为TRUE时通过；</span></div><div class="line"><span class="type">XCTAssertFalse</span>(expression, format...)</div><div class="line"><span class="comment">//当expression求值为False时通过；</span></div><div class="line"><span class="type">XCTAssertEqualObjects</span>(a1, a2, format...)</div><div class="line"><span class="comment">//判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；</span></div><div class="line"><span class="type">XCTAssertNotEqualObjects</span>(a1, a2, format...)</div><div class="line"><span class="comment">//判断不等，[a1 isEqual:a2]值为False时通过；</span></div><div class="line"><span class="type">XCTAssertEqual</span>(a1, a2, format...)</div><div class="line"><span class="comment">//判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；</span></div><div class="line"><span class="type">XCTAssertNotEqual</span>(a1, a2, format...)</div><div class="line"><span class="comment">//判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；</span></div><div class="line"><span class="type">XCTAssertEqualWithAccuracy</span>(a1, a2, accuracy, format...)</div><div class="line"><span class="comment">//判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；</span></div><div class="line"><span class="type">XCTAssertNotEqualWithAccuracy</span>(a1, a2, accuracy, format...)</div><div class="line"><span class="comment">//判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；</span></div><div class="line"><span class="type">XCTAssertThrows</span>(expression, format...)</div><div class="line"><span class="comment">//异常测试，当expression发生异常时通过；反之不通过；（很变态）</span></div><div class="line"><span class="type">XCTAssertThrowsSpecific</span>(expression, specificException, format...)</div><div class="line"><span class="comment">//异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；</span></div><div class="line"><span class="type">XCTAssertThrowsSpecificNamed</span>(expression, specificException, exception_name, format...)</div><div class="line"><span class="comment">//异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；</span></div><div class="line"><span class="type">XCTAssertNoThrow</span>(expression, format…)</div><div class="line"><span class="comment">//异常测试，当expression没有发生异常时通过测试；</span></div><div class="line"><span class="type">XCTAssertNoThrowSpecific</span>(expression, specificException, format...)</div><div class="line"><span class="comment">//异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；</span></div><div class="line"><span class="type">XCTAssertNoThrowSpecificNamed</span>(expression, specificException, exception_name, format...)</div><div class="line"><span class="comment">//异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；</span></div></pre></td></tr></table></figure>
<h2 id="Demo下载请点击这里"><a href="#Demo下载请点击这里" class="headerlink" title="Demo下载请点击这里"></a>Demo下载请<a href="https://github.com/tianziyao/SwiftUnitTest" target="_blank" rel="external">点击这里</a></h2><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="http://letsswift.com/2014/06/swift-unit-test/" target="_blank" rel="external">http://letsswift.com/2014/06/swift-unit-test/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每个 iOS 程序员都要时不时的为他们的 APP 做 Debug。除非你是那种超级大牛，否则你肯定体验过查了无数个小时的 Bug 最后才发现那仅仅是个简单的语法错误时那种油然而生的绝望感。或者更糟：你根本就没发现那些 Bug。无论你是编程新手，还是开发过很多 APP 的老司机，例行的写写单元测试会让你的代码更可靠，更安全，更容易 Debug！&lt;/p&gt;
&lt;p&gt;你很走运，Xcode 7 和 Swift 支持单元测试。尽管单元测试不保证（有了它你就会写出）绝对没有 Bug 的 APP，它还是一种能让你验证每段代码是否如期工作，并让 debug 过程更加便利。&lt;/p&gt;
&lt;p&gt;正如其名，在单元测试中你要为某段代码单元创建一些小规模的、针对其某个特性的测试，然后确保每个代码单元都能通过这些测试。如果通过的话，它的旁边会出现一个绿色小标志，而如果因故测试不通过， Xcode 会把该测试标记为 “failed”。这就提示你去查看代码，找出失败原因。&lt;/p&gt;
&lt;p&gt;这篇教程将简要介绍如何在 Swift 项目中使用&lt;code&gt;XCTest.framework&lt;/code&gt;进行代码单元测试。那么我们为什么需要做单元测试呢？单元测试对于我们有以下几点帮助：&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS调试" scheme="http://yoursite.com/tags/iOS%E8%B0%83%E8%AF%95/"/>
    
      <category term="单元测试" scheme="http://yoursite.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>微信开发 - access_token</title>
    <link href="http://yoursite.com/2016/09/05/%E5%BE%AE%E4%BF%A1%E6%8E%A5%E5%8F%A3%20-%20access%20token/"/>
    <id>http://yoursite.com/2016/09/05/微信接口 - access token/</id>
    <published>2016-09-04T18:24:00.000Z</published>
    <updated>2016-09-05T12:08:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>在微信公众平台接口开发中，access_token占据了一个很重要的地位，它相当于进入各种接口的钥匙，拿到这个钥匙才有调用其他各种特殊接口的权限。</p>
<p>同样微信服务器也是通过access_token识别是哪个公众号，以及该公众号是否有权限调用该接口。</p>
<p>access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。开发者需要进行妥善保存。access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。</p>
<p><strong>公众号可以使用AppID和AppSecret调用本接口来获取access_token。AppID和AppSecret可在开发模式中获得，注意调用所有微信接口时均需使用https协议。</strong></p>
   <a id="more"></a>
<h2 id="access-token开发策略"><a href="#access-token开发策略" class="headerlink" title="access_token开发策略"></a>access_token开发策略</h2><p>因为access_token具有每天2000次的访问限制，而access_token又是很重要的属性，调用非常频繁，基本上所有的接口都需要使用access_token来进行访问权限的验证，当频繁调用微信API时，很有可能会超出2000次的限制。因此普遍的解决方案是将一次获取的access_token保存到数据库，在两个小时后再更新数据库，在这两个小时内，所有需要access_token的地方全部到数据库来取。 </p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/access_token%E5%BC%80%E5%8F%91%E7%AD%96%E7%95%A5.gif" alt="access_token开发策略"></p>
<h2 id="接口调用请求说明"><a href="#接口调用请求说明" class="headerlink" title="接口调用请求说明"></a>接口调用请求说明</h2><p>使用HTTP请求，请求方式为GET：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</div></pre></td></tr></table></figure>
<p>请求中附带的参数为：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>grant_type</td>
<td>是</td>
<td>获取access_token填写client_credential</td>
</tr>
<tr>
<td>appid</td>
<td>是</td>
<td>第三方用户唯一凭证</td>
</tr>
<tr>
<td>secret</td>
<td>是</td>
<td>第三方用户唯一凭证密钥，即appsecret</td>
</tr>
</tbody>
</table>
<h2 id="返回说明"><a href="#返回说明" class="headerlink" title="返回说明"></a>返回说明</h2><p>正常情况下，微信会返回下述JSON数据包给公众号：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="attr">"access_token"</span>:<span class="string">"ACCESS_TOKEN"</span>,<span class="attr">"expires_in"</span>:<span class="number">7200</span>&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>access_token</td>
<td>获取到的凭证</td>
</tr>
<tr>
<td>expires_in</td>
<td>凭证有效时间，单位：秒</td>
</tr>
</tbody>
</table>
<h2 id="获取粉丝头像"><a href="#获取粉丝头像" class="headerlink" title="获取粉丝头像"></a>获取粉丝头像</h2><p>下面我们用获取粉丝头像的例子来演示如何使用access_token。</p>
<p>首先写一个PHP文件，来获取access_token：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">getaccesstoken.php</div><div class="line"></div><div class="line"><span class="meta">&lt;?php</span></div><div class="line">define(<span class="string">'appid'</span>, <span class="string">'wx5d649f3295ce323a'</span>);</div><div class="line">define(<span class="string">'app_secret'</span>, <span class="string">'a17ecddd3fb0699814fce90fa6376b8e'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_access_token</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    $url = <span class="string">"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid="</span>.appid.<span class="string">"&amp;secret="</span>.app_secret;</div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    $ch = curl_init();</div><div class="line">    <span class="comment">//设置选项，包括URL</span></div><div class="line">    curl_setopt($ch, CURLOPT_URL, $url);</div><div class="line">    curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_USERAGENT, <span class="number">1</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_ENCODING, <span class="string">"gzip"</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">//执行并获取HTML文档内容</span></div><div class="line">    $output = curl_exec($ch);</div><div class="line">    <span class="comment">//释放curl句柄</span></div><div class="line">    curl_close($ch);</div><div class="line">    <span class="comment">//打印获得的数据</span></div><div class="line">    <span class="comment">//print_r($output);</span></div><div class="line">    $access_taken_arr = json_decode($output, <span class="keyword">true</span>);</div><div class="line">    $access_token = $access_taken_arr[<span class="string">"access_token"</span>];</div><div class="line">    <span class="comment">//print_r($access_taken_arr);</span></div><div class="line">    <span class="keyword">return</span> $access_token;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>新建另一个PHP文件，首先获取粉丝列表，提取出粉丝的openid组成数组：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_user_list</span><span class="params">($access_token)</span> </span>&#123;</div><div class="line"></div><div class="line">    $url = <span class="string">"https://api.weixin.qq.com/cgi-bin/user/get?access_token="</span>.$access_token;</div><div class="line">    <span class="comment">//echo $access_token;</span></div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    $ch = curl_init();</div><div class="line">    <span class="comment">//设置选项，包括URL</span></div><div class="line">    curl_setopt($ch, CURLOPT_URL, $url);</div><div class="line">    curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_USERAGENT, <span class="number">1</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_ENCODING, <span class="string">"gzip"</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">//执行并获取HTML文档内容</span></div><div class="line">    $output = curl_exec($ch);</div><div class="line">    <span class="comment">//释放curl句柄</span></div><div class="line">    curl_close($ch);</div><div class="line">    <span class="comment">//打印获得的数据</span></div><div class="line">    <span class="comment">//print_r($output);</span></div><div class="line">    $user_list_arr = json_decode($output, <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">return</span> ($user_list_arr[<span class="string">"data"</span>][<span class="string">"openid"</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后利用openid获取粉丝的用户信息：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_user_info</span><span class="params">($access_token, $openid)</span> </span>&#123;</div><div class="line"></div><div class="line">    $url = <span class="string">"https://api.weixin.qq.com/cgi-bin/user/info?access_token="</span>.$access_token.<span class="string">"&amp;openid="</span>.$openid.<span class="string">"&amp;lang=zh_CN"</span>;</div><div class="line"></div><div class="line">    $ch = curl_init();</div><div class="line">    curl_setopt($ch, CURLOPT_URL, $url);</div><div class="line">    curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_USERAGENT, <span class="number">1</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_ENCODING, <span class="string">"gzip"</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    $output = curl_exec($ch);</div><div class="line">    curl_close($ch);</div><div class="line"></div><div class="line">    $user_info_arr = json_decode($output, <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">return</span> ($user_info_arr[<span class="string">"headimgurl"</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后从用户信息中提取出用户头像的url，并传给iOS客户端：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ($i=<span class="number">0</span>; $i&lt;<span class="number">3</span>; $i++) &#123;</div><div class="line">    $openid = $openids[$i];</div><div class="line">    $use_info = get_user_info($access_token, $openid);</div><div class="line">    $user_image = substr($use_info, <span class="number">0</span>, strlen($str)<span class="number">-2</span>).<span class="string">"/132"</span>;</div><div class="line">    <span class="comment">//echo $user_image;</span></div><div class="line">    array_push($user_images, $user_image);</div><div class="line">&#125;</div><div class="line"><span class="keyword">echo</span> json_encode($user_images);</div></pre></td></tr></table></figure>
<p>在Xcode中创建工程，使用NSURLSession获取PHP服务器传来的包含粉丝头像url的数组，利用url获取粉丝头像，并将其设置为工程中ImageView的Image，这里需要注意的是，<strong>UI操作要转到主线程进行</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getWechatFansHeadImgs</span><span class="params">()</span></span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">self</span>.pleaseWait()</div><div class="line">        </div><div class="line">        <span class="comment">//let request = NSURLRequest(URL: NSURL(string: "http://localhost:8888/i/wechat/getuserinfo.php")!)</span></div><div class="line">        <span class="keyword">let</span> request = <span class="type">NSURLRequest</span>(<span class="type">URL</span>: <span class="type">NSURL</span>(string: <span class="string">"http://123.206.27.127/wechat/getuserinfo.php"</span>)!)</div><div class="line"></div><div class="line">        <span class="keyword">let</span> task = <span class="type">NSURLSession</span>.sharedSession().dataTaskWithRequest(request) &#123; (data, resp, error) <span class="keyword">in</span></div><div class="line">            </div><div class="line">            <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</div><div class="line">                <span class="built_in">print</span>(error?.localizedDescription)</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">var</span> imgLinks: [<span class="type">String</span>] = []</div><div class="line">                <span class="keyword">let</span> readingOprions = <span class="type">NSJSONReadingOptions</span>.<span class="type">MutableContainers</span></div><div class="line">                imgLinks = <span class="keyword">try</span>! <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(data!, options: readingOprions) <span class="keyword">as</span>! <span class="type">Array</span><span class="comment">//nil</span></div><div class="line">                <span class="built_in">print</span>(imgLinks)</div><div class="line">                </div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;imgLinks.<span class="built_in">count</span> &#123;</div><div class="line">                    <span class="keyword">if</span> imgLinks[i] != <span class="string">""</span> &#123;</div><div class="line">                        <span class="keyword">let</span> data = <span class="type">NSData</span>(contentsOfURL: <span class="type">NSURL</span>(string: imgLinks[i])!)</div><div class="line">                        dispatch_async(dispatch_get_main_queue(), &#123;</div><div class="line">                            <span class="keyword">self</span>.headImageViews[i].image = data != <span class="literal">nil</span> ? <span class="type">UIImage</span>(data: data!) : <span class="literal">nil</span></div><div class="line">                            <span class="built_in">print</span>(i)</div><div class="line">                        &#125;)</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="built_in">print</span>(<span class="type">NSThread</span>.currentThread())</div><div class="line">                dispatch_async(dispatch_get_main_queue(), &#123;</div><div class="line">                    <span class="keyword">self</span>.clearAllNotice()</div><div class="line">                    <span class="keyword">self</span>.noticeSuccess(<span class="string">"获取成功"</span>, autoClear: <span class="literal">true</span>, autoClearTime: <span class="number">2</span>)</div><div class="line">                &#125;)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        task.resume()</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>最后使用点击事件触发这个方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">showHeadImageButtonDidTouch</span><span class="params">(sender: AnyObject)</span></span> &#123;</div><div class="line">    </div><div class="line">    getWechatFansHeadImgs()</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Demo下载请点击这里"><a href="#Demo下载请点击这里" class="headerlink" title="Demo下载请点击这里"></a>Demo下载请<a href="https://github.com/tianziyao/demo" target="_blank" rel="external">点击这里</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在微信公众平台接口开发中，access_token占据了一个很重要的地位，它相当于进入各种接口的钥匙，拿到这个钥匙才有调用其他各种特殊接口的权限。&lt;/p&gt;
&lt;p&gt;同样微信服务器也是通过access_token识别是哪个公众号，以及该公众号是否有权限调用该接口。&lt;/p&gt;
&lt;p&gt;access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。开发者需要进行妥善保存。access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公众号可以使用AppID和AppSecret调用本接口来获取access_token。AppID和AppSecret可在开发模式中获得，注意调用所有微信接口时均需使用https协议。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="微信开发" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="微信开发" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>微信开发 - 接口简介</title>
    <link href="http://yoursite.com/2016/09/05/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%20-%20%E6%8E%A5%E5%8F%A3%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2016/09/05/微信开发 - 接口简介/</id>
    <published>2016-09-04T18:24:00.000Z</published>
    <updated>2016-09-05T12:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于用户体验和安全性方面的考虑，微信公众号的注册有一定门槛，某些高级接口的权限需要微信认证后才可以获取。所以，为了帮助开发者快速了解和上手微信公众号开发，熟悉各个接口的调用，需要开通测试账号。</p>
<p>开通测试账号的路径为：</p>
<blockquote>
<p>微信公众平台 &gt; 开发者工具 &gt; 公众平台测试帐号 &gt; 进入</p>
</blockquote>
<p>或点击<a href="http://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;t=sandbox/index" target="_blank" rel="external">传送门</a>，需要填写的为以下几项：</p>
<blockquote>
<p>URL：接口文档所在的路径，如：<code>https://localhost/filepath/wxapifile.php</code></p>
<p>Token：接口文档中设定的Token</p>
<p>域名：网址或主机名，如：<code>localhost</code></p>
</blockquote>
<p>如对以上步骤陌生的同学可以先看<a href="https://tianziyao.github.io/2016/09/02/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%20-%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" target="_blank" rel="external">这篇文章</a>。</p>
   <a id="more"></a>
<h2 id="接口频率限制"><a href="#接口频率限制" class="headerlink" title="接口频率限制"></a>接口频率限制</h2><p>公众号调用接口并不是无限制的。为了防止公众号的程序错误而引发微信服务器负载异常，默认情况下，每个公众号调用接口都不能超过一定限制，当超过一定限制时，调用对应接口会收到如下错误返回码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;errcode&quot;:45009,&quot;errmsg&quot;:&quot;api freq out of limit&quot;&#125;</div></pre></td></tr></table></figure>
<p>接口频率限制的说明请点击<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433744592&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">传送门</a>。</p>
<h2 id="全局返回码"><a href="#全局返回码" class="headerlink" title="全局返回码"></a>全局返回码</h2><p>公众号每次调用接口时，可能获得正确或错误的返回码，开发者可以根据返回码信息调试接口，排查错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;errcode&quot;:45009,&quot;errmsg&quot;:&quot;api freq out of limit&quot;&#125;</div></pre></td></tr></table></figure>
<p>如上的返回码<code>45009</code>表达的就是<code>接口调用超过限制</code>。接口频率限制的说明请点击<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433744592&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">传送门</a>。</p>
<h2 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h2><p>access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。开发者需要进行妥善保存。</p>
<p>access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。</p>
<p>access_token相当于开发者的服务器访问微信服务器的一把钥匙，而微信服务器提供的各种API是一个个门，具有正确的access_token才可以得到门后面的东西。</p>
<h3 id="获取微信服务器IP接口"><a href="#获取微信服务器IP接口" class="headerlink" title="获取微信服务器IP接口"></a>获取微信服务器IP接口</h3><p>如果公众号基于安全等考虑，需要获知微信服务器的IP地址列表，以便进行相关限制，它一般是为了判断请求是否来自于微信，如不是微信服务器则可以返回非法访问等操作。</p>
<h3 id="长链接转短链接接口"><a href="#长链接转短链接接口" class="headerlink" title="长链接转短链接接口"></a>长链接转短链接接口</h3><p>顾名思义，就是将一条长链接转成短链接。它的主要使用场景是，如果开发者用于生成二维码的原链接（商品、支付二维码等）太长导致扫码速度和成功率下降，将原长链接通过此接口转成短链接再生成二维码将大大提升扫码速度和成功率。</p>
<h3 id="获取用户列表接口"><a href="#获取用户列表接口" class="headerlink" title="获取用户列表接口"></a>获取用户列表接口</h3><p>公众号可通过本接口来获取帐号的关注者列表，关注者列表由一串OpenID（加密后的微信号，每个用户对每个公众号的OpenID是唯一的）组成。一次拉取调用最多拉取10000个关注者的OpenID，可以通过多次拉取的方式来满足需求。</p>
<p>它主要用于获取和保存用户信息，在高级群发接口中也会使用到。</p>
<h3 id="获取用户基本信息接口"><a href="#获取用户基本信息接口" class="headerlink" title="获取用户基本信息接口"></a>获取用户基本信息接口</h3><p>在关注者与公众号产生消息交互后，公众号可获得关注者的OpenID（加密后的微信号，每个用户对每个公众号的OpenID是唯一的。对于不同公众号，同一用户的openid不同）。</p>
<p>公众号可通过本接口来根据OpenID获取用户基本信息，包括<strong>昵称、头像、性别、所在城市、语言和关注时间</strong>。</p>
<h4 id="UnionID机制"><a href="#UnionID机制" class="headerlink" title="UnionID机制"></a>UnionID机制</h4><p>开发者可通过OpenID来获取用户基本信息。特别需要注意的是，<strong>如果开发者拥有多个移动应用、网站应用和公众帐号，可通过获取用户基本信息中的unionid来区分用户的唯一性</strong>。</p>
<p>因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号，用户的unionid是唯一的，换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。 </p>
<p><strong>这也就是说，openid是开发者的唯一用户标识，unionid是整个微信的唯一用户标识，openid是获取unionid的先决条件，两种标识都需要用户关注或使用应用后才能获取。</strong></p>
<h3 id="网页授权接口"><a href="#网页授权接口" class="headerlink" title="网页授权接口"></a>网页授权接口</h3><p>如果用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息。</p>
<h4 id="网页授权的两种范围"><a href="#网页授权的两种范围" class="headerlink" title="网页授权的两种范围"></a>网页授权的两种范围</h4><ul>
<li>以snsapi_base为scope发起的网页授权，是用来<strong>获取进入页面的用户的openid的</strong>，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面）。</li>
<li>以snsapi_userinfo为scope发起的网页授权，是用来<strong>获取用户的基本信息的</strong>。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。 </li>
<li>用户管理类接口中的“获取用户基本信息接口”，是在用户和公众号产生消息交互或关注后事件推送后，才能根据用户OpenID来获取用户基本信息。这个接口，包括其他微信接口，都是<strong>需要该用户（即openid）关注了公众号后，才能调用成功的</strong>。 </li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">snsapi_userinfo演示</th>
<th style="text-align:center">可能是snsapi_base</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://oboehz2ag.bkt.clouddn.com/snsapi_userinfo.jpg" alt="snsapi_userinfo"></td>
<td style="text-align:center"><img src="http://oboehz2ag.bkt.clouddn.com/snsapi_base.jpg" alt="snsapi_base"></td>
</tr>
</tbody>
</table>
<h3 id="高级群发接口"><a href="#高级群发接口" class="headerlink" title="高级群发接口"></a>高级群发接口</h3><p>在公众平台网站上，为订阅号提供了每天一条的群发权限，为服务号提供每月（自然月）4条的群发权限。而对于某些具备开发能力的公众号运营者，可以通过高级群发接口，实现更灵活的群发能力。</p>
<p>高级群发具有两个优点：</p>
<ul>
<li>可根据用户标签或openid进行群发，普通群发只可针对标签和全部进行群发，高级群发的针对性更强；</li>
<li>高级群发图文内容支持HTML</li>
</ul>
<h3 id="JS-SDK接口"><a href="#JS-SDK接口" class="headerlink" title="JS-SDK接口"></a>JS-SDK接口</h3><p>微信JS-SDK是微信公众平台面向网页开发者提供的基于微信内的网页开发工具包。</p>
<p>通过使用微信JS-SDK，网页开发者可借助微信高效地使用拍照、选图、语音、位置等手机系统的能力，同时可以直接使用微信分享、扫一扫、卡券、支付等微信特有的能力，为微信用户提供更优质的网页体验。</p>
<p>例如分享功能，JS-SDK可以提供自定义分享标题，内容和图片的支持，还有调用相机，位置等接口。</p>
<h3 id="模板消息接口"><a href="#模板消息接口" class="headerlink" title="模板消息接口"></a>模板消息接口</h3><p>公众号可以主动向用户发送消息，用户可以收到服务号每月4条，订阅号每天1条的消息，超出后公众号发送的消息将对此用户屏蔽，这样的限制是不能满足我们的开发需求的。</p>
<p>当用户在公众号进行特定行为时，可以使用模板消息。模板消息仅用于公众号向用户发送重要的服务通知，只能用于符合其要求的服务场景中，如信用卡刷卡通知，商品购买成功通知等。</p>
<p>不支持广告等营销类消息以及其它所有可能对用户造成骚扰的消息。</p>
<table>
<thead>
<tr>
<th style="text-align:center">JS-SDK分享演示</th>
<th style="text-align:center">模板消息演示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://oboehz2ag.bkt.clouddn.com/JSSDK.PNG" alt="JSSDK"></td>
<td style="text-align:center"><img src="http://oboehz2ag.bkt.clouddn.com/%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF.PNG" alt="模板消息"></td>
</tr>
</tbody>
</table>
<h2 id="开发前确定需要的接口"><a href="#开发前确定需要的接口" class="headerlink" title="开发前确定需要的接口"></a>开发前确定需要的接口</h2><p>案例如下：</p>
<p>某公司希望将自己的PC商城和自己的微信公众平台进行对接，也就是在微信上绑定PC商城账号的功能，以实现在微信中点击菜单无需登录即可查看自己账号的详情，购物记录等。</p>
<p>那么如何得知需要的接口有哪些呢？首先我们需要：</p>
<h3 id="确定功能的流程"><a href="#确定功能的流程" class="headerlink" title="确定功能的流程"></a>确定功能的流程</h3><p> <img src="http://oboehz2ag.bkt.clouddn.com/%E5%8A%9F%E8%83%BD%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B.gif" alt="功能流程示例"></p>
<p>将功能的流程罗列好以后，即可按照每个流程的需求来确定需要调用的接口。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于用户体验和安全性方面的考虑，微信公众号的注册有一定门槛，某些高级接口的权限需要微信认证后才可以获取。所以，为了帮助开发者快速了解和上手微信公众号开发，熟悉各个接口的调用，需要开通测试账号。&lt;/p&gt;
&lt;p&gt;开通测试账号的路径为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;微信公众平台 &amp;gt; 开发者工具 &amp;gt; 公众平台测试帐号 &amp;gt; 进入&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或点击&lt;a href=&quot;http://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;amp;t=sandbox/index&quot;&gt;传送门&lt;/a&gt;，需要填写的为以下几项：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;URL：接口文档所在的路径，如：&lt;code&gt;https://localhost/filepath/wxapifile.php&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Token：接口文档中设定的Token&lt;/p&gt;
&lt;p&gt;域名：网址或主机名，如：&lt;code&gt;localhost&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如对以上步骤陌生的同学可以先看&lt;a href=&quot;https://tianziyao.github.io/2016/09/02/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%20-%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="微信开发" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="微信开发" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>微信开发 - 快速入门</title>
    <link href="http://yoursite.com/2016/09/02/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%20-%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2016/09/02/微信开发 - 快速入门/</id>
    <published>2016-09-01T18:24:00.000Z</published>
    <updated>2016-09-02T12:03:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>微信是一个生活方式，张小龙提出的这个愿景已经得到了越来越清晰的体现。</p>
</blockquote>
<p>群聊、语音、视频，照片/视频/位置共享，支付和商店都有了，还能通过公众账号来获取各种资源……</p>
<p>如今的微信就是在日中天的状态，公众平台带来的影响有目共睹，所以很多公司和个人都希望有自己的公众号，想充分利用却无处下手，下面我们分为几篇文章，由浅入深的了解微信开发。</p>
<p>在下面的学习中，需要你具有PHP语言的基础，并拥有一台具有PHP运行环境的主机，如果还没有可以通过新浪SAE，阿里云ECS等进行搭建。</p>
<p>下面进入正题！</p>
   <a id="more"></a>
<h2 id="接入开发者模式"><a href="#接入开发者模式" class="headerlink" title="接入开发者模式"></a>接入开发者模式</h2><p>接入开发者模式非常简单，主要分下面几个步骤：</p>
<ol>
<li>下载官方接口文件；</li>
<li>简单调整接口文件的代码；</li>
<li>将调整好的接口文件上传到服务器；</li>
<li>在开发者后台进行接口的验证；</li>
</ol>
<p>首先下载PHP接口文件，下载地址请点击<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421135319&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信公众平台开发者文档</a>。</p>
<p>将原有的代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">define(<span class="string">"TOKEN"</span>, <span class="string">"weixin"</span>);</div><div class="line">$wechatObj = <span class="keyword">new</span> wechatCallbackapiTest();</div><div class="line">$wechatObj-&gt;valid();</div></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">define(<span class="string">"TOKEN"</span>, <span class="string">"wechat"</span>);</div><div class="line"></div><div class="line">$wechatObj = <span class="keyword">new</span> wechatCallbackapiTest();</div><div class="line"></div><div class="line"><span class="keyword">if</span> ($_GET[<span class="string">"echostr"</span>]) &#123;</div><div class="line">    $wechatObj-&gt;valid();</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    $wechatObj-&gt;responseMsg();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后将修改后的PHP文件上传至你的服务器，进入：</p>
<blockquote>
<p>微信公众平台 &gt; 开发 &gt; 基本配置 &gt; 服务器配置 &gt; 修改配置</p>
</blockquote>
<p>在弹出的<strong>基本配置/ 填写服务器配置</strong>中：</p>
<blockquote>
<p>URL填写你的PHP文件地址，如：<code>https://localhost/filepath/wx_sample.php</code> ；</p>
<p>Token填写你在PHP文件中设定的值，如：<code>define(&quot;TOKEN&quot;, &quot;wechat&quot;);</code>，填写<code>wechat</code> ；</p>
<p>EncodingAESKey使用<code>随机生成</code>即可；</p>
<p>消息加解密方式选择<code>明文模式</code>即可；</p>
</blockquote>
<p>点击提交，就完成了开发者模式的接入。</p>
<h2 id="开发者模式下数据传输及处理"><a href="#开发者模式下数据传输及处理" class="headerlink" title="开发者模式下数据传输及处理"></a>开发者模式下数据传输及处理</h2><p> <img src="http://oboehz2ag.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93.gif" alt="微信开发模式数据传输"></p>
<p>了解开发者模式下的数据传输后，我们开始编写第一个程序。</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>没错，就是从它开始……</p>
<p>实现Hello World非常简单，首先编写程序代码，将PHP文件中原代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>( $keyword )) &#123;</div><div class="line">	$msgType = <span class="string">"text"</span>;</div><div class="line">	$contentStr = <span class="string">"Welcome to wechat world!"</span>;</div><div class="line">	$resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">	<span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"Input something..."</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>( $keyword )) &#123;</div><div class="line">	$msgType = <span class="string">"text"</span>;</div><div class="line">	$contentStr = $keyword.<span class="string">"World"</span>;</div><div class="line">	$resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">	<span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"Input something..."</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时，向你的公众号发送一个<code>Hello</code>，就会返回一个<code>Hello World</code>，相信大家都已经明白，<strong><code>$keyword</code>这个变量，就是用户发送的文本信息</strong>。</p>
<p>这时当用户发送语音，图片，位置等信息时，因为PHP文件对此没有进行对应的处理，所以用户设备会收到<strong>该公众号暂时无法提供服务，请稍后再试</strong>。</p>
<h2 id="被动回复消息"><a href="#被动回复消息" class="headerlink" title="被动回复消息"></a>被动回复消息</h2><p>当用户发送消息给公众号时（或某些特定的用户操作引发的事件推送时），会产生一个POST请求，开发者可以在响应包（Get）中返回特定XML结构，来对该消息进行响应（现支持回复文本、图片、图文、语音、视频、音乐）。严格来说，发送被动响应消息其实并不是一种接口，而是对微信服务器发过来消息的一次回复。</p>
<p><strong>一旦遇到以下情况，微信都会在公众号会话中，向用户下发系统提示“该公众号暂时无法提供服务，请稍后再试”：</strong></p>
<blockquote>
<p>1、开发者在5秒内未回复任何内容</p>
<p>2、开发者回复了异常数据，比如JSON数据等</p>
</blockquote>
<p>另外，请注意，回复图片等多媒体消息时需要预先通过素材管理接口上传临时素材到微信服务器，可以使用素材管理中的临时素材，也可以使用永久素材。</p>
<p>被动回复支持的消息类型有：</p>
<p><strong>文本、图片、语音、视频、音乐</strong></p>
<p>当然，还有可以包括以上所有类型的<strong>图文消息</strong>。</p>
<p>各消息类型是由XML数据包构成，关于数据包的格式请访问<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140543&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信开发者文档</a>。</p>
<h2 id="关注事件处理"><a href="#关注事件处理" class="headerlink" title="关注事件处理"></a>关注事件处理</h2><p>用户在关注与取消关注公众号时，微信会把这个事件推送到开发者填写的URL。方便开发者给用户下发欢迎消息或者做帐号的解绑。</p>
<p><strong>关注事件实际上是获取Event事件类型，并设置不同消息类型的XML数据包推送到用户设备</strong>。</p>
<p>推送XML数据包示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[FromUser]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>123456789<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[event]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Event</span>&gt;</span>&lt;![CDATA[subscribe]]&gt;<span class="tag">&lt;/<span class="name">Event</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></div></pre></td></tr></table></figure>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ToUserName</td>
<td>开发者微信号</td>
</tr>
<tr>
<td>FromUserName</td>
<td>发送方帐号（一个OpenID）</td>
</tr>
<tr>
<td>CreateTime</td>
<td>消息创建时间 （整型）</td>
</tr>
<tr>
<td>MsgType</td>
<td>消息类型，event</td>
</tr>
<tr>
<td>Event</td>
<td>事件类型，subscribe(订阅)、unsubscribe(取消订阅)</td>
</tr>
</tbody>
</table>
<h3 id="关注事件文字回复"><a href="#关注事件文字回复" class="headerlink" title="关注事件文字回复"></a>关注事件文字回复</h3><p>首先我们需要获取Event参数，并对Event进行相应的处理：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$postObj = simplexml_load_string($postStr, <span class="string">'SimpleXMLElement'</span>, LIBXML_NOCDATA);</div><div class="line">$fromUsername = $postObj-&gt;FromUserName;</div><div class="line">$toUsername = $postObj-&gt;ToUserName;</div><div class="line">$keyword = trim($postObj-&gt;Content);</div><div class="line">$event = $postObj-&gt;Event;</div><div class="line">$time = time();</div><div class="line">$textTpl = <span class="string">"&lt;xml&gt;</span></div><div class="line">			&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;</div><div class="line">			&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;</div><div class="line">			&lt;CreateTime&gt;%s&lt;/CreateTime&gt;</div><div class="line">			&lt;MsgType&gt;&lt;![CDATA[%s]]&gt;&lt;/MsgType&gt;</div><div class="line">			&lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt;</div><div class="line">			&lt;FuncFlag&gt;0&lt;/FuncFlag&gt;</div><div class="line">			&lt;/xml&gt;";</div><div class="line"></div><div class="line"><span class="keyword">if</span> ($event == <span class="string">"subscribe"</span>) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"订阅事件"</span>;</div><div class="line">    $msgType = <span class="string">"text"</span>;</div><div class="line">    $contentStr = <span class="string">"欢迎关注superliar"</span>;</div><div class="line">    $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">    <span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">elseif</span> ($event == <span class="string">"unsubscribe"</span>) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"取消订阅事件"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时我们取消关注的公众号，再重新关注它，会收到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">欢迎关注superliar</div></pre></td></tr></table></figure>
<h3 id="关注事件图文回复"><a href="#关注事件图文回复" class="headerlink" title="关注事件图文回复"></a>关注事件图文回复</h3><p>图文消息的XML包结构如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[fromUser]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>12345678<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[news]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ArticleCount</span>&gt;</span>2<span class="tag">&lt;/<span class="name">ArticleCount</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Articles</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Title</span>&gt;</span>&lt;![CDATA[title1]]&gt;<span class="tag">&lt;/<span class="name">Title</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">Description</span>&gt;</span>&lt;![CDATA[description1]]&gt;<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">PicUrl</span>&gt;</span>&lt;![CDATA[picurl]]&gt;<span class="tag">&lt;/<span class="name">PicUrl</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Url</span>&gt;</span>&lt;![CDATA[url]]&gt;<span class="tag">&lt;/<span class="name">Url</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Title</span>&gt;</span>&lt;![CDATA[title]]&gt;<span class="tag">&lt;/<span class="name">Title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Description</span>&gt;</span>&lt;![CDATA[description]]&gt;<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">PicUrl</span>&gt;</span>&lt;![CDATA[picurl]]&gt;<span class="tag">&lt;/<span class="name">PicUrl</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Url</span>&gt;</span>&lt;![CDATA[url]]&gt;<span class="tag">&lt;/<span class="name">Url</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">Articles</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></div></pre></td></tr></table></figure>
<p>参数说明如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ToUserName</td>
<td>是</td>
<td>接收方帐号（收到的OpenID）</td>
</tr>
<tr>
<td>FromUserName</td>
<td>是</td>
<td>开发者微信号</td>
</tr>
<tr>
<td>CreateTime</td>
<td>是</td>
<td>消息创建时间 （整型）</td>
</tr>
<tr>
<td>MsgType</td>
<td>是</td>
<td>news</td>
</tr>
<tr>
<td>ArticleCount</td>
<td>是</td>
<td>图文消息个数，限制为10条以内</td>
</tr>
<tr>
<td>Articles</td>
<td>是</td>
<td>多条图文消息信息，默认第一个item为大图,注意，如果图文数超过10，则将会无响应</td>
</tr>
<tr>
<td>Title</td>
<td>否</td>
<td>图文消息标题</td>
</tr>
<tr>
<td>Description</td>
<td>否</td>
<td>图文消息描述</td>
</tr>
<tr>
<td>PicUrl</td>
<td>否</td>
<td>图片链接，支持JPG、PNG格式，较好的效果为大图360<em>200，小图200</em>200</td>
</tr>
<tr>
<td>Url</td>
<td>否</td>
<td>点击图文消息跳转链接</td>
</tr>
</tbody>
</table>
<p><code>MsgTyp</code>描述的是推送消息的类型，如<code>text\image\voice\video\music\news</code>等。</p>
<p>首先定义一个图文消息类型的XML包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">$newsTpl = "<span class="tag">&lt;<span class="name">xml</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[%s]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[%s]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>%s<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[%s]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">ArticleCount</span>&gt;</span>2<span class="tag">&lt;/<span class="name">ArticleCount</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">Articles</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">item</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">Title</span>&gt;</span>&lt;![CDATA[欢迎关注superliar]]&gt;<span class="tag">&lt;/<span class="name">Title</span>&gt;</span> </div><div class="line">           <span class="tag">&lt;<span class="name">Description</span>&gt;</span>&lt;![CDATA[superliar是一个真人秀节目,balabalabalabalabalabalabalabala]]&gt;<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">PicUrl</span>&gt;</span>&lt;![CDATA[http://i2.hdslb.com/bfs/archive/e4d44a24ef5b838db63ac6c4c5fda0302102fb23.jpg]]&gt;<span class="tag">&lt;/<span class="name">PicUrl</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">Url</span>&gt;</span>&lt;![CDATA[http://www.panda.tv/]]&gt;<span class="tag">&lt;/<span class="name">Url</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">item</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">Title</span>&gt;</span>&lt;![CDATA[玩狼人杀有什么独家技巧?]]&gt;<span class="tag">&lt;/<span class="name">Title</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">Description</span>&gt;</span>&lt;![CDATA[一个玩家做了什么不重要，重要的是要知道ta为什么这么做。]]&gt;<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">PicUrl</span>&gt;</span>&lt;![CDATA[http://i0.hdslb.com/bfs/archive/b957f527aadaddc3c32287f0ff5c1858df696658.jpg]]&gt;<span class="tag">&lt;/<span class="name">PicUrl</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">Url</span>&gt;</span>&lt;![CDATA[https://www.zhihu.com/question/25833846]]&gt;<span class="tag">&lt;/<span class="name">Url</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">Articles</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">xml</span>&gt;</span>";</div></pre></td></tr></table></figure>
<p>然后将订阅的Event事件处理修改为：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ($event == <span class="string">"subscribe"</span>) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"订阅事件"</span>;</div><div class="line">    $msgType = <span class="string">"news"</span>;</div><div class="line">    $resultStr = sprintf($newsTpl, $fromUsername, $toUsername, $time, $msgType);</div><div class="line">    <span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">elseif</span> ($event == <span class="string">"unsubscribe"</span>) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"取消订阅事件"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时再重新关注，收到的就是一条图文消息了，其他类型的消息也是同样的原理。</p>
<h2 id="关键字触发事件"><a href="#关键字触发事件" class="headerlink" title="关键字触发事件"></a>关键字触发事件</h2><p>关键字触发一般用于运营活动中，即用户发送一条特定的消息，服务器返回一条特定的消息。</p>
<h3 id="返回文本消息"><a href="#返回文本消息" class="headerlink" title="返回文本消息"></a>返回文本消息</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>( $keyword )) &#123;</div><div class="line">    <span class="keyword">if</span> ($keyword == <span class="string">"text"</span>) &#123;</div><div class="line">        $msgType = <span class="string">"text"</span>;</div><div class="line">        $contentStr = <span class="string">"您发送了"</span>.$keyword;</div><div class="line">        $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">        <span class="keyword">echo</span> $resultStr;</div><div class="line">    &#125;</div><div class="line">	$msgType = <span class="string">"text"</span>;</div><div class="line">	$contentStr = <span class="string">"Hello World"</span>;</div><div class="line">	$resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">	<span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"Input something..."</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时用户输入<code>text</code>，就会收到服务器返回的<code>您发送了text</code>。用户发送其他信息，则返回<code>Hello World</code>。</p>
<h3 id="返回图文消息"><a href="#返回图文消息" class="headerlink" title="返回图文消息"></a>返回图文消息</h3><p>重新定义一个图文消息XML数据包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$newsNoImgTpl = "<span class="tag">&lt;<span class="name">xml</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[%s]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[%s]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>%s<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[%s]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">ArticleCount</span>&gt;</span>1<span class="tag">&lt;/<span class="name">ArticleCount</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">Articles</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">item</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">Title</span>&gt;</span>&lt;![CDATA[欢迎关注superliar]]&gt;<span class="tag">&lt;/<span class="name">Title</span>&gt;</span> </div><div class="line">            <span class="tag">&lt;<span class="name">Description</span>&gt;</span>&lt;![CDATA[superliar是一个真人秀节目,balabalabalabalabalabalabalabala]]&gt;<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">Url</span>&gt;</span>&lt;![CDATA[http://www.panda.tv/]]&gt;<span class="tag">&lt;/<span class="name">Url</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">Articles</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">xml</span>&gt;</span>";</div></pre></td></tr></table></figure>
<p>触发事件设置为：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>( $keyword )) &#123;</div><div class="line">    <span class="keyword">if</span> ($keyword == <span class="string">"text"</span>) &#123;</div><div class="line">        $msgType = <span class="string">"text"</span>;</div><div class="line">        $contentStr = <span class="string">"您发送了"</span>.$keyword;</div><div class="line">        $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">        <span class="keyword">echo</span> $resultStr;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ($keyword == <span class="string">"news"</span>) &#123;</div><div class="line">        $msgType = <span class="string">"news"</span>;</div><div class="line">        $resultStr = sprintf($newsNoImgTpl, $fromUsername, $toUsername, $time, $msgType);</div><div class="line">        <span class="keyword">echo</span> $resultStr;</div><div class="line">    &#125;</div><div class="line">	$msgType = <span class="string">"text"</span>;</div><div class="line">	$contentStr = <span class="string">"Hello World"</span>;</div><div class="line">	$resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">	<span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"Input something..."</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时当用户发送news时，就会收到一条无图的图文消息。</p>
<h2 id="接收不同类型消息"><a href="#接收不同类型消息" class="headerlink" title="接收不同类型消息"></a>接收不同类型消息</h2><p>如果要接收处理不同类型的消息，首先要获取用户发送的消息类型：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$msgType = $postObj-&gt;MsgType;</div></pre></td></tr></table></figure>
<p>此时可针对用户发送的不同类型的消息，进行对应的处理：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ($msgType == <span class="string">"image"</span>) &#123;</div><div class="line">    $msgType = <span class="string">"text"</span>;</div><div class="line">    $contentStr = <span class="string">"您发送了image类型的消息,服务器返回text类型消息"</span>;</div><div class="line">    $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">    <span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">elseif</span> ($msgType == <span class="string">"voice"</span>) &#123;</div><div class="line">    $msgType = <span class="string">"text"</span>;</div><div class="line">    $contentStr = <span class="string">"您发送了voice类型的消息,服务器返回text类型消息"</span>;</div><div class="line">    $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">    <span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">elseif</span> ($msgType == <span class="string">"video"</span>) &#123;</div><div class="line">    $msgType = <span class="string">"text"</span>;</div><div class="line">    $contentStr = <span class="string">"您发送了video类型的消息,服务器返回text类型消息"</span>;</div><div class="line">    $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">    <span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">elseif</span> ($msgType == <span class="string">"music"</span>) &#123;</div><div class="line">    $msgType = <span class="string">"text"</span>;</div><div class="line">    $contentStr = <span class="string">"您发送了music类型的消息,服务器返回text类型消息"</span>;</div><div class="line">    $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">    <span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Demo下载请点击这里"><a href="#Demo下载请点击这里" class="headerlink" title="Demo下载请点击这里"></a>Demo下载请<a href="https://github.com/tianziyao/demo" target="_blank" rel="external">点击这里</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;微信是一个生活方式，张小龙提出的这个愿景已经得到了越来越清晰的体现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;群聊、语音、视频，照片/视频/位置共享，支付和商店都有了，还能通过公众账号来获取各种资源……&lt;/p&gt;
&lt;p&gt;如今的微信就是在日中天的状态，公众平台带来的影响有目共睹，所以很多公司和个人都希望有自己的公众号，想充分利用却无处下手，下面我们分为几篇文章，由浅入深的了解微信开发。&lt;/p&gt;
&lt;p&gt;在下面的学习中，需要你具有PHP语言的基础，并拥有一台具有PHP运行环境的主机，如果还没有可以通过新浪SAE，阿里云ECS等进行搭建。&lt;/p&gt;
&lt;p&gt;下面进入正题！&lt;/p&gt;
    
    </summary>
    
      <category term="微信开发" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="微信开发" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>微信开发 - 公众平台简介</title>
    <link href="http://yoursite.com/2016/09/02/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%20-%20%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2016/09/02/微信开发 - 公众平台简介/</id>
    <published>2016-09-01T18:24:00.000Z</published>
    <updated>2016-09-02T11:50:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>微信开发即微信公众平台开发，将企业信息、服务、活动等内容通过微信网页的方式进行表现，用户通过简单的设置，就能生成微信3G网站。通过微信公众平台将企业品牌展示给微信用户，减少宣传成本，建立企业与消费者、客户的一对一互动和沟通，将消费者接入企业CRM系统，进行促销、推广、宣传、售后等。形成了一种主流的线上线下微信互动营销方式。</p>
<p>通过二次开发可以将公众账号由一个媒体型营销工具转化成提供服务的产品。而一旦成为用户需要的产品，公众账号的营销功能便会开启。<br>微信的核心是通讯工具，这一工具属性将用户牢牢地黏在了平台之上。用户和企业可以非常方便地在上面进行沟通，所以微信很自然地就成了企业的CRM(客户管理系统)平台来面对忠实用户，这也给了企业将服务引入平台的机会。</p>
   <a id="more"></a>
<h2 id="主要模板"><a href="#主要模板" class="headerlink" title="主要模板"></a>主要模板</h2><p>微信公众账号不会做太多深度的开放，为了把微信做得更“轻”。在2013年6月份的合作伙伴大会上，微信产品部助理曾鸣提出，微信公众账号不是一个纯粹的营销工具，让公众账号提供最体现企业价值的东西。</p>
<ul>
<li>在线营销：向终端客户推荐新品、促销策略等；</li>
<li>售后服务：通过微信平台，自动与客户进行交互，展示企业产品、售后支持；</li>
<li>电子商务：将企业网站或购物平台与微信对接，推荐到朋友圈获取免费宣传；</li>
<li>会员管理：企业会员可通过微信平台进行线下活动预约、积分管理等操作。</li>
</ul>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>公众平台是企业在OTT产品基础上新增的功能模块，基于“再小的个体也有自己品牌”这一理念。通过这一平台，个人和企业都可以打造一个公众号，并实现和特定群体的文字、图片、语音的全方位沟通、互动。同时，企业也可以利用公众平台进行CRM式管理，个人可以进行自媒体创作。</p>
<h3 id="微信官网"><a href="#微信官网" class="headerlink" title="微信官网"></a>微信官网</h3><ol>
<li>公司介绍：支持多级分类；</li>
<li>产品展示：产品支持多图显示，手指滑动浏览图片；</li>
<li>新闻资讯：对接微信公众平台消息推送；</li>
<li>联系方式：LBS地图位置标注，点击电话号码直接拨打；</li>
<li>信息推送：以微信官方规定的消息推送为标准。</li>
</ol>
<h3 id="微信客服"><a href="#微信客服" class="headerlink" title="微信客服"></a>微信客服</h3><ol>
<li>多人工客服：实现多个人工客服在线与微信公众平台客户沟通；</li>
<li>LBS位置服务：用户经过微信提供位置，公众平台自动应答离用户最近的门店、经销商；</li>
<li>建议/投诉/售后：微信平台内嵌售后服务表单。</li>
</ol>
<h3 id="微信商城"><a href="#微信商城" class="headerlink" title="微信商城"></a>微信商城</h3><ol>
<li>在线订购：支持现有商城系统进行对接；</li>
<li>会员系统：支持现有会员系统进行对接；</li>
<li>在线支付：支持在线支付功能，若无需在线支付，则只记录订单信息与流程。</li>
</ol>
<h3 id="活动与促销"><a href="#活动与促销" class="headerlink" title="活动与促销"></a>活动与促销</h3><ol>
<li>活动发布：软商系统直接对接微信平台发布；</li>
<li>抽奖刮刮卡：支持系统自定义奖品。</li>
<li>抽奖转盘：支持系统自定义奖品。</li>
</ol>
<h2 id="开放接口"><a href="#开放接口" class="headerlink" title="开放接口"></a>开放接口</h2><p>公众平台推出新的认证体系，微信将免费开放地理位置、客服、语音等九大高级技术接口 。针对服务号领域，微信还将推出一些垂直领域定制。微信产品部模式识别中心总监陈波透露，图像识别还将与微信支付结合，提供购买流程。这两个技术主要为公众平台提供服务，后续将向App开放。</p>
<ol>
<li>语音识别接口</li>
<li>客服接口</li>
<li>OAuth2.0 网页授权接口</li>
<li>生成带参数的二维码接口</li>
<li>获取用户地理位置接口</li>
<li>获取用户基本信息接口</li>
<li>获取关注者列表接口</li>
<li>用户分组接口</li>
<li>上传下载多媒体文件接口</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信开发即微信公众平台开发，将企业信息、服务、活动等内容通过微信网页的方式进行表现，用户通过简单的设置，就能生成微信3G网站。通过微信公众平台将企业品牌展示给微信用户，减少宣传成本，建立企业与消费者、客户的一对一互动和沟通，将消费者接入企业CRM系统，进行促销、推广、宣传、售后等。形成了一种主流的线上线下微信互动营销方式。&lt;/p&gt;
&lt;p&gt;通过二次开发可以将公众账号由一个媒体型营销工具转化成提供服务的产品。而一旦成为用户需要的产品，公众账号的营销功能便会开启。&lt;br&gt;微信的核心是通讯工具，这一工具属性将用户牢牢地黏在了平台之上。用户和企业可以非常方便地在上面进行沟通，所以微信很自然地就成了企业的CRM(客户管理系统)平台来面对忠实用户，这也给了企业将服务引入平台的机会。&lt;/p&gt;
    
    </summary>
    
      <category term="微信开发" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="微信开发" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS网络编程 - NSURLConnection</title>
    <link href="http://yoursite.com/2016/08/25/iOS%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%20-%20NSURLConnection/"/>
    <id>http://yoursite.com/2016/08/25/iOS网络编程 - NSURLConnection/</id>
    <published>2016-08-25T10:16:00.000Z</published>
    <updated>2016-08-25T01:54:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://pic.58pic.com/58pic/15/60/34/15Q58PICAS4_1024.png" alt=""></p>
<a id="more"></a>
<p>在iOS7后，NSURLSession基本代替了NSURLConnection进行网络开发，在iOS9后，NSURLConnection相关方法被完全的弃用，iOS系统有向下兼容的特性，尽管NSURLConnection已经被弃用，但在开发中，其方法依然可以被使用，并且如果需要兼容到很低版本的iOS系统，有时就必须使用NSURLConnection类了。</p>
<p>使用NSURLConnection用到的六个关于网络连接的类分别是：</p>
<ul>
<li>NSURLConnection：提供了初始化、开始和取消一个网络连接</li>
<li>NSURL：封装了一个网络路径</li>
<li>NSURLRequest：设置网络的请求信息</li>
<li>NSMutableURLRequest：NSURLRequest的子类，可以设置请求参数</li>
<li>NSURLResponse：接收服务器返回的信息</li>
<li>NSError：包含了网络请求中遇到的错误信息</li>
</ul>
<p>使用NSURLConnection发送请求的步骤很简单：</p>
<ol>
<li>创建一个NSURL对象，设置请求路径（设置请求路径）</li>
<li>传入NSURL创建一个NSURLRequest对象，设置请求头和请求体（创建请求对象）</li>
<li>使用NSURLConnection发送NSURLRequest（发送请求）</li>
</ol>
<p>使用NSURLConnection发送请求有两张情况，同步请求和异步请求。</p>
<h2 id="NSURLConnection-同步请求"><a href="#NSURLConnection-同步请求" class="headerlink" title="NSURLConnection 同步请求"></a>NSURLConnection 同步请求</h2><p>对于网络请求分为同步和异步两种，同步是指在请求结果返回之前，程序代码会卡在请求处，之后的代码不会被执行，异步是指在发送请求之后，一边在子线程中接收返回数据，一边执行之后的代码，当返回数据接收完毕后，采用回调的方式通知主线程做处理。</p>
<p>异步的连接将会创建一个新的线程，这个线程将会来负责下载的动作。而对于同步连接，在下载连接和处理通讯时，则会阻塞当前调用线程。许多开发者都会认为同步的连接将会堵塞主线程，其实这种观点是错误的。</p>
<p>一个同步的连接是会阻塞调用它的线程，如果你在主线程中创建一个同步连接，主线程会阻塞，但是如果你并不是从主线程开启的一个同步的连接，它将会类似异步的连接一样，因此这种情况并不会堵塞你的主线程。</p>
<p>事实上，同步和异步的主要区别就是运行 runtime 为会异步连接创建一个线程，而同步连接则不会。</p>
<p>下面是同步请求的示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> request = <span class="type">NSMutableURLRequest</span>(<span class="type">URL</span>: <span class="type">NSURL</span>(string: url!)!)</div><div class="line"></div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">let</span> data = <span class="keyword">try</span> <span class="type">NSURLConnection</span>.sendSynchronousRequest(request, returningResponse: <span class="literal">nil</span>)</div><div class="line">    <span class="built_in">print</span>(data)</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"出错了"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="NSURLConnection-异步请求"><a href="#NSURLConnection-异步请求" class="headerlink" title="NSURLConnection 异步请求"></a>NSURLConnection 异步请求</h2><p>使用同步的方式进行请求有一个很大的弊端，在进行网络请求时，数据的返回往往需要一定时间，不可能瞬间完成，使用同步的方式将很有可能会导致界面卡死，没有提示也不能交互任何用户操作，会给用户程序卡死的假象。</p>
<p>NSURLConnection类提供代理和block两种方式进行异步请求操作。</p>
<h3 id="NSURLConnection-代理"><a href="#NSURLConnection-代理" class="headerlink" title="NSURLConnection 代理"></a>NSURLConnection 代理</h3><p>首先遵守NSURLConnectionDataDelegate协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">NSURLConnectionDataDelegate</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> url: <span class="type">String</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用如下的代码进行请求：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectionWithDelegate</span><span class="params">(url: String?)</span></span> -&gt; <span class="type">NSURLConnection</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">NSURLConnection</span>(request:  <span class="type">NSMutableURLRequest</span>(<span class="type">URL</span>: <span class="type">NSURL</span>(string: url!)!), delegate: <span class="keyword">self</span>)!</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请求发出后，会一次调用如下代理方法进行请求过程的监听和数据的获取：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">connection</span><span class="params">(connection: NSURLConnection, didFailWithError error: NSError)</span></span> &#123;</div><div class="line">      <span class="built_in">print</span>(<span class="string">"连接失败，<span class="subst">\(error)</span>"</span>)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">connection</span><span class="params">(connection: NSURLConnection, didReceiveResponse response: NSURLResponse)</span></span> &#123;</div><div class="line">      <span class="built_in">print</span>(<span class="string">"收到服务器响应，<span class="subst">\(response)</span>"</span>)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">connection</span><span class="params">(connection: NSURLConnection, didReceiveData data: NSData)</span></span> &#123;</div><div class="line">data.appendData(data)</div><div class="line"><span class="built_in">print</span>(<span class="string">"正在接收数据"</span>)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">connectionDidFinishLoading</span><span class="params">(connection: NSURLConnection)</span></span> &#123;</div><div class="line">      <span class="built_in">print</span>(<span class="string">"数据传输完成，<span class="subst">\(connection)</span>"</span>)</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>其中didReceiveData有可能被多次调用，比如下载一个文件夹，文件夹中每有一个文件下载完，有可能就会调用 一次，所以这个函数有时会使用累加代码，将多次下载的数据写入到一个文件里面。</p>
<h3 id="NSURLConnection-Block"><a href="#NSURLConnection-Block" class="headerlink" title="NSURLConnection Block"></a>NSURLConnection Block</h3><p>使用如下代码进行block方式的异步请求，在block中会传入请求到的返回数据和数据信息等参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectionWithThread</span><span class="params">(url: String?)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> queue = <span class="type">NSOperationQueue</span>()</div><div class="line">    <span class="keyword">let</span> request = <span class="type">NSMutableURLRequest</span>(<span class="type">URL</span>: <span class="type">NSURL</span>(string: url!)!)</div><div class="line">    <span class="type">NSURLConnection</span>.sendAsynchronousRequest(request, queue: queue) &#123;</div><div class="line">        (resp: <span class="type">NSURLResponse</span>?, data: <span class="type">NSData</span>?, error: <span class="type">NSError</span>?) <span class="keyword">in</span></div><div class="line">        <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"出错了，<span class="subst">\(error)</span>"</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">let</span> readingOprions = <span class="type">NSJSONReadingOptions</span>.<span class="type">MutableContainers</span></div><div class="line">            <span class="keyword">let</span> dict = <span class="keyword">try</span>? <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(data!, options: readingOprions)</div><div class="line">            <span class="keyword">self</span>.imageUrl = dict?.objectForKey(<span class="string">"headimgurl"</span>) <span class="keyword">as</span>? <span class="type">String</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="NSURLConnection-网络请求设置"><a href="#NSURLConnection-网络请求设置" class="headerlink" title="NSURLConnection 网络请求设置"></a>NSURLConnection 网络请求设置</h2><p>网络请求的设置如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">setRequestMessage</span><span class="params">(url: String?)</span></span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> user = <span class="string">"username=admin&amp;password=12345&amp;department=125"</span></div><div class="line">        <span class="keyword">let</span> queue = <span class="type">NSOperationQueue</span>()</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> request = <span class="type">NSMutableURLRequest</span>(<span class="type">URL</span>: <span class="type">NSURL</span>(),</div><div class="line">                                          cachePolicy: <span class="type">NSURLRequestCachePolicy</span>.<span class="type">ReloadIgnoringLocalCacheData</span>,</div><div class="line">                                          timeoutInterval: <span class="number">60</span>) <span class="comment">//超出60秒后请求失败</span></div><div class="line">        </div><div class="line">        request.<span class="type">URL</span> = <span class="type">NSURL</span>(string: url!)!</div><div class="line">        request.<span class="type">HTTPMethod</span> = <span class="string">"POST"</span></div><div class="line">        <span class="keyword">let</span> data = user.dataUsingEncoding(<span class="type">NSUTF8StringEncoding</span>)</div><div class="line">        request.<span class="type">HTTPBody</span> = data</div><div class="line">        </div><div class="line">        <span class="type">NSURLConnection</span>.sendAsynchronousRequest(request, queue: queue) &#123;</div><div class="line">            (resp: <span class="type">NSURLResponse</span>?, data: <span class="type">NSData</span>?, error: <span class="type">NSError</span>?) <span class="keyword">in</span></div><div class="line">            <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</div><div class="line">                <span class="built_in">print</span>(<span class="string">"出错了，<span class="subst">\(error)</span>"</span>)</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">print</span>(<span class="string">"服务器返回了响应消息，<span class="subst">\(resp)</span>"</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其中的核心在于：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> request = <span class="type">NSMutableURLRequest</span>(<span class="type">URL</span>: <span class="type">NSURL</span>(),</div><div class="line">                                          cachePolicy: <span class="type">NSURLRequestCachePolicy</span>.<span class="type">ReloadIgnoringLocalCacheData</span>,</div><div class="line">                                          timeoutInterval: <span class="number">60</span>) <span class="comment">//超出60秒后请求失败</span></div></pre></td></tr></table></figure>
<p>NSURLRequestCachePolicy指定缓存逻辑。URL加载系统提供了一个磁盘和内存混合的缓存，来响应网络请求。这个缓存允许一个应用减少对网络连接的依赖，并且增加性能。</p>
<p>使用缓存的目的是为了使用的应用程序能更快速的响应用户输入，是程序高效的运行。有时候我们需要将远程web服务器获取的数据缓存起来，减少对同一个url多次请求。     </p>
<p><strong>可变请求才具有cachePolicy和timeoutInterval参数。</strong></p>
<h3 id="NSURLRequestCachePolicy-参数"><a href="#NSURLRequestCachePolicy-参数" class="headerlink" title="NSURLRequestCachePolicy 参数"></a>NSURLRequestCachePolicy 参数</h3><ul>
<li>NSURLRequestUseProtocolCachePolicy = 0：</li>
</ul>
<p>默认缓存策略。</p>
<p>如果一个NSCachedURLResponse对于请求并不存在，数据将会从源端获取；</p>
<p>如果请求拥有一个缓存的响应，那么URL加载系统会检查这个响应来决定；</p>
<p>如果它指定内容必须重新生效，将建立一个连向源端的连接来查看内容是否发生变化；</p>
<p>假如内容没有变化，那么响应就从本地缓存返回数据；</p>
<p>如果内容变化了，那么数据将从源端获取；</p>
<ul>
<li>NSURLRequestReloadIgnoringLocalCacheData = 1：</li>
</ul>
<p>URL应该加载源端数据，不使用本地缓存数据；</p>
<ul>
<li>NSURLRequestReturnCacheDataElseLoad = 2：</li>
</ul>
<p>指定已存的缓存数据应该用来响应请求，不管它的生命时长和过期时间；</p>
<p>如果在缓存中没有已存数据来响应请求的话，数据从源端加载；</p>
<ul>
<li>NSURLRequestReturnCacheDataDontLoad = 3：</li>
</ul>
<p>指定已存的缓存数据用来满足请求，不管生命时长和过期时间；</p>
<p>如果在缓存中没有已存数据来响应URL加载请求的话，不去尝试从源段加载数据， 此时认为加载请求失败；</p>
<p>这个常量指定了一个类似于离线模式的行为，常用于离线模式；</p>
<ul>
<li>NSURLRequestReloadIgnoringLocalAndRemoteCacheData =4：</li>
</ul>
<p>本地缓存数据、代理和其他中介都要忽视他们的缓存，直接加载源数据； </p>
<p>NSURLRequestReloadIgnoringCacheData和NSURLRequestReloadIgnoringLocalCacheData，两个的设置相同；</p>
<ul>
<li>NSURLRequestReloadRevalidatingCacheData = 5：</li>
</ul>
<p>指定如果已存的缓存数据被提供它的源段确认为有效则允许使用缓存数据响应请求，否则从源段加载数据； </p>
<p>只有响应http和https的请求会被缓存，ftp和文件协议当被缓存策略允许的时候尝试接入源段；</p>
<p>自定义的NSURLProtocol类能够保护缓存， 如果它们被选择使用的话；</p>
<p><code>HTTPMethod</code>和<code>HTTPBody</code>分别对应网络请求中的请求头和请求体：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">request.<span class="type">HTTPMethod</span> = <span class="string">"POST"</span></div><div class="line"><span class="keyword">let</span> data = user.dataUsingEncoding(<span class="type">NSUTF8StringEncoding</span>)</div><div class="line">request.<span class="type">HTTPBody</span> = data</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://pic.58pic.com/58pic/15/60/34/15Q58PICAS4_1024.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS网络编程" scheme="http://yoursite.com/tags/iOS%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Mac开发工具 -  SHH登录</title>
    <link href="http://yoursite.com/2016/08/24/Mac%E6%8A%80%E5%B7%A7%20-%20%20SHH%E7%99%BB%E5%BD%95/"/>
    <id>http://yoursite.com/2016/08/24/Mac技巧 -  SHH登录/</id>
    <published>2016-08-24T10:16:00.000Z</published>
    <updated>2016-08-24T04:40:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mac Terminal是自带SSH的，通过终端SSH远程连接Centos服务器非常方便，在端口为默认的22情况下，只需要在终端下输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -l root hostNameOrAddress</div></pre></td></tr></table></figure>
<p>就可以连接了，如果改变了端口，使用如下命令即可登录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -p portNumber -l root hostNameOrAddress</div></pre></td></tr></table></figure>
<p>如果是Ubuntu主机，也可以这个命令进行连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssh -X userName@hostNameOrAddress</div><div class="line">ssh userName@hostNameOrAddress -p portNumber</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>例如：<code>ssh ubuntu@192.168.100.100</code>。</p>
<p>其中ubuntu是要登录的主机的用户名，192.168.100.100是要登录的主机的IP地址。</p>
<h2 id="错误排除"><a href="#错误排除" class="headerlink" title="错误排除"></a>错误排除</h2><p>如果SSH无法连接，可以先用whereis来看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ whereis ssh</div></pre></td></tr></table></figure>
<p>以下表示现有进程中找不到ssh对应的进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ps aux | grep ssh</div><div class="line">apple           25927   0.0  0.0  2432784    616 s000  R+    3:14下午   0:00.00 grep ssh</div></pre></td></tr></table></figure>
<p>直接用SSH命令连接本地主机或远程主机时会遇到下列错误提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh: connect to host localhost port 22: Connection refused</div></pre></td></tr></table></figure>
<p>在于系统设置中没有打开远程登录，参见<a href="http://stackoverflow.com/questions/6313929/how-do-i-open-port-22-in-osx-10-6-7" target="_blank" rel="external">传送门</a>。</p>
<p>输入<code>ssh localhost</code>来测试一下，如果提示输入密码来认证就没问题了。</p>
<p>此时再grep一下进程可以看到SSH进程在运行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ps aux | grep ssh</div><div class="line">apple            4656   0.0  0.0  2525056   1540   ??  S    三02下午   0:00.19 /usr/bin/ssh-agent -l</div><div class="line">apple           26009   0.0  0.0  2432784    612 s000  R+    3:19下午   0:00.00 grep ssh</div></pre></td></tr></table></figure>
<p>如果提示以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Host key verification failed. ssh</div><div class="line">Host key verification failed.</div></pre></td></tr></table></figure>
<p>尝试以下的解决方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi ~/.ssh/known_hosts</div></pre></td></tr></table></figure>
<p>删除此目录下hostNameOrAddress的相关rsa的信息，或者直接删除这个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd ~/.ssh/</div><div class="line"></div><div class="line">rm known_hosts</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mac Terminal是自带SSH的，通过终端SSH远程连接Centos服务器非常方便，在端口为默认的22情况下，只需要在终端下输入：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ssh -l root hostNameOrAddress&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就可以连接了，如果改变了端口，使用如下命令即可登录：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ssh -p portNumber -l root hostNameOrAddress&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果是Ubuntu主机，也可以这个命令进行连接：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ssh -X userName@hostNameOrAddress&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ssh userName@hostNameOrAddress -p portNumber&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Other" scheme="http://yoursite.com/categories/Other/"/>
    
    
      <category term="SHH" scheme="http://yoursite.com/tags/SHH/"/>
    
      <category term="开发工具" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>iOS生命周期 - Main函数</title>
    <link href="http://yoursite.com/2016/08/24/iOS%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%20-%20Main%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2016/08/24/iOS生命周期 - Main函数/</id>
    <published>2016-08-24T10:16:00.000Z</published>
    <updated>2016-08-24T05:03:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>所有基于C编写的app的<strong>入口</strong>都是main函数，但iOS应用程序有点不同。不同就是你不需要为iOS应用程序而自己编写main函数，当你使用Xcode创建工程的时候就已经提供了。除非一些特殊情况，否则你<strong>不应该</strong>修改Xcode提供的main函数实现，在下图中我们可以看到Xcode为我们生成了一个main.m文件：</p>
<p> <img src="http://oboehz2ag.bkt.clouddn.com/ocmain.m.png" alt="ocmain.m"></p>
<a id="more"></a>
<h2 id="UIApplicationMain"><a href="#UIApplicationMain" class="headerlink" title="UIApplicationMain"></a>UIApplicationMain</h2><p>截图中默认的iOS程序就是从main函数开始执行的，但是在main函数中我们其实只能看到一个方法，这个方法内部是一个消息循环（相当于一个死循 环），因此运行到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]))</div></pre></td></tr></table></figure>
<p>UIApplicationMain这个方法之后程序不会自动退出，而只有当用户手动关闭程序这个循环才结束。这个方法有四个参数：</p>
<ul>
<li>第一个参数和第二个参数其实就是main函数的参数，分别代表：参数个数、参数内容；</li>
<li>第三个参数代表UIApplication类（或子类）字符串，这个参数默认为nil则代表默认为UIApplication类，用户 可以自定义一个类继承于这个类；如果为nil则等价于NSStringFromClass([UIApplication class])，大家可以自己试验，效果完全一样；UIApplication是单例模式，一个应用程序只有一个UIApplication对象或子对 象；</li>
<li>第四个参数是UIApplication的代理类字符串，默认生成的是AppDelegate类，这个类主要用于监听整个应用程序生命 周期的各个事件，当UIApplication运行过程中引发了某个事件之后会调用代理中对应的方法；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>main</code>函数的两个参数<code>(int argc, char *argv[])</code>，iOS中没有用到，包括这两个参数是为了与标准ANSI C保持一致。</p>
<p><code>UIApplicationMain</code>函数，前两个参数和<code>main</code>函数一样，重点是后两个，官方说明是这样的：</p>
<blockquote>
<p>// If nil is specified for principalClassName, the value for NSPrincipalClass from the Info.plist is used. If there is no<br>// NSPrincipalClass key specified, the UIApplication class is used. The delegate class will be instantiated using init.<br>UIKIT_EXTERN int UIApplicationMain(int argc, char <em>argv[], NSString </em>principalClassName, NSString *delegateClassName);</p>
</blockquote>
<p>后两个参数分别表示程序的主要类（principal class）和代理类（delegate class）。如果主要类为nil，将从Info.plist中获取，如果Info.plist中不存在对应的key，则默认为UIApplication；如果代理类为nil，将在新建工程时创建。</p>
<p>根据UIApplicationMain函数，程序将进入AppDelegate.m，这个文件是Xcode新建工程时自动生成的。</p>
<p>上面实例代码中有一个很重要的函数<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKitFunctionReference/index.html#//apple_ref/c/func/UIApplicationMain" target="_blank" rel="external">UIApplicationMain</a>，它主要是创建app的几个核心对象来处理以下过程：</p>
<ol>
<li>从可用<code>Storyboard</code>文件加载用户界面</li>
<li>调用<code>AppDelegate</code>自定义代码来做一些初始化设置</li>
<li>将app放入<code>Main Run Loop</code>环境中来响应和处理与用户交互产生的事件</li>
</ol>
<h3 id="Swift中的Main函数"><a href="#Swift中的Main函数" class="headerlink" title="Swift中的Main函数"></a>Swift中的Main函数</h3><p>用OC语言创建的项目，一定会有一个main.m文件，里面有一个main函数，在这个函数中唤醒app。如果在app启动时放置断点，可以看到应用程序调用栈，main函数作为程序启动后的第二个函数被调用，然后在main函数中再启动UIApplication，并绑定AppDelegate。如下图：</p>
<p> <img src="http://oboehz2ag.bkt.clouddn.com/ocmain.png" alt="ocmain"></p>
<p>但是Swift项目中没有一个名为main.swift的文件，为什么app的入口没有了？官方文档的说法是这样的：</p>
<blockquote>
<p>In Xcode, Mac templates default to including a “main.swift” file, but for iOS apps the default for new iOS project templates is to add @UIApplicationMain to a regular Swift file. This causes the compiler to synthesize a mainentry point for your iOS app, and eliminates the need for a “main.swift” file.</p>
</blockquote>
<p>这段话的意思是，Swift项目中添加了@UIApplicationMain 到swift文件中，使得编译器合成了一个app入口，所以不需要main.swift文件。</p>
<p> <img src="http://oboehz2ag.bkt.clouddn.com/swiftmain.png" alt="swiftmain"></p>
<p>可能苹果认为我们并不需要自行配置app入口，所以干脆简化了项目配置，使用更加简单的方式启动应用，但有时候我们可能需要自己配置入口，例如我们要创建一个UIApplication的子类时。</p>
<h2 id="自定义UIApplicationMain"><a href="#自定义UIApplicationMain" class="headerlink" title="自定义UIApplicationMain"></a>自定义UIApplicationMain</h2><p>如果你希望通过自行配置入口的方式来创建一个UIApplication子类，首先定义一个UIApplication的子类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Foundation</div><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span>: <span class="title">UIApplication</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">sendEvent</span><span class="params">(event: UIEvent)</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.sendEvent(event)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"send event"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后新建main.swift文件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Foundation</div><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="type">UIApplicationMain</span>(<span class="type">Process</span>.argc, <span class="type">Process</span>.unsafeArgv, <span class="type">NSStringFromClass</span>(myApplication), <span class="type">NSStringFromClass</span>(<span class="type">AppDelegate</span>))</div></pre></td></tr></table></figure>
<p>在Appdelegate的最顶部声明@UIApplicationMain，表示该类是application的delegate。</p>
<p>如果不用该属性标识，另外一种做法是在main.swift中调用UIApplicationMain函数，设置delegate和application。以上我们就是根据这种方法来设置的。</p>
<p>去掉Appdelegate的@UIApplicationMain，我们就将main.swift设置为了入口。</p>
<h2 id="UIApplicationMain的参数"><a href="#UIApplicationMain的参数" class="headerlink" title="UIApplicationMain的参数"></a>UIApplicationMain的参数</h2><p>以前OC的main函数的argv参数是一个字符串指针，打印出来后是应用程序的路径。</p>
<p>Swift中main函数的 Process.unsafeArgv 参数变成了一串十六进制数字，应该也是代表应用程序地址。</p>
<h2 id="Demo下载"><a href="#Demo下载" class="headerlink" title="Demo下载"></a>Demo下载</h2><p><a href="https://github.com/tianziyao/demo/tree/master/CustomApplication" target="_blank" rel="external">GitHub传送门</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所有基于C编写的app的&lt;strong&gt;入口&lt;/strong&gt;都是main函数，但iOS应用程序有点不同。不同就是你不需要为iOS应用程序而自己编写main函数，当你使用Xcode创建工程的时候就已经提供了。除非一些特殊情况，否则你&lt;strong&gt;不应该&lt;/strong&gt;修改Xcode提供的main函数实现，在下图中我们可以看到Xcode为我们生成了一个main.m文件：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://oboehz2ag.bkt.clouddn.com/ocmain.m.png&quot; alt=&quot;ocmain.m&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS生命周期" scheme="http://yoursite.com/tags/iOS%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
</feed>
