<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iSTian&#39;notes</title>
  <subtitle>Quick notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-07-08T11:54:05.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>iSTian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS事件 - 响应者链和事件分发</title>
    <link href="http://yoursite.com/2017/04/08/iOS%E4%BA%8B%E4%BB%B6%20-%20%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    <id>http://yoursite.com/2017/04/08/iOS事件 - 响应者链和事件分发/</id>
    <published>2017-04-07T18:24:00.000Z</published>
    <updated>2017-07-08T11:54:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>响应者对象就是可以响应事件并对事件作出处理。在 iOS 中，存在 <code>UIResponder</code> 类，它定义了响应者对象的所有方法。<code>UIApplication</code>、<code>UIView</code> 等类都继承了 <code>UIResponder</code> 类，<code>UIWindow</code> 和 <code>UIKit</code> 中的控件因为继承了 <code>UIView</code>，所以也间接继承了 <code>UIResponder</code> 类，这些类的实例都可以当作响应者。</p>
<p>当前接受触摸的响应者对象被称为第一响应者，即表示当前该对象正在与用户交互，它是响应者链的开端。</p>
<p>响应者链表示一系列的响应者对象。事件被交由第一响应者对象处理，如果第一响应者不处理，事件被沿着响应者链向上传递，交给下一个响应者。</p>
<p>一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象(如果存在)，然后是它的父视图对象(如果存在)，以此类推，直到顶层视图。</p>
<p>接下来会沿着顶层视图(<code>top view</code>)到窗口(<code>UIWindow</code>)再到程序(<code>UIApplication</code>)。如果整个过程都没有响应这个事件，该事件就被丢弃。</p>
<p>一般情况下，在响应者链中只要由对象处理事件，事件就停止传递。但有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。</p>
<a id="more"></a>
<h2 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h2><p>视图对触摸事件是否需要作处回应可以通过设置视图的 <code>userInteractionEnabled</code> 属性。默认状态为 YES，如果设置为 NO，可以阻止视图接收和分发触摸事件。除此之外，当视图被隐藏或者透明也不会接收事件。</p>
<p>不过这个属性只对视图有效，如果想要整个程序都不响应事件，可以调用 <code>UIApplication</code> 的 <code>beginIngnoringInteractionEvents</code> 方法来完全停止事件接收和分发。通过 <code>endIngnoringInteractionEvents</code> 方法来恢复让程序接收和分发事件。</p>
<p>如果要让视图接收多点触摸，需要设置它的 <code>multipleTouchEnabled</code> 属性为 YES，默认状态下这个属性值为NO，即视图默认不接收多点触摸，整个 iOS 触摸事件从产生到寂灭大致如下图：</p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/uitouchflow.png" alt="img"></p>
<h3 id="起始阶段"><a href="#起始阶段" class="headerlink" title="起始阶段"></a>起始阶段</h3><ol>
<li>CPU 处于睡眠状态，等待事件发生；</li>
<li>手指触摸屏幕</li>
</ol>
<h3 id="系统响应阶段"><a href="#系统响应阶段" class="headerlink" title="系统响应阶段"></a>系统响应阶段</h3><ol>
<li>屏幕硬件感应到输入，并将感应到的事件传递给输入输出驱动 <code>IOKit</code>；</li>
<li><code>IOKit.framework</code> 封装整个触摸事件为 <code>IOHIDEvent</code> 对象；</li>
<li><code>IOKit.framework</code> 通过 IPC 将事件转发给 <code>SpringBoard.app</code>；</li>
</ol>
<blockquote>
<p><code>SpringBoard.app</code> 就是 iOS 的系统桌面，当触摸事件发生时，也只有负责管理桌面的 <code>SpringBoard.app</code> 才知道如何正确的响应。因为触摸发生时，有可能用户正在桌面翻页找 App，也有可能正处于在微信中刷朋友圈。</p>
</blockquote>
<p>以上是系统层的响应，系统感应到外界的输入，并将相应的输入封装成比较概括的 <a href="http://iphonedevwiki.net/index.php/IOHIDFamily" target="_blank" rel="external"><code>IOHIDEvent</code></a> 对象，然后 <code>UIKit</code> 通过 <code>IOHIDEvent</code> 的类型，判断出相应事件应该由 <a href="http://iphonedevwiki.net/index.php/`SpringBoard.app`" target="_blank" rel="external"><code>SpringBoard .app</code></a> 处理，直接通过 <code>Mach Port(IPC进程间通信)</code> 转发给 <code>SpringBoard.app</code>。</p>
<h3 id="桌面响应阶段"><a href="#桌面响应阶段" class="headerlink" title="桌面响应阶段"></a>桌面响应阶段</h3><p><code>SpringBoard.app</code> 主线程 <code>Runloop</code> 收到 <a href="https://developer.apple.com/reference/`IOKit`" target="_blank" rel="external"><code>IOKit.framework</code></a> 转发来的消息苏醒，并触发对应 <code>Mach Port</code> 的 <code>Source1</code> 回调 <code>__IOHIDEventSystemClientQueueCallback()</code>。</p>
<p>如果 <code>SpringBoard.app</code> 监测到有 App 在前台，即 xxxx.app，<code>SpringBoard.app</code> 通过 <code>Mach Port(IPC进程间通信)</code> 转发给 xxxx.app，如果 <code>SpringBoard.app</code> 监测到监测无前台 App，则 <code>SpringBoard.app</code> 进入 App 内部响应阶段的第二段，即触发 <code>Source0</code> 回调。</p>
<h4 id="Source1-事件响应"><a href="#Source1-事件响应" class="headerlink" title="Source1 事件响应"></a>Source1 事件响应</h4><p>苹果注册了一个 <code>Source1</code> 用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()</code>。</p>
<p>当一个硬件事件，如触摸/锁屏/摇晃等发生后，首先由 <code>IOKit.framework</code> 生成一个 <code>IOHIDEvent</code> 事件并由 <code>SpringBoard</code> 接收。<code>SpringBoard</code> 只接收按键(锁屏/静音等)，触摸，加速，距离传感器等几种 Event，随后用 <code>Mach Port</code> 转发给需要的 App 进程。随后苹果注册的那个 <code>Source1</code> 就会触发回调，并调用 <code>_UIApplicationHandleEventQueue()</code> 进行应用内部的分发。</p>
<p><code>_UIApplicationHandleEventQueue()</code> 会把 <code>IOHIDEvent</code> 处理并包装成 <code>UIEvent</code> 进行处理或分发，其中包括识别 UIGesture，处理屏幕旋转，发送给 <code>UIWindow</code> 等。通常事件比如 <code>UIButton</code> 点击、<code>touchesBegin/Move/End/Cancel</code> 事件都是在这个回调中完成的。</p>
<h4 id="Source0-手势识别"><a href="#Source0-手势识别" class="headerlink" title="Source0 手势识别"></a>Source0 手势识别</h4><p>当上面的 <code>_UIApplicationHandleEventQueue()</code> 识别了一个手势时，其首先会调用 <code>Cancel</code> 将当前的 <code>touchesBegin/Move/End</code> 系列回调打断。随后系统将对应的 <code>UIGestureRecognizer</code> 标记为待处理。</p>
<p>苹果注册了一个 <code>Observer</code> 监测 <code>BeforeWaiting (Loop即将进入休眠)</code> 事件，这个 <code>Observer</code> 的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的 <code>GestureRecognizer</code>，并执行 <code>GestureRecognizer</code> 的回调。</p>
<p>当有 <code>UIGestureRecognizer</code> 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h3 id="App内部响应阶段"><a href="#App内部响应阶段" class="headerlink" title="App内部响应阶段"></a>App内部响应阶段</h3><ol>
<li>前台 App 主线程 <code>Runloop</code> 收到 <code>SpringBoard.app</code> 转发来的消息苏醒，并触发对应 <code>Mach Port</code> 的 <code>Source1</code> 回调 <code>__IOHIDEventSystemClientQueueCallback()</code> ；</li>
<li><code>Source1</code> 回调内部触发 <code>Source0</code> 回调 <code>__UIApplicationHandleEventQueue()</code> ；</li>
<li><code>Soucre0</code> 回调内部，封装 <code>IOHIDEvent</code> 为 <code>UIEvent</code> ；</li>
<li>平时开发熟悉的触摸事件响应链从这开始了；</li>
<li>通过递归调用<code>UIView</code>层级的 <code>hitTest(_:with:)</code> ，结合 <code>point(inside:with:)</code> 找到 <code>UIEvent</code> 中每一个 <code>UITouch</code> 所属的 <code>UIView</code>，其实是想找到离触摸事件点最近的那个<code>UIView</code>。</li>
<li>这个过程是从 <code>UIView</code> 层级的最顶层往最底层递归查询，但这不是 <code>UIResponder</code> 响应链，事件响应是在 <code>UIEvent</code> 中每一个 <code>UITouch</code> 所属的 <code>UIView</code> 都确定之后方才开始。</li>
</ol>
<p>但需要注意，以下三种情况 <code>UIView</code> 的 <code>hitTest(_:with:)</code> 不会被调用，也导致其子 <code>UIView</code> 的 <code>hitTest(_:with:)</code> 不会被调用，而之后响应事件是下向上传递的，这直接导致以下三种情况的 <code>UIView</code> 及其子 <code>UIView</code> 不接收任何触摸事件：</p>
<ol>
<li>userInteractionEnabled = NO</li>
<li>hidden = YES</li>
<li>alpha = 0.0~0.01之间</li>
</ol>
<blockquote>
<p>UIImageView 的 userInteractionEnabled 默认为NO，因此 UIImageView 以及它的子控件默认是不接收触摸事件的。</p>
</blockquote>
<p>当把断点打在某个 <code>UIView</code> <code>hitTest(_:with:)</code> 中时，对应的调用堆栈如下：<br><img src="http://oboehz2ag.bkt.clouddn.com/calltraceoftouching.png" alt="img"></p>
<ol>
<li><p>根据围绕 <code>UITouch</code> 所属的 <code>UIView</code> 及其父视图 <code>UIView</code> 的 <code>UIGestureRecognizer</code>，来确定一个 <code>UITouch</code> 的 <code>UIGestureRecognizer</code>；</p>
</li>
<li><p><code>UITouch</code> 所属的 <code>UIView</code> 和 <code>gestureRecognizers</code> 收到此 <code>UITouch</code> 和相应的 <code>UIEvent</code>，并按照 <code>UITouch</code> 所处的状态调用四大 <code>UITouch</code> 方法中的一个，事件响应开始；</p>
</li>
<li><p>对于 <code>UIView</code> 收到的 <code>UITouch</code> 事件，四大 <code>UITouch</code> 事件都是如此，则会按照 <code>UIResponder</code> 响应链一直往上传递，直到某个 <code>UIResponder</code> 因为主动响应触摸事件，切断了响应链，即不调用下一个 <code>UIResponder</code> 的响应方法，如果一直没有 <code>UIResponder</code> 做响应处理，则这些 <code>UITouch</code> 到达最后的响应者即 <code>UIApplication</code> 后，就被吃掉消失。</p>
</li>
<li><p>如果在事件响应过程中，有 <code>UIGestureRecognizer</code> 成功识别，则此 <code>UIGestureRecognizer</code> 将独自占有所需要的 <code>UITouch</code>，这些 <code>UITouch</code> 所属的 <code>UIView</code> 及其他的 <code>UIGestureRecognizer</code> 的 <code>touchesCancelled(_:with:)</code> 方法将调用。</p>
<p>如果在手势的代理中设置可以同时识别两个手势，则允许同时识别的手势均可以收到所需要的 <code>UITouch</code>事件，但与识别成功的 <code>UIGestureRecognizer</code> 无关的 <code>UITouch</code> 则会继续按照上述传递逻辑传递。也即允许两个手势同时识别，只要所占有的 <code>UITouch</code> 不相同。</p>
</li>
<li><p>如果 <code>UIGestureRecognizer</code> 识别成功，则调用相应的 action，处理对应的逻辑。如果某个 <code>UIResponder</code> 主动响应了触摸事件，则根据其本身的响应逻辑处理对应的业务，<code>UIControl</code> 都是主动响应并切断 <code>UITouch</code> 的向上传递的。</p>
</li>
<li><p><code>UITouch</code> 事件流动完毕，整个系统重新进入睡眠等待下一个事件。</p>
</li>
</ol>
<h2 id="响应者链"><a href="#响应者链" class="headerlink" title="响应者链"></a>响应者链</h2><p>通常，一个 iOS 应用中，在一块屏幕上通常有很多的 UI 控件，也就是有很多的 View，那么当一个事件发生时，如何来确定是哪个 View 响应了这个事件呢，接下来我们就一起来看看。</p>
<h3 id="寻找hit-test-view"><a href="#寻找hit-test-view" class="headerlink" title="寻找hit-test view"></a>寻找<code>hit-test view</code></h3><p>什么是 <code>hit-test view</code> 呢？简单来说就是你触发事件所在的那个 View，寻找 <code>hit-test view</code> 的过程就叫做 <code>Hit-Testing</code>。</p>
<p>发生触摸事件后，系统会将该事件加入到一个由 <code>UIApplication</code> 管理的事件队列中，为什么是队列而不是栈呢？因为队列是先进先出，触摸的处理也是顺序执行的。</p>
<p><code>UIApplication</code> 会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口 <code>keyWindow</code>，主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。找到合适的视图控件后，就会调用视图控件的 <code>touches</code> 方法来作具体的事件处理：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">touchesBegan…</div><div class="line">touchesMoved…</div><div class="line">touchedEnded…</div></pre></td></tr></table></figure>
<p>那么响应链是如何找到最合适的控件来处理事件的呢？</p>
<ol>
<li>自己是否能接收触摸事件；</li>
<li>触摸点是否在自己身上；</li>
<li>从后往前遍历子控件数组，重复前面的两个步骤；</li>
<li>如果没有符合条件的子控件，那么就自己最适合处理；</li>
</ol>
<p>下面是 <code>hitTest</code> 实现的伪代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//调用时机：只要时间传递到此控件，就会执行 hitTest 方法</span></div><div class="line"><span class="comment">//作用:  寻找最合适的 view 给你</span></div><div class="line"><span class="comment">//UIApplication -&gt; [UIWindow hitTest:withEvent:] 寻找最合适的view告诉系统</span></div><div class="line"><span class="comment">//point:当前手指触摸的点</span></div><div class="line"><span class="comment">//point:是方法调用者坐标系上的点</span></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">hitTest</span><span class="params">(<span class="number">_</span> point: CGPoint, with event: `UIEvent`?)</span></span> -&gt; `<span class="type">UIView</span>`? &#123;</div><div class="line">    <span class="comment">//1.保证开启交互，如未开启，没有合适的控件</span></div><div class="line">    <span class="keyword">guard</span> isUserInteractionEnabled == <span class="literal">true</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//2.保证未隐藏，如隐藏，没有合适的控件</span></div><div class="line">    <span class="keyword">guard</span> isHidden == <span class="literal">false</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//3.保证透明度大于 0.01，如 &lt;= 0.01，没有合适的控件</span></div><div class="line">    <span class="keyword">guard</span> alpha &gt; <span class="number">0.01</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//4.保证触摸点在自己的视图内，如不在，没有合适的控件</span></div><div class="line">    <span class="keyword">guard</span> <span class="keyword">self</span>.point(inside: point, with: event) == <span class="literal">true</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//5.便利控件下的子控件，如有更合适的子控件，返回</span></div><div class="line">    <span class="keyword">for</span> subView <span class="keyword">in</span> <span class="keyword">self</span>.subviews &#123;</div><div class="line">        <span class="keyword">let</span> subPoint = <span class="keyword">self</span>.convert(point, to: subView)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> fitView = subView.hitTest(subPoint, with: event) &#123;</div><div class="line">            <span class="keyword">return</span> fitView</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//6. 如没有更合适的子控件，返回自身</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在查找最合适的 View 的过程中用到了两个最重要的方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="type">UIView</span> *)hitTest:(<span class="type">CGPoint</span>)point withEvent:(<span class="type">UIEvent</span> *)event</div><div class="line">- (<span class="type">BOOL</span>)pointInside:(<span class="type">CGPoint</span>)point withEvent:(<span class="type">UIEvent</span> *)event;</div></pre></td></tr></table></figure>
<h3 id="hitTest-withEvent"><a href="#hitTest-withEvent" class="headerlink" title="hitTest:withEvent:"></a>hitTest:withEvent:</h3><p>只要事件一传递给一个控件，这个控件就会调用自己的 <code>hitTest:withEvent:</code> 方法，用于寻找并返回最合适的 View， <strong>它不管这个控件能不能处理事件也不管点是否在 View 上，事件都会先传给这 View 再调用这个 View 的 <code>hitTest:withEvent:</code> 方法。不管点击哪里，最合适的 View 都是 hitTest 返回的那个 View。</strong></p>
<p>利用这个特性可以拦截事件的处理：</p>
<blockquote>
<p>事件传递给谁就会调用这个 View 的 <code>hitTest:withEvent:</code> 方法，如果返回 <code>nil</code>，那么该方法的控件本身和子控件不是最合适的 View，那么最合适的 View 就是该控件的父控件。</p>
</blockquote>
<p>如果想让 A 成为最合适的 View 就重写 A 的父控件 B 的 <code>hitTest:withEvent:</code> 方法，或者自己的 <code>hitTest:withEvent:</code> 方法返回 <code>self</code>，建议采用第一种。</p>
<h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><ul>
<li><p>谁都不能处理事件，窗口也不能处理。</p>
<blockquote>
<p>重写 window 的 <code>hitTest：withEvent：</code> 方法返回 <code>nil</code> </p>
</blockquote>
</li>
<li><p>只能由窗口处理事件。</p>
<blockquote>
<p>控制器的 view 的 <code>hitTest：withEvent：</code> 方法返回 <code>nil</code></p>
<p>或者 window 的 <code>hitTest：withEvent：</code> 方法返回 <code>self</code></p>
</blockquote>
</li>
<li><p>返回 <code>nil</code> 的含义：</p>
<blockquote>
<p>调用当前 <code>hitTest：withEvent：</code> 方法 <code>return nil</code> 的意思是 View 不是合适的 View，子控件也不是合适的 View。如果同级的兄弟控件也没有合适的 View，那么最合适的 View 就是父控件。</p>
</blockquote>
</li>
</ul>
<h3 id="pointInside-withEvent"><a href="#pointInside-withEvent" class="headerlink" title="pointInside:withEvent"></a>pointInside:withEvent</h3><p><code>pointInside:withEvent:</code> 方法判断点在不在当前 View 上(方法调用者的坐标系上)如果返回 YES，代表点在方法调用者的坐标系上；</p>
<p>返回 NO 代表点不在方法调用者的坐标系上，那么方法调用者也就不能处理事件。我们可以重写这个方法，主动拦截事件的传递：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//作用:判断下传入过来的点在不在方法调用者的坐标系上</span></div><div class="line"><span class="comment">// point:是方法调用者坐标系上的点</span></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">point</span><span class="params">(inside point: CGPoint, with event: `UIEvent`?)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="响应者对象-Responsder-Object"><a href="#响应者对象-Responsder-Object" class="headerlink" title="响应者对象(Responsder Object)"></a>响应者对象(Responsder Object)</h3><p>响应者对象是能够响应并且处理事件的对象，<code>UIResponder</code> 是所有响应者对象的父类，包括 <code>UIApplication</code>、<code>UIView</code> 和 <code>UIViewController</code> 都是 <code>UIResponder</code> 的子类。也就意味着所有的 View 和 <code>ViewController</code> 都是响应者对象。</p>
<h3 id="第一响应者-First-Responder"><a href="#第一响应者-First-Responder" class="headerlink" title="第一响应者(First Responder)"></a>第一响应者(First Responder)</h3><p>第一响应者是第一个接收事件的 View 对象，我们在 Xcode 的 Interface Builder 画视图时，可以看到视图结构中就有 First Responder。</p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/firstresponder.png" alt="img"></p>
<p>这里的 First Responder 就是 <code>UIApplication</code> 了。另外，我们可以控制一个 View 让其成为 First Responder，通过实现 <code>canBecomeFirstResponder</code> 方法并返回 YES 可以使当前 View 成为第一响应者，或者调用 View 的 <code>becomeFirstResponder</code> 方法也可以，例如当 <code>UITextField</code> 调用该方法时会弹出键盘进行输入，此时输入框控件就是第一响应者。</p>
<h3 id="事件传递机制"><a href="#事件传递机制" class="headerlink" title="事件传递机制"></a>事件传递机制</h3><p>如上所说，如果 <code>hit-test view</code> 不能处理当前事件，那么事件将会沿着响应者链(Responder Chain)进行传递，直到遇到能处理该事件的响应者(Responsder Object)。通过下图，我们来看看两种不同情况下得事件传递机制。</p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/responderchain.png" alt="img"></p>
<p>左边的情况，接收事件的 <code>initial view</code> 如果不能处理该事件并且她不是顶层的 View，则事件会往它的父 View 进行传递。<code>initial view</code> 的父 View 获取事件后如果仍不能处理，则继续往上传递，循环这个过程。如果顶层的 View 还是不能处理这个事件的话，则会将事件传递给它们的 <code>ViewController</code>，如果 <code>ViewController</code> 也不能处理，则传递给 <code>UIWindow</code>，此时 <code>Window</code> 不能处理的话就将事件传递给 <code>UIApplication</code>，最后如果连 <code>Application</code> 也不能处理，则废弃该事件。</p>
<p>右边图的流程唯一不同就在于，如果当前的 <code>ViewController</code> 是有层级关系的，那么当子 <code>ViewController</code> 不能处理事件时，它会将事件继续往上传递，直到传递到其 <code>Root ViewController</code>，后面的流程就跟之前分析的一样了。</p>
<p>这就是事件响应者链的传递机制，通过这些内容，我们可以更深入的了解事件在 iOS 中得传递机制，对我们在实际开发中更好的理解事件操作的原理有很大的帮助，也对我们实现复杂布局进行事件处理时增添了多一份的理解。</p>
<h3 id="事件传递的完整过程"><a href="#事件传递的完整过程" class="headerlink" title="事件传递的完整过程"></a>事件传递的完整过程</h3><ol>
<li>先将事件对象由上往下传递(由父控件传递给子控件)，找到最合适的控件来处理这个事件；</li>
<li>调用最合适控件的 <code>touches…</code> 方法；</li>
<li>如果调用了 <code>super touches…</code> 就会将事件顺着响应者链条往上传递，传递给上一个响应者；</li>
<li>接着就会调用上一个响应者的 <code>touches….</code> 方法；</li>
</ol>
<h3 id="判断上一个响应者"><a href="#判断上一个响应者" class="headerlink" title="判断上一个响应者"></a>判断上一个响应者</h3><ol>
<li>如果当前这个 View 是控制器的 View，那么控制器就是上一个响应者；</li>
<li>如果当前这个 View 不是控制器的 View，那么父控件就是上一个响应者；</li>
</ol>
<h2 id="UIResponder"><a href="#UIResponder" class="headerlink" title="UIResponder"></a>UIResponder</h2><p>如果你观察一下 <code>UIView</code> 的子类，可以发现 3 个基类: <code>reponders</code> (响应者)，<code>views</code> (视图)和 <code>controls</code> (控件)。我们快速重温一下它们之间发生了什么。</p>
<p><code>UIResponder</code> 是 <code>UIView</code> 的父类。<code>responder</code> 能够处理触摸、手势、远程控制等事件。之所以它是一个单独的类而没有合并到 <code>UIView</code> 中，是因为 <code>UIResponder</code> 有更多的子类，最明显的就是 <code>UIApplication</code> 和 <code>UIViewController</code>。通过重写 <code>UIResponder</code> 的方法，可以决定一个类是否可以成为第一响应者，例如当前输入焦点元素。</p>
<p>iOS 中要响应事件都必须继承 <code>UIResponder</code>，且是对象，我们称之为响应者对象。 继承 <code>UIResponder</code> 的有：</p>
<ul>
<li><code>UIApplication</code></li>
<li><code>UIViewController</code></li>
<li><code>UIView</code></li>
</ul>
<p>当触摸或运动传感器等交互行为发生时，它们被发送给第一响应者，通常是一个视图。如果第一响应者没有处理，则该行为沿着响应链到达视图控制器，如果行为仍然没有被处理，则继续传递给应用。如果想监测晃动手势，可以根据需要在这 3 层中的任意位置处理。</p>
<p><code>UIResponder</code> 还允许自定义输入方法，从 <code>inputAccessoryView</code> 向键盘添加辅助视图到使用 <code>inputView</code> 提供一个完全自定义的键盘，<code>UIResponder</code> 内部提供了以下方法来处理事件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一根或者多根手指开始触摸 view，系统会自动调用 view 的下面方法</span></div><div class="line">- (void)touchesBegan:(<span class="type">NSSet</span> *)touches withEvent:(<span class="type">UIEvent</span> *)event;</div><div class="line"><span class="comment">//一根或者多根手指在 view 上移动，系统会自动调用 view 的下面方法(随着手指的移动，会持续调用该方法)</span></div><div class="line">- (void)touchesMoved:(<span class="type">NSSet</span> *)touches withEvent:(<span class="type">UIEvent</span> *)event;</div><div class="line"><span class="comment">//一根或者多根手指离开 view，系统会自动调用 view 的下面方法</span></div><div class="line">- (void)touchesEnded:(<span class="type">NSSet</span> *)touches withEvent:(<span class="type">UIEvent</span> *)event;</div><div class="line"><span class="comment">//触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用 view 的下面方法</span></div><div class="line">- (void)touchesCancelled:(<span class="type">NSSet</span> *)touches withEvent:(<span class="type">UIEvent</span> *)event;</div><div class="line"></div><div class="line"><span class="comment">//加速计事件</span></div><div class="line">- (void)motionBegan:(<span class="type">UIEventSubtype</span>)motion withEvent:(<span class="type">UIEvent</span> *)event;</div><div class="line">- (void)motionEnded:(<span class="type">UIEventSubtype</span>)motion withEvent:(<span class="type">UIEvent</span> *)event;</div><div class="line">- (void)motionCancelled:(<span class="type">UIEventSubtype</span>)motion withEvent:(<span class="type">UIEvent</span> *)event;</div><div class="line"></div><div class="line"><span class="comment">//远程控制事件</span></div><div class="line">- (void)remoteControlReceivedWithEvent:(<span class="type">UIEvent</span> *)event;</div></pre></td></tr></table></figure>
<h2 id="UIControl"><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h2><p><code>UIControl</code> 建立在视图上，增加了更多的交互支持。最重要的是，它增加了 <code>target / action</code> 模式。看一下具体的子类，我们可以看一下按钮，日期选择器，文本框等等。创建交互控件时，你通常想要子类化一个 <code>UIControl</code>。</p>
<p>一些常见的像 <code>bar buttons</code> 虽然也支持 <code>target / action</code>，和 <code>text view</code> 其实并不是 <code>UIControl</code>。</p>
<p><code>UIControl</code> 是控制对象，继承于 <code>UIView</code>，如传达用户意图的应用程序按钮和滑块的基类。你不能使用 <code>UIControl</code> 的类直接实例化控件。相反，它定义了它的所有子类的通用接口和行为结构</p>
<blockquote>
<p><code>UIControl</code> 主要包括触摸事件、加速事件、远程事件这几种。</p>
</blockquote>
<h3 id="UIControl-的常用属性"><a href="#UIControl-的常用属性" class="headerlink" title="UIControl 的常用属性"></a>UIControl 的常用属性</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//控件默认是启用的。要禁用控件，可以将 enabled 属性设置为 NO，这将导致控件忽略任何触摸事件。被禁用后，控件还可以用不同的方式显示自己，比如变成灰色不可用。虽然是由控件的子类完成的，这个属性却存在于 `UIControl` 中。</span></div><div class="line"><span class="type">BOOL</span> enabled;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//当用户选中控件时，`UIControl` 类会将其 selected 属性设置为 YES。子类有时使用这个属性来让控件选择自身，或者来表现不同的行为方式。</span></div><div class="line"><span class="type">BOOL</span> selected;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">BOOL</span> highlighted;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//控件如何在垂直方向上布置自身的内容。</span></div><div class="line"><span class="type">UIControlContentVerticalAlignment</span> contentVerticalAlignment;    </div><div class="line"><span class="type">UIControlContentVerticalAlignmentCenter</span> <span class="comment">//居中</span></div><div class="line"><span class="type">UIControlContentVerticalAlignmentTop</span>    <span class="comment">//居顶</span></div><div class="line"><span class="type">UIControlContentVerticalAlignmentBottom</span> <span class="comment">//居下</span></div><div class="line"><span class="type">UIControlContentVerticalAlignmentFill</span></div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//控件如何在水平方向上布置自身的内容</span></div><div class="line"><span class="type">UIControlContentHorizontalAlignment</span> contentHorizontalAlignment;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// `UIControl`状态(只读)</span></div><div class="line"><span class="type">UIControlState</span> state;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//只读</span></div><div class="line"><span class="type">BOOL</span> tracking;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//是否touchInside(只读)</span></div><div class="line"><span class="type">BOOL</span> touchInside;</div></pre></td></tr></table></figure>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//事件通知。UIControl类提供了一个标准机制，来进行事件登记和接收。这令你可以指定你的控件在发生特定事件时，通知代理类的一个方法。</span></div><div class="line">- (<span class="type">BOOL</span>)beginTrackingWithTouch:(<span class="type">UITouch</span> *)touch withEvent:(<span class="type">UIEvent</span> *)event;</div><div class="line">- (<span class="type">BOOL</span>)continueTrackingWithTouch:(<span class="type">UITouch</span> *)touch withEvent:(<span class="type">UIEvent</span> *)event;</div><div class="line">- (void)endTrackingWithTouch:(<span class="type">UITouch</span> *)touch withEvent:(<span class="type">UIEvent</span> *)event;</div><div class="line">- (void)cancelTrackingWithEvent:(<span class="type">UIEvent</span> *)event;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注册一个事件</span></div><div class="line">- (void)addTarget:(id)target action:(<span class="type">SEL</span>)action forControlEvents:(<span class="type">UIControlEvents</span>)controlEvents;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//移除事件通知。要删除一个或多个事件的相应动作，可以使用`UIControl`类的removeTarget方法。使用nil值就可以将给定事件目标的所有动作删除</span></div><div class="line">- (void)removeTarget:(id)target action:(<span class="type">SEL</span>)action forControlEvents:(<span class="type">UIControlEvents</span>)controlEvents;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取得关于一个控件所有指定动作的列表，可以使用allTargets方法。这个方法返回一个NSSet，其中包含事件的完整列表</span></div><div class="line">- (<span class="type">NSSet</span>*)allTargets;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取关于一个控件所有事件的列表</span></div><div class="line">- (<span class="type">UIControlEvents</span>)allControlEvents;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取针对某一特定事件目标的全部动作列表</span></div><div class="line">- (<span class="type">NSArray</span> *)actionsForTarget:(id)target forControlEvent:(<span class="type">UIControlEvents</span>)controlEvent;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果设计了一个自定义控件类，可以使用sendActionsForControlEvent方法，为基本的`UIControl`事件或自己的自定义事件发送通知。例如，如果你的控件值正在发生变化，就可以发送相应通知，通过控件的代码可以指定时间目标，这个通知将被传播到这些指定的目标。</span></div><div class="line">- (void)sendAction:(<span class="type">SEL</span>)action to:(id)target forEvent:(<span class="type">UIEvent</span> *)event;</div><div class="line">- (void)sendActionsForControlEvents:(<span class="type">UIControlEvents</span>)controlEvents;</div></pre></td></tr></table></figure>
<h2 id="UIGestureRescognizer"><a href="#UIGestureRescognizer" class="headerlink" title="UIGestureRescognizer"></a>UIGestureRescognizer</h2><p><code>UIGestureRescognizer</code> 是一类手势识别器对象，它可以附属在你指定的 View 上，并且为其设定指定的手势操作，例如是点击、滑动或者是拖拽。当触控事件发生时，设置了<code>Gesture Recognizer`s` 的 View 会先通过识别器去拦截触控事件，如果该触控事件是事先为 View 设定的触控监听事件，那么</code>Gesture Recognizer<code>s</code> 将会发送动作消息给目标处理对象，目标处理对象则对这次触控事件进行处理，先看看如下流程图。</p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/actiontarget.png" alt="img"></p>
<p>在 iOS 中，View 就是我们在屏幕上看到的各种 UI 控件，当一个触控事件发生时，<code>Gesture Recognizer`s` 会先获取到指定的事件，然后发送 `action message` 给目标对象 `target`，目标对象就是 `ViewController`，在 `ViewController` 中通过事件方法完成对该事件的处理。</code>Gesture Recognizer<code>s</code> 能设置诸如单击、滑动、拖拽等事件，通过 <code>Action-Target</code> 这种设计模式，好处是能动态为 View 添加各种事件监听，而不用去实现一个 View 的子类去完成这些功能。</p>
<h3 id="常用手势识别类"><a href="#常用手势识别类" class="headerlink" title="常用手势识别类"></a>常用手势识别类</h3><p>在 <code>UIKit</code> 框架中，系统为我们事先定义好了一些常用的手势识别器，包括点击、双指缩放、拖拽、滑动、旋转以及长按，通过这些手势识别器我们可以构造丰富的操作方式。</p>
<table>
<thead>
<tr>
<th>子类</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>UITapGestureRecognizer</td>
<td>敲击</td>
</tr>
<tr>
<td>UIPinchGestureRecognizer</td>
<td>捏合，用于缩放</td>
</tr>
<tr>
<td>UIPanGestureRecognizer</td>
<td>拖拽</td>
</tr>
<tr>
<td>UISwipeGestureRecognizer</td>
<td>轻扫</td>
</tr>
<tr>
<td>UIRotationGestureRecognizer</td>
<td>旋转</td>
</tr>
<tr>
<td>UILongPressGestureRecognizer</td>
<td>长按</td>
</tr>
</tbody>
</table>
<p>在上表中可以看到，<code>UIKit</code> 框架中已经提供了诸如 <code>UITapGestureRecognizer</code> 在内的六种手势识别器，如果你需要实现自定义的手势识别器，也可以通过继承 <code>UIGestureRecognizer</code> 类并重写其中的方法来完成，这里我们就不详细讨论了。</p>
<p>每一个 <code>Gesture Recognizer</code> 关联一个 View，但是一个 View 可以关联多个 <code>Gesture Recognizer</code>，因为一个 View可能还能响应多种触控操作方式。当一个触控事件发生时，<code>Gesture Recognizer</code> 接收一个动作消息要先于 View 本身，结果就是 <code>Gesture Recognizer</code> 作为 View 处理触控事件的代表，或者叫代理。当 <code>Gesture Recognizer</code> 接收到指定的事件时，它就会发送一条 <code>action message</code> 给 <code>ViewController</code> 并处理。</p>
<h3 id="UIGestureRescognizer-常用属性和方法："><a href="#UIGestureRescognizer-常用属性和方法：" class="headerlink" title="UIGestureRescognizer 常用属性和方法："></a>UIGestureRescognizer 常用属性和方法：</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">@interface <span class="type">UIGestureRecognizer</span> : <span class="type">NSObject</span></div><div class="line">  </div><div class="line"><span class="comment">//创建一个手势对象并添加触发事件</span></div><div class="line">- (instancetype)initWithTarget:(nullable id)target action:(nullable <span class="type">SEL</span>)action <span class="type">NS_DESIGNATED_INITIALIZER</span>; </div><div class="line"></div><div class="line"><span class="comment">//给一个手势对象添加监听事件</span></div><div class="line">- (void)addTarget:(id)target action:(<span class="type">SEL</span>)action;  </div><div class="line"></div><div class="line"><span class="comment">//移除一个手势的监听事件</span></div><div class="line">- (void)removeTarget:(nullable id)target action:(nullable <span class="type">SEL</span>)action; </div><div class="line"></div><div class="line"><span class="comment">//设置能识别到手势的最少的轻触次数(默认为1)</span></div><div class="line">@property (nonatomic) <span class="type">NSUInteger</span>  numberOfTapsRequired;     </div><div class="line"></div><div class="line"><span class="comment">//设置能识别到手势的最少的手指的个数(默认为1) </span></div><div class="line">@property (nonatomic) <span class="type">NSUInteger</span>  numberOfTouchesRequired;  </div><div class="line"></div><div class="line"><span class="comment">//获取当前手势状态</span></div><div class="line">@property(nonatomic,readonly) <span class="type">UIGestureRecognizerState</span> state;  </div><div class="line"></div><div class="line"><span class="comment">//委托</span></div><div class="line">@property(nullable,nonatomic,<span class="keyword">weak</span>) id &lt;<span class="type">UIGestureRecognizerDelegate</span>&gt; delegate; </div><div class="line"></div><div class="line"><span class="comment">//手势识别是否可用</span></div><div class="line">@property(nonatomic, getter=isEnabled) <span class="type">BOOL</span> enabled;  </div><div class="line"></div><div class="line"><span class="comment">//获取手势触摸的View视图 只读</span></div><div class="line">@property(nullable, nonatomic,readonly) <span class="type">UIView</span> *view;  </div><div class="line"></div><div class="line"><span class="comment">/*是否取消触摸控件的响应</span></div><div class="line">默认为YES，这种情况下当手势识别器识别到触摸之后，会发送touchesCancelled</div><div class="line">给触摸到的控件以取消控件view对touch的响应，这个时候只有手势识别器响应touch，</div><div class="line">当设置成NO时，手势识别器识别到触摸之后不会发送touchesCancelled给控件，</div><div class="line">这个时候手势识别器和控件view均响应touch。</div><div class="line">注意：手势识别和触摸事件是同时存在的，只是因为touchesCancelled导致触摸事件失效。*/</div><div class="line">@property(nonatomic) <span class="type">BOOL</span> cancelsTouchesInView;    </div><div class="line"></div><div class="line"><span class="comment">/*是否延迟发送触摸事件给触摸到的控件</span></div><div class="line">默认是NO，这种情况下当发生一个触摸时，手势识别器先捕捉到到触摸，</div><div class="line">然后发给触摸到的控件，两者各自做出响应。</div><div class="line">如果设置为YES，手势识别器在识别的过程中(注意是识别过程)，不会将触摸发给触摸到的控件，即控件不会有任何触摸事件。</div><div class="line">只有在识别失败之后才会将触摸事件发给触摸到的控件，这种情况下控件view的响应会延迟约0.15ms。*/</div><div class="line">@property(nonatomic) <span class="type">BOOL</span> delaysTouchesBegan;     </div><div class="line">  </div><div class="line"><span class="comment">//如果触摸识别失败是否立即结束本次手势识别的触摸事件</span></div><div class="line">@property(nonatomic) <span class="type">BOOL</span> delaysTouchesEnded;        </div><div class="line"></div><div class="line"><span class="comment">/*指定一个手势需要另一个手势执行失败才会执行，同时触发多个手势使用其中一个手势的解决办法</span></div><div class="line">有时手势是相关联的，如单机和双击，点击和长按，点下去瞬间可能只会识别到单击无法识别其他，</div><div class="line">该方法可以指定某一个手势，即便自己已经满足条件了，也不会立刻触发，会等到该指定的手势确定失败之后才触发</div><div class="line">*/</div><div class="line">- (void)requireGestureRecognizerToFail:(<span class="type">UIGestureRecognizer</span> *)otherGestureRecognizer;</div><div class="line"></div><div class="line"><span class="comment">//获取当前触摸在指定视图上的点</span></div><div class="line">- (<span class="type">CGPoint</span>)locationInView:(nullable <span class="type">UIView</span>*)view;                               </div><div class="line"></div><div class="line"><span class="comment">//获取触摸手指数</span></div><div class="line">- (<span class="type">NSUInteger</span>)numberOfTouches;   </div><div class="line"></div><div class="line"><span class="comment">//多指触摸的触摸点相对于指定视图的位置</span></div><div class="line">- (<span class="type">CGPoint</span>)locationOfTouch:(<span class="type">NSUInteger</span>)touchIndex inView:(nullable <span class="type">UIView</span>*)view; </div><div class="line">@end</div><div class="line"> </div><div class="line"><span class="comment">//代理方法</span></div><div class="line">@<span class="class"><span class="keyword">protocol</span> <span class="title">UIGestureRecognizerDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line">  </div><div class="line">@<span class="title">optional</span></div><div class="line">//开始进行手势识别时调用的方法，返回<span class="title">NO</span>则结束识别，不再触发手势，用处：可以在控件指定的位置使用手势识别</div><div class="line">- (<span class="title">BOOL</span>)<span class="title">gestureRecognizerShouldBegin</span>:(<span class="title">UIGestureRecognizer</span> *)<span class="title">gestureRecognizer</span>;</div><div class="line"></div><div class="line">/*是否支持多手势触发，返回<span class="title">YES</span>，则可以多个手势一起触发方法，返回<span class="title">NO</span>则为互斥。</div><div class="line">是否允许多个手势识别器共同识别，一个控件的手势识别后是否阻断手势识别继续向下传播。</div><div class="line">默认返回<span class="title">NO</span>，如果为<span class="title">YES</span>，响应者链上层对象触发手势识别后，如果下层对象也添加了手势并成功识别也会继续执行，</div><div class="line">否则上层对象识别后则不再继续传播*/</div><div class="line">- (<span class="title">BOOL</span>)<span class="title">gestureRecognizer</span>:(<span class="title">UIGestureRecognizer</span> *)<span class="title">gestureRecognizer</span> <span class="title">shouldRecognizeSimultaneouslyWithGestureRecognizer</span>:(<span class="title">UIGestureRecognizer</span> *)<span class="title">otherGestureRecognizer</span>;</div><div class="line"></div><div class="line">//这个方法返回<span class="title">YES</span>，第一个手势和第二个互斥时，第一个会失效</div><div class="line">- (<span class="title">BOOL</span>)<span class="title">gestureRecognizer</span>:(<span class="title">UIGestureRecognizer</span> *)<span class="title">gestureRecognizer</span> <span class="title">shouldRequireFailureOfGestureRecognizer</span>:(<span class="title">UIGestureRecognizer</span> *)<span class="title">otherGestureRecognizer</span>;</div><div class="line"></div><div class="line">//这个方法返回<span class="title">YES</span>，第一个和第二个互斥时，第二个会失效</div><div class="line">- (<span class="title">BOOL</span>)<span class="title">gestureRecognizer</span>:(<span class="title">UIGestureRecognizer</span> *)<span class="title">gestureRecognizer</span> <span class="title">shouldBeRequiredToFailByGestureRecognizer</span>:(<span class="title">UIGestureRecognizer</span> *)<span class="title">otherGestureRecognizer</span>;</div><div class="line"></div><div class="line">/*手指触摸屏幕后回调的方法，返回<span class="title">NO</span>则不再进行手势识别，方法触发等</div><div class="line">此方法在<span class="title">window</span>对象在有触摸事件发生时，调用`<span class="title">Gesture</span> <span class="title">Recognizer</span>`的</div><div class="line"><span class="title">touchesBegan</span>:<span class="title">withEvent</span>:方法之前调用。</div><div class="line">如果返回<span class="title">NO</span>,则`<span class="title">Gesture</span> <span class="title">Recognizer</span>`不会看到此触摸事件。(默认情况下为<span class="title">YES</span>)*/</div><div class="line">- (<span class="title">BOOL</span>)<span class="title">gestureRecognizer</span>:(<span class="title">UIGestureRecognizer</span> *)<span class="title">gestureRecognizer</span> <span class="title">shouldReceiveTouch</span>:(<span class="title">UITouch</span> *)<span class="title">touch</span>;</div><div class="line"></div><div class="line">@<span class="title">end</span></div></pre></td></tr></table></figure>
<h3 id="UILongPressGestureRecognizer-常用属性和方法"><a href="#UILongPressGestureRecognizer-常用属性和方法" class="headerlink" title="UILongPressGestureRecognizer 常用属性和方法"></a>UILongPressGestureRecognizer 常用属性和方法</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@interface <span class="type">UILongPressGestureRecognizer</span> : <span class="type">UIGestureRecognizer</span></div><div class="line"><span class="comment">//设置能识别到手势的最少的轻触次数(默认为1)</span></div><div class="line">@property (nonatomic) <span class="type">NSUInteger</span> numberOfTapsRequired;     </div><div class="line"><span class="comment">//设置能识别到手势的最少的手指的个数(默认为1) </span></div><div class="line">@property (nonatomic) <span class="type">NSUInteger</span> numberOfTouchesRequired;   </div><div class="line"><span class="comment">//设置能识别到长按手势的最短的长按时间，单位：秒，默认为0.5</span></div><div class="line">@property (nonatomic) <span class="type">CFTimeInterval</span> minimumPressDuration; </div><div class="line"><span class="comment">//设置长按时允许移动的最大距离，单位：像素，默认为10像素</span></div><div class="line">@property (nonatomic) <span class="type">CGFloat</span> allowableMovement;           </div><div class="line">@end</div><div class="line">  </div><div class="line"><span class="type">UILongPressGestureRecognizer</span> *longPress = [[<span class="type">UILongPressGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:@selector(longPressAction:)];</div><div class="line"><span class="comment">//设置能识别到长按手势的最小的长按时间</span></div><div class="line">longPress.minimumPressDuration = <span class="number">0.5</span>;</div><div class="line"><span class="comment">//"容错的范围"</span></div><div class="line">longPress.allowableMovement  = <span class="number">10</span>;</div><div class="line"><span class="comment">//把长按手势添加到对应的控件中</span></div><div class="line">[<span class="keyword">self</span>.imgView addGestureRecognizer:longPress];</div></pre></td></tr></table></figure>
<h3 id="UISwipeGestureRecognizer-常用属性和方法"><a href="#UISwipeGestureRecognizer-常用属性和方法" class="headerlink" title="UISwipeGestureRecognizer 常用属性和方法"></a>UISwipeGestureRecognizer 常用属性和方法</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">typedef <span class="type">NS_OPTIONS</span>(<span class="type">NSUInteger</span>, <span class="type">UISwipeGestureRecognizerDirection</span>) &#123;</div><div class="line">    <span class="type">UISwipeGestureRecognizerDirectionRight</span> = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,  <span class="comment">//向右滑</span></div><div class="line">    <span class="type">UISwipeGestureRecognizerDirectionLeft</span>  = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,  <span class="comment">//向左滑</span></div><div class="line">    <span class="type">UISwipeGestureRecognizerDirectionUp</span>    = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,  <span class="comment">//向上滑</span></div><div class="line">    <span class="type">UISwipeGestureRecognizerDirectionDown</span>  = <span class="number">1</span> &lt;&lt; <span class="number">3</span>  <span class="comment">//向下滑</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">@interface <span class="type">UISwipeGestureRecognizer</span> : <span class="type">UIGestureRecognizer</span>`</div><div class="line"><span class="comment">//最少触摸手指个数，默认为1</span></div><div class="line">@property(nonatomic) <span class="type">NSUInteger</span> numberOfTouchesRequired; </div><div class="line"><span class="comment">//设置轻扫手势支持的方向，默认为向右滑</span></div><div class="line">@property(nonatomic) <span class="type">UISwipeGestureRecognizerDirection</span> direction;               </div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="UIRotationGestureRecognizer-常用属性和方法"><a href="#UIRotationGestureRecognizer-常用属性和方法" class="headerlink" title="UIRotationGestureRecognizer 常用属性和方法"></a>UIRotationGestureRecognizer 常用属性和方法</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@interface <span class="type">UIRotationGestureRecognizer</span> : <span class="type">UIGestureRecognizer</span></div><div class="line"><span class="comment">//旋转的角度</span></div><div class="line">@property (nonatomic) <span class="type">CGFloat</span> rotation;  </div><div class="line"><span class="comment">//旋转速度，单位：度/秒、         </span></div><div class="line">@property (nonatomic,readonly) <span class="type">CGFloat</span> velocity;           </div><div class="line">@end</div><div class="line"></div><div class="line"><span class="comment">//为图片框添加一个旋转手势</span></div><div class="line"><span class="type">UIRotationGestureRecognizer</span> *rotation = [[<span class="type">UIRotationGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:@selector(rotateAction:)];rotation.delegate = <span class="keyword">self</span>;</div><div class="line">[<span class="keyword">self</span>.imgView addGestureRecognizer:rotation];</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//旋转手势的监听方法</span></div><div class="line">- (void)rotateAction:(<span class="type">UIRotationGestureRecognizer</span> *)recognizer &#123;</div><div class="line"><span class="comment">//在原来的基础上, 累加多少度</span></div><div class="line">recognizer.view.transform = <span class="type">CGAffineTransformRotate</span>(recognizer.view.transform, recognizer.rotation);</div><div class="line"><span class="comment">//每次旋转完毕后将rotation的值, 恢复到0的位置.recognizer.rotation = 0;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="UIPanGestureRecognizer-常用属性和方法"><a href="#UIPanGestureRecognizer-常用属性和方法" class="headerlink" title="UIPanGestureRecognizer 常用属性和方法"></a>UIPanGestureRecognizer 常用属性和方法</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@interface <span class="type">UIPanGestureRecognizer</span> : <span class="type">UIGestureRecognizer</span></div><div class="line"><span class="comment">//设置触发拖拽最少手指数，默认为1</span></div><div class="line">@property (nonatomic) <span class="type">NSUInteger</span> minimumNumberOfTouches;   </div><div class="line"><span class="comment">//设置触发拖拽最多手指数，默认为 UINT_MAX 无限大</span></div><div class="line">@property (nonatomic) <span class="type">NSUInteger</span> maximumNumberOfTouches;   </div><div class="line"><span class="comment">//获取当前拖拽位置</span></div><div class="line">- (<span class="type">CGPoint</span>)translationInView:(nullable <span class="type">UIView</span> *)view;                        </div><div class="line"><span class="comment">//设置当前拖拽位置</span></div><div class="line">- (void)setTranslation:(<span class="type">CGPoint</span>)translation inView:(nullable <span class="type">UIView</span> *)view;</div><div class="line"><span class="comment">//设置拖拽速度，单位：像素/秒</span></div><div class="line">- (<span class="type">CGPoint</span>)velocityInView:(nullable <span class="type">UIView</span> *)view;                          </div><div class="line">@end</div><div class="line">  </div><div class="line"><span class="type">UIPanGestureRecognizer</span> *pan = [[<span class="type">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:@selector(panAction:)];</div><div class="line">[<span class="keyword">self</span>.imgView addGestureRecognizer:pan];</div><div class="line"></div><div class="line"><span class="comment">//拖拽手势的监听方法</span></div><div class="line">- (void)panAction:(<span class="type">UIPanGestureRecognizer</span> *)recognizer &#123;</div><div class="line">  <span class="comment">//获取手指拖拽的时候, 平移的值</span></div><div class="line">  <span class="type">CGPoint</span> translation = [recognizer translationInView:recognizer.view];</div><div class="line">  <span class="comment">//让当前控件做响应的平移</span></div><div class="line">  recognizer.view.transform = <span class="type">CGAffineTransformTranslate</span>(recognizer.view.transform, translation.x, translation.y);</div><div class="line">  <span class="comment">//每次平移手势识别完毕后, 让平移的值不要累加</span></div><div class="line">  [recognizer setTranslation:<span class="type">CGPointZero</span> inView:recognizer.view];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="连续和不连续动作"><a href="#连续和不连续动作" class="headerlink" title="连续和不连续动作"></a>连续和不连续动作</h3><p>触控动作同时分为连续动作和不连续动作，连续动作例如滑动和拖拽，它会持续一小段时间，而不连续动作例如单击，它瞬间就会完成，在这两类事件的处理上又稍有不同。</p>
<p>对于不连续动作，<code>Gesture Recognizer</code> 只会给 <code>ViewContoller</code> 发送一个单一的动作消息，而对于连续动作，<code>Gesture Recognizer</code> 会发送多条动作消息给 <code>ViewContoller</code>，直到所有的事件都结束。</p>
<p>为一个 View 添加 <code>GestureRecognizer</code> 有两种方式，一种是通过 <code>InterfaceBuilder</code> 实现，另一种就是通过代码实现，我们看看通过代码来如何实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//初始化手势</span></div><div class="line"><span class="keyword">let</span> tap = <span class="type">UITapGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(<span class="keyword">self</span>.doSomeThing(tap:)))</div><div class="line"><span class="comment">//指定操作为点击 1 次</span></div><div class="line">tap.numberOfTapsRequired = <span class="number">1</span></div><div class="line"><span class="comment">//需要 2 根手指同时点击</span></div><div class="line">tap.numberOfTouchesRequired = <span class="number">2</span></div><div class="line"><span class="comment">//为当前 View 添加 GestureRecognizer</span></div><div class="line">view.addGestureRecognizer(tap</div></pre></td></tr></table></figure>
<p>在事件处理过程中，这两种方式所处的状态又各有不同，首先，所有的触控事件最开始都是处于可用状态 <code>Possible</code>，对应 <code>UIKit</code> 里面的 <code>UIGestureRecognizerStatePossible</code> 类，如果是不连续动作事件，则状态只会从 <code>Possible</code> 转变为已识别状态 <code>Recognized</code> 或者是失败状态 <code>Failed</code>。例如一次成功的单击动作，就对应了 <code>Possible-Recognized</code> 这个过程。</p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/possiblerecognized%20.png" alt="img"></p>
<p>手势识别有以下几种状态：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>UIGestureRecognizerStatePossible</td>
<td>没有触摸事件发生，所有手势识别的默认状态</td>
</tr>
<tr>
<td>UIGestureRecognizerStateBegan</td>
<td>一个手势已经开始但尚未改变或者完成时</td>
</tr>
<tr>
<td>UIGestureRecognizerStateChanged</td>
<td>手势状态改变</td>
</tr>
<tr>
<td>UIGestureRecognizerStateEnded</td>
<td>手势完成</td>
</tr>
<tr>
<td>UIGestureRecognizerStateCancelled</td>
<td>手势取消，恢复至Possible状态</td>
</tr>
<tr>
<td>UIGestureRecognizerStateFailed</td>
<td>手势失败，恢复至Possible状态</td>
</tr>
</tbody>
</table>
<p>如果是连续动作事件，如果事件没有失败并且连续动作的第一个动作被 <code>Recognized</code>，则从 <code>Possible</code> 状态转移到 <code>Began</code> 状态，这里表示连续动作的开始，接着会转变为 <code>Changed</code> 状态，在这个状态下会不断循环的处理连续动作，直到动作执行完成变转变为 <code>Recognized</code> 已识别状态，最终该动作会处于完成状态 <code>Ended</code>，另外，连续动作事件的处理状态会从 <code>Changed</code> 状态转变为 <code>Canceled</code> 状态，原因是识别器认为当前的动作已经不匹配当初对事件的设定了。</p>
<h2 id="UITouch-amp-UIEvent"><a href="#UITouch-amp-UIEvent" class="headerlink" title="UITouch &amp; UIEvent"></a>UITouch &amp; UIEvent</h2><p>在屏幕上的每一次动作事件都是一次 <code>Touch</code>，在 iOS 中用 <code>UITouch</code> 对象表示每一次的触控，多个 <code>Touch</code> 组成一次 <code>Event</code>，用 <code>UIEvent</code> 来表示一次事件对象。目前 iOS 设备支持的多点操作手指数最多是 5，下图展示了一个 <code>UIEvent</code> 对象与多个 <code>UITouch</code> 对象之间的关系。</p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/uitouch.png" alt="img"></p>
<p><strong>当用户触摸屏幕后，就会产生相应的事件，所有相关的 <code>UITouch</code> 对象都被包装在事件中，被程序交由特定的对象来处理。<code>UITouch</code> 对象直接包括触摸的详细信息，比如触摸的位置、时间、阶段。</strong></p>
<p>当手指移动时，系统会更新同一个 <code>UITouch</code> 对象，使之能够一直保存该手指在的触摸位置，当手指离开屏幕时，系统会销毁相应的 <code>UITouch</code> 对象。</p>
<h3 id="UITouch-的常用属性和方法"><a href="#UITouch-的常用属性和方法" class="headerlink" title="UITouch 的常用属性和方法"></a>UITouch 的常用属性和方法</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//触摸事件在屏幕上有一个周期</span></div><div class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">UITouchPhase</span>) &#123;</div><div class="line">    <span class="type">UITouchPhaseBegan</span>,           <span class="comment">//开始触摸  </span></div><div class="line">    <span class="type">UITouchPhaseMoved</span>,           <span class="comment">//移动    </span></div><div class="line">    <span class="type">UITouchPhaseStationary</span>,      <span class="comment">//停留</span></div><div class="line">    <span class="type">UITouchPhaseEnded</span>,           <span class="comment">//触摸结束</span></div><div class="line">    <span class="type">UITouchPhaseCancelled</span>,       <span class="comment">//触摸中断</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//检测是否支持3DTouch</span></div><div class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">UIForceTouchCapability</span>) &#123;</div><div class="line">    <span class="type">UIForceTouchCapabilityUnknown</span> = <span class="number">0</span>,  <span class="comment">//3D Touch检测失败</span></div><div class="line">    <span class="type">UIForceTouchCapabilityUnavailable</span> = <span class="number">1</span>,  <span class="comment">//3D Touch不可用</span></div><div class="line">    <span class="type">UIForceTouchCapabilityAvailable</span> = <span class="number">2</span>  <span class="comment">//3D Touch可用</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">@interface <span class="type">UITouch</span> : <span class="type">NSObject</span></div><div class="line"></div><div class="line"><span class="comment">//触摸产生或变化的时间戳 只读</span></div><div class="line">@property(nonatomic,readonly) <span class="type">NSTimeInterval</span>      timestamp;</div><div class="line"><span class="comment">//触摸周期内的各个状态</span></div><div class="line">@property(nonatomic,readonly) <span class="type">UITouchPhase</span>        phase;</div><div class="line"><span class="comment">//短时间内点击的次数 只读</span></div><div class="line">@property(nonatomic,readonly) <span class="type">NSUInteger</span>          tapCount;   </div><div class="line"></div><div class="line"><span class="comment">//获取手指与屏幕的接触半径 IOS8以后可用 只读</span></div><div class="line">@property(nonatomic,readonly) <span class="type">CGFloat</span> majorRadius <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">8_0</span>);</div><div class="line"><span class="comment">//获取手指与屏幕的接触半径的误差 IOS8以后可用 只读</span></div><div class="line">@property(nonatomic,readonly) <span class="type">CGFloat</span> majorRadiusTolerance <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">8_0</span>);</div><div class="line"></div><div class="line"><span class="comment">//触摸时所在的窗口 只读</span></div><div class="line">@property(nullable,nonatomic,readonly,strong) <span class="type">UIWindow</span> *window;</div><div class="line"><span class="comment">//触摸时所在视图</span></div><div class="line">@property(nullable,nonatomic,readonly,strong) <span class="type">UIView</span> *view;</div><div class="line"><span class="comment">//获取触摸手势</span></div><div class="line">@property(nullable,nonatomic,readonly,copy)   <span class="type">NSArray</span> &lt;<span class="type">UIGestureRecognizer</span> *&gt;  *gestureRecognizers </div><div class="line"></div><div class="line"><span class="comment">//取得在指定视图的位置</span></div><div class="line"><span class="comment">//返回值表示触摸在view上的位置</span></div><div class="line"><span class="comment">//这里返回的位置是针对view的坐标系的(以view的左上角为原点(0,0))</span></div><div class="line"><span class="comment">//调用时传入的view参数为nil的话，返回的是触摸点在`UIWindow`的位置</span></div><div class="line">- (<span class="type">CGPoint</span>)locationInView:(nullable <span class="type">UIView</span> *)view;</div><div class="line"><span class="comment">//该方法记录了前一个触摸点的位置</span></div><div class="line">- (<span class="type">CGPoint</span>)previousLocationInView:(nullable <span class="type">UIView</span> *)view;</div><div class="line"></div><div class="line"><span class="comment">//获取触摸压力值，一般的压力感应值为1.0 IOS9 只读</span></div><div class="line">@property(nonatomic,readonly) <span class="type">CGFloat</span> force <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">9_0</span>);</div><div class="line"></div><div class="line"><span class="comment">//获取最大触摸压力值</span></div><div class="line">@property(nonatomic,readonly) <span class="type">CGFloat</span> maximumPossibleForce <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">9_0</span>);</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当手指接触到屏幕，不管是单点触摸还是多点触摸，事件都会开始，直到用户所有的手指都离开屏幕。期间所有的 <code>UITouch</code> 对象都被包含在 <code>UIEvent</code> 事件对象中，由程序分发给处理者，事件记录了这个周期中所有触摸对象状态的变化。</p>
<p>只要屏幕被触摸，系统就会报若干个触摸的信息封装到 <code>UIEvent</code> 对象中发送给程序，由管理程序 <code>UIApplication</code> 对象将事件分发。一般来说，事件将被发给主窗口，然后传给第一响应者对象处理。</p>
<p>在上述过程中，完成了一次双指缩放的事件动作，每一次手指状态的变化都对应事件动作处理过程中得一个阶段。通过 <code>Began-Moved-Ended</code> 这几个阶段的 <code>Touch</code> 共同构成了一次事件 <code>Event</code>。在事件响应对象 <code>UIResponder</code> 中有对应的方法来分别处理这几个阶段的事件。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一根或者多根手指开始触摸 view，系统会自动调用 view 的下面方法</span></div><div class="line">- (void)touchesBegan:(<span class="type">NSSet</span> *)touches withEvent:(<span class="type">UIEvent</span> *)event;</div><div class="line"><span class="comment">//一根或者多根手指在 view 上移动，系统会自动调用 view 的下面方法(随着手指的移动，会持续调用该方法)</span></div><div class="line">- (void)touchesMoved:(<span class="type">NSSet</span> *)touches withEvent:(<span class="type">UIEvent</span> *)event;</div><div class="line"><span class="comment">//一根或者多根手指离开 view，系统会自动调用 view 的下面方法</span></div><div class="line">- (void)touchesEnded:(<span class="type">NSSet</span> *)touches withEvent:(<span class="type">UIEvent</span> *)event;</div><div class="line"><span class="comment">//触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用 view 的下面方法</span></div><div class="line">- (void)touchesCancelled:(<span class="type">NSSet</span> *)touches withEvent:(<span class="type">UIEvent</span> *)event;</div></pre></td></tr></table></figure>
<p>4 个触摸事件处理方法中，都有 <code>NSSet *touches</code> 和 <code>UIEvent *event</code> 两个参数，一次完整的触摸过程中，只会产生一个事件对象，4 个触摸方法都是同一个 <code>event</code> 参数。</p>
<p>如果两根手指同时触摸一个 View，那么 View 只会调用一次 <code>touchesBegan:withEvent:</code> 方法，<code>touches</code> 参数中装着 2 个 <code>UITouch</code> 对象。</p>
<p>如果这两根手指一前一后分开触摸同一个 View，那么 View 会分别调用 2 次 <code>touchesBegan:withEvent:</code> 方法，并且每次调用时的 <code>touches</code> 参数中只包含一个 <code>UITouch</code> 对象。根据 <code>touches</code> 中 <code>UITouch</code> 的个数可以判断出是单点触摸还是多点触摸。</p>
<h3 id="UIEvent-常用属性和方法"><a href="#UIEvent-常用属性和方法" class="headerlink" title="UIEvent 常用属性和方法"></a>UIEvent 常用属性和方法</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//事件类型</span></div><div class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">UIEventType</span>) &#123;</div><div class="line">    <span class="type">UIEventTypeTouches</span>,<span class="comment">//触控</span></div><div class="line">    <span class="type">UIEventTypeMotion</span>, <span class="comment">//加速感应器</span></div><div class="line">    <span class="type">UIEventTypeRemoteControl</span>,<span class="comment">//远程操作</span></div><div class="line">    <span class="type">UIEventTypePresses</span> <span class="comment">//3D touch</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//触摸事件的类型</span></div><div class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">UIEventSubtype</span>) &#123;</div><div class="line">    </div><div class="line">    <span class="type">UIEventSubtypeNone</span>                              = <span class="number">0</span>,</div><div class="line">    <span class="comment">//摇晃 </span></div><div class="line">    <span class="type">UIEventSubtypeMotionShake</span>                       = <span class="number">1</span>,</div><div class="line">   	<span class="comment">//播放</span></div><div class="line">    <span class="type">UIEventSubtypeRemoteControlPlay</span>                 = <span class="number">100</span>,</div><div class="line">   	<span class="comment">//暂停</span></div><div class="line">    <span class="type">UIEventSubtypeRemoteControlPause</span>                = <span class="number">101</span>,</div><div class="line">    <span class="comment">//停止</span></div><div class="line">    <span class="type">UIEventSubtypeRemoteControlStop</span>                 = <span class="number">102</span>,</div><div class="line">    <span class="comment">//播放和暂停切换 </span></div><div class="line">    <span class="type">UIEventSubtypeRemoteControlTogglePlayPause</span>      = <span class="number">103</span>,</div><div class="line">    <span class="comment">//下一首</span></div><div class="line">    <span class="type">UIEventSubtypeRemoteControlNextTrack</span>            = <span class="number">104</span>,</div><div class="line">    <span class="comment">//上一首</span></div><div class="line">    <span class="type">UIEventSubtypeRemoteControlPreviousTrack</span>        = <span class="number">105</span>,</div><div class="line">    <span class="comment">//开始后退 </span></div><div class="line">    <span class="type">UIEventSubtypeRemoteControlBeginSeekingBackward</span> = <span class="number">106</span>,</div><div class="line">    <span class="comment">//结束后退 </span></div><div class="line">    <span class="type">UIEventSubtypeRemoteControlEndSeekingBackward</span>   = <span class="number">107</span>,</div><div class="line">    <span class="comment">//开始快进 </span></div><div class="line">    <span class="type">UIEventSubtypeRemoteControlBeginSeekingForward</span>  = <span class="number">108</span>,</div><div class="line">    <span class="comment">//结束快进</span></div><div class="line">    <span class="type">UIEventSubtypeRemoteControlEndSeekingForward</span>    = <span class="number">109</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@interface <span class="type">UIEvent</span> : <span class="type">NSObject</span></div><div class="line"><span class="comment">//事件类型</span></div><div class="line">@property(nonatomic,readonly) <span class="type">UIEventType</span>   </div><div class="line"><span class="comment">//触摸事件的类型</span></div><div class="line">@property(nonatomic,readonly) <span class="type">UIEventSubtype</span>  </div><div class="line"></div><div class="line"><span class="comment">//事件的时间戳</span></div><div class="line">@property(nonatomic,readonly) <span class="type">NSTimeInterval</span>  timestamp;</div><div class="line"></div><div class="line"><span class="comment">//所有的触摸 </span></div><div class="line">- (nullable <span class="type">NSSet</span> &lt;<span class="type">UITouch</span> *&gt; *)allTouches;</div><div class="line"><span class="comment">//获得`UIWindow`的触摸</span></div><div class="line">- (nullable <span class="type">NSSet</span> &lt;<span class="type">UITouch</span> *&gt; *)touchesForWindow:(<span class="type">UIWindow</span> *)window;</div><div class="line"><span class="comment">//获得`UIView`的触摸  </span></div><div class="line">- (nullable <span class="type">NSSet</span> &lt;<span class="type">UITouch</span> *&gt; *)touchesForView:(<span class="type">UIView</span> *)view;</div><div class="line"><span class="comment">//获得事件中特定手势的触摸</span></div><div class="line">- (nullable <span class="type">NSSet</span> &lt;<span class="type">UITouch</span> *&gt; *)touchesForGestureRecognizer:(<span class="type">UIGestureRecognizer</span> *)gesture ;</div><div class="line"><span class="comment">//会将丢失的触摸放到一个新的 `UIEvent` 数组中，你可以用 coalescedTouchesForTouch(_:) 方法来访问</span></div><div class="line">- (nullable <span class="type">NSArray</span> &lt;<span class="type">UITouch</span> *&gt; *)coalescedTouchesForTouch:(<span class="type">UITouch</span> *)touch;</div><div class="line"><span class="comment">//辅助`UITouch`的触摸，预测发生了一系列主要的触摸事件。这些预测可能不完全匹配的触摸的真正的行为，因为它的移动，所以他们应该被解释为一个估计。</span></div><div class="line">- (nullable <span class="type">NSArray</span> &lt;<span class="type">UITouch</span> *&gt; *)predictedTouchesForTouch:(<span class="type">UITouch</span> *)touch;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>UIEvent</code> 是代表 iOS 系统中的一个事件，一个事件包含一个或多个的 <code>UITouch</code>；<code>UIEvent</code> 分为三类：</p>
<ol>
<li><code>UIEventTypeTouches</code> 触摸事件，通过触摸、手势进行触发，例如手指点击、缩放；</li>
<li><code>UIEventTypeMotion</code> 运动事件，通过加速器进行触发，例如手机晃动；</li>
<li><code>UIEventTypeRemoteControl</code> 远程控制事件，通过其他远程设备触发，例如耳机控制按钮；</li>
</ol>
<p>触摸对象的事件类型包括一个或多个触摸，触摸与某一事件联系在一起。一个触摸是被一个 <code>UITouch</code> 对象调用的。当一个事件触发了，系统将会把它传递给合适的响应对象并通过 <code>UIEvent</code> 对象发出一个消息。</p>
<p>调用 <code>UIResponder</code> 方法如 <code>touchesBegan:withEvent:</code>，响应对象可以分配触摸事件到合适的触摸类型并适当的控制他们。<code>UIEvent</code> 中的方法可以让你获取全部的触摸事件 <code>allTouches</code> 或者给定的视图或者窗口 <code>touchesForView: 或者 touchesForWindow:</code>，它可以分辨从响应对象传递过来的事件对象发生的时间 <code>timestamp</code>。</p>
<p>一个 <code>UIEvent</code> 对象贯穿在多点触摸事件的序列中，<code>UIKit</code> 重用同一个 <code>UIEvent</code> 实例来分配每一个事件到应用程序。你不需要保持一个事件对象或者任何从事件对象返回的对象。如果你需要保存事件对象然后传递到另外一个对象，你需要从 <code>UITouch</code> 或者 <code>UIEvent</code> 中复制信息。</p>
<p>你可以通过类型属性和子类型属性，获取事件类型和事件的子类型。<code>UIEvent</code> 定义了事件的类型为触摸，摇晃和遥控事件，它也定义了摇晃事件的子类型，以及为遥控事件定义了一系列的子类型。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>iOS触摸事件的流动：<a href="http://shellhue.github.io/2017/03/04/FlowOfUITouch/" target="_blank" rel="external">http://shellhue.github.io/2017/03/04/FlowOfUITouch/</a></p>
<p>iOS事件的传递与响应：<a href="http://blog.csdn.net/yongyinmg/article/details/19616527" target="_blank" rel="external">http://blog.csdn.net/yongyinmg/article/details/19616527</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;响应者对象就是可以响应事件并对事件作出处理。在 iOS 中，存在 &lt;code&gt;UIResponder&lt;/code&gt; 类，它定义了响应者对象的所有方法。&lt;code&gt;UIApplication&lt;/code&gt;、&lt;code&gt;UIView&lt;/code&gt; 等类都继承了 &lt;code&gt;UIResponder&lt;/code&gt; 类，&lt;code&gt;UIWindow&lt;/code&gt; 和 &lt;code&gt;UIKit&lt;/code&gt; 中的控件因为继承了 &lt;code&gt;UIView&lt;/code&gt;，所以也间接继承了 &lt;code&gt;UIResponder&lt;/code&gt; 类，这些类的实例都可以当作响应者。&lt;/p&gt;
&lt;p&gt;当前接受触摸的响应者对象被称为第一响应者，即表示当前该对象正在与用户交互，它是响应者链的开端。&lt;/p&gt;
&lt;p&gt;响应者链表示一系列的响应者对象。事件被交由第一响应者对象处理，如果第一响应者不处理，事件被沿着响应者链向上传递，交给下一个响应者。&lt;/p&gt;
&lt;p&gt;一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象(如果存在)，然后是它的父视图对象(如果存在)，以此类推，直到顶层视图。&lt;/p&gt;
&lt;p&gt;接下来会沿着顶层视图(&lt;code&gt;top view&lt;/code&gt;)到窗口(&lt;code&gt;UIWindow&lt;/code&gt;)再到程序(&lt;code&gt;UIApplication&lt;/code&gt;)。如果整个过程都没有响应这个事件，该事件就被丢弃。&lt;/p&gt;
&lt;p&gt;一般情况下，在响应者链中只要由对象处理事件，事件就停止传递。但有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。&lt;/p&gt;
    
    </summary>
    
      <category term="响应链" scheme="http://yoursite.com/categories/%E5%93%8D%E5%BA%94%E9%93%BE/"/>
    
    
      <category term="事件" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6/"/>
    
      <category term="Aciton-Target" scheme="http://yoursite.com/tags/Aciton-Target/"/>
    
      <category term="事件分发" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    
      <category term="事件拦截" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发 - 利用Runtime优化归解档 </title>
    <link href="http://yoursite.com/2017/01/24/iOS%E5%BC%80%E5%8F%91%20-%20%E5%88%A9%E7%94%A8Runtime%E4%BC%98%E5%8C%96%E5%BD%92%E8%A7%A3%E6%A1%A3%20/"/>
    <id>http://yoursite.com/2017/01/24/iOS开发 - 利用Runtime优化归解档 /</id>
    <published>2017-01-23T20:43:00.000Z</published>
    <updated>2017-01-24T15:25:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Runtime 是 iOS 开发中的知名黑魔法，充分体现了 Objective - C 的动态运行时特性，Swift 是一门静态语言，这意味着代码编译时即确定了其实际调用的方法和类型，所以纯粹的 Swift 类和对象没有办法使用 Runtime，更不存在 Method swizzling，但是呢，Swift 是兼容 Objective - C 的，继承自 NSObject 的类，也就具有了运行时的消息机制。</p>
<p>纯粹的 Swift 类，也可以通过添加 <code>@objc</code> 修饰符， <code>@objc</code> 关键字只需要对那些不是继承自 <code>NSObject</code> 的类型进行，如果 class 是继承自 <code>NSObject</code> 的话，Swift 会默认自动为所有的非 private 的类和成员加上 <code>@objc</code>。</p>
<p> <code>@objc</code> 修饰符主要用于需要暴露给 Objective-C 使用的任何地方 (包括类，属性和方法等) ，以支持其动态派发和运行时机制。</p>
<p>添加 <code>@objc</code> 修饰符并不意味着这个方法或者属性会变成动态派发，Swift 依然可能会将其优化为静态调用。如果需要施展一些像 Method swizzling 或者运行时再决定实现这样的 “黑魔法” 的时候，我们就必须用到 <code>dynamic</code> 修饰符了。 <code>dynamic</code> 修饰符会隐式的添加 <code>@objc</code> 进行修饰。</p>
<p>也就是说，需要 Swift 和 Objective 混合开发时，使用 <code>@objc</code> 就可以了，需要 Swift 完全实现运行时机制时，那么必须要添加 <code>dynamic</code> 修饰符。</p>
<p>下面我们通过优化归解档，来了解 Runtime 在 Swift 中的应用：</p>
<a id="more"></a>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span>, <span class="title">NSCoding</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> age = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">        <span class="keyword">self</span>.age = age</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(with aCoder: NSCoder)</span></span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//属性的个数</span></div><div class="line">        <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">UInt32</span> = <span class="number">0</span></div><div class="line">        <span class="comment">//获取属性列表，inout属性的个数</span></div><div class="line">        <span class="keyword">let</span> ivars = class_copyIvarList(<span class="type">Person</span>.<span class="keyword">self</span>, &amp;<span class="built_in">count</span>)</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; <span class="built_in">count</span> &#123;</div><div class="line">            <span class="comment">//取出属性</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> ivar = ivars?[<span class="type">Int</span>(i)] &#123;</div><div class="line">                <span class="comment">//获取属性名</span></div><div class="line">                <span class="keyword">let</span> key = <span class="type">String</span>(utf8String: ivar_getName(ivar))</div><div class="line">                <span class="comment">//使用KVC获取属性值，并归档</span></div><div class="line">                aCoder.encode(<span class="keyword">self</span>.value(forKey: key!), forKey: key!)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//释放ivars</span></div><div class="line">        free(ivars)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</div><div class="line">        </div><div class="line">        <span class="comment">//属性的个数</span></div><div class="line">        <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">UInt32</span> = <span class="number">0</span></div><div class="line">        <span class="comment">//获取属性列表，inout属性的个数</span></div><div class="line">        <span class="keyword">let</span> ivars = class_copyIvarList(<span class="type">Person</span>.<span class="keyword">self</span>, &amp;<span class="built_in">count</span>)</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; <span class="built_in">count</span> &#123;</div><div class="line">            <span class="comment">//取出属性</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> ivar = ivars?[<span class="type">Int</span>(i)] &#123;</div><div class="line">                <span class="comment">//获取属性名</span></div><div class="line">                <span class="keyword">let</span> key = <span class="type">String</span>(utf8String: ivar_getName(ivar))</div><div class="line">                <span class="comment">//解档</span></div><div class="line">                <span class="keyword">let</span> value = aDecoder.decodeObject(forKey: key!)</div><div class="line">                <span class="comment">//使用KVC传值</span></div><div class="line">                <span class="keyword">self</span>.setValue(value, forKey: key!)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//释放ivars</span></div><div class="line">        free(ivars)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们使用归解档，属性很多或者结构很复杂时，会产生很多的重复代码，这时就可以通过 Runtime 来获取类的属性列表，属性名，属性数量等，再通过 KVC 完成取值和赋值，大大简化了这一步骤。</p>
<p>下面是使用方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">save</span><span class="params">(<span class="number">_</span> sender: AnyObject)</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> <span class="built_in">max</span> = <span class="type">Person</span>(name: <span class="string">"Max"</span>, age: <span class="number">100</span>)</div><div class="line">    <span class="keyword">let</span> <span class="built_in">min</span> = <span class="type">Person</span>(name: <span class="string">"Min"</span>, age: <span class="number">0</span>)</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> result = <span class="type">NSKeyedArchiver</span>.archiveRootObject([<span class="built_in">max</span>, <span class="built_in">min</span>], toFile: filePath!)</div><div class="line">    <span class="built_in">print</span>(<span class="string">"result:"</span>, result, <span class="string">"filePath:"</span>, filePath)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(<span class="number">_</span> sender: AnyObject)</span></span> &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> arr = <span class="type">NSKeyedUnarchiver</span>.unarchiveObject(withFile: filePath!) <span class="keyword">as</span>! [<span class="type">Person</span>]</div><div class="line">    <span class="keyword">let</span> <span class="built_in">max</span> = arr.first</div><div class="line">    <span class="keyword">let</span> <span class="built_in">min</span> = arr.last</div><div class="line">    </div><div class="line">    <span class="built_in">print</span>(<span class="built_in">max</span>?.name, <span class="built_in">min</span>?.name)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Runtime 还有很多强大的方法，不仅仅是针对 Class，还有 Method、SEL、Protocol等，我们以后再讲。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Runtime 是 iOS 开发中的知名黑魔法，充分体现了 Objective - C 的动态运行时特性，Swift 是一门静态语言，这意味着代码编译时即确定了其实际调用的方法和类型，所以纯粹的 Swift 类和对象没有办法使用 Runtime，更不存在 Method swizzling，但是呢，Swift 是兼容 Objective - C 的，继承自 NSObject 的类，也就具有了运行时的消息机制。&lt;/p&gt;
&lt;p&gt;纯粹的 Swift 类，也可以通过添加 &lt;code&gt;@objc&lt;/code&gt; 修饰符， &lt;code&gt;@objc&lt;/code&gt; 关键字只需要对那些不是继承自 &lt;code&gt;NSObject&lt;/code&gt; 的类型进行，如果 class 是继承自 &lt;code&gt;NSObject&lt;/code&gt; 的话，Swift 会默认自动为所有的非 private 的类和成员加上 &lt;code&gt;@objc&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt; &lt;code&gt;@objc&lt;/code&gt; 修饰符主要用于需要暴露给 Objective-C 使用的任何地方 (包括类，属性和方法等) ，以支持其动态派发和运行时机制。&lt;/p&gt;
&lt;p&gt;添加 &lt;code&gt;@objc&lt;/code&gt; 修饰符并不意味着这个方法或者属性会变成动态派发，Swift 依然可能会将其优化为静态调用。如果需要施展一些像 Method swizzling 或者运行时再决定实现这样的 “黑魔法” 的时候，我们就必须用到 &lt;code&gt;dynamic&lt;/code&gt; 修饰符了。 &lt;code&gt;dynamic&lt;/code&gt; 修饰符会隐式的添加 &lt;code&gt;@objc&lt;/code&gt; 进行修饰。&lt;/p&gt;
&lt;p&gt;也就是说，需要 Swift 和 Objective 混合开发时，使用 &lt;code&gt;@objc&lt;/code&gt; 就可以了，需要 Swift 完全实现运行时机制时，那么必须要添加 &lt;code&gt;dynamic&lt;/code&gt; 修饰符。&lt;/p&gt;
&lt;p&gt;下面我们通过优化归解档，来了解 Runtime 在 Swift 中的应用：&lt;/p&gt;
    
    </summary>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/Runtime/"/>
    
    
      <category term="Runtime" scheme="http://yoursite.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式 - KVC内部机制&amp;使用场景</title>
    <link href="http://yoursite.com/2016/12/21/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20KVC%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2016/12/21/iOS设计模式 - KVC内部机制/</id>
    <published>2016-12-20T18:24:00.000Z</published>
    <updated>2017-01-24T15:46:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两天面试在KVC的问题上有所欠缺，对于底层了解不够，因此写下这篇文章。这篇文章主要是使用KVC对Key的搜索原理，自己写代码来实现KVC。</p>
<p>关于Apple是如何实现KVC这个问题：</p>
<blockquote>
<p>🙃 🙃 我也不知道…… </p>
</blockquote>
<p>因为没有办法打印出调用过的函数，所以KVC背后的一切还是很神秘的，只能通过几个有限的API来猜想，</p>
<p>对于<code>setValue:forKey:</code> ，在setter存在的情况，KVC 会直接发送<code>set&lt;Key&gt;:</code> 消息赋值；</p>
<p>在setter不在的情况下，且<code>accessInstanceVariablesDirectly</code>方法是true的情况下，会按<code>（_&lt;key&gt;, _&lt;isKey&gt;, &lt;key&gt;, is&lt;Key&gt;）</code>的顺序去查找实例变量，检查其是否存在之后通过<code>object_setIvar</code>给它赋值。</p>
<p>如果都没有就调用<code>setValue:forUNdefinedKey:</code>抛出错误。</p>
<p>对于<code>setValue:forKeyPath:</code>，递归地检查keyPath中的属性是否存在，到达目标路径时再调用<code>setValue:forKey:</code> 完成赋值。</p>
<p>大致上我准备按上面的执行顺序进行实现，由于集合、字典和模型、KeyPath的情况比较复杂，所以我只实现了最普通的存值和取值，下面进入正题：</p>
   <a id="more"></a>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MyError</span>: <span class="title">ErrorType</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">NotExist</span></div><div class="line">    <span class="keyword">case</span> <span class="type">NotNSObjectType</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSObject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setMyValue</span><span class="params">(value value: AnyObject?, forKey key: String?)</span></span> <span class="keyword">throws</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">/**判断Key是否是空值*/</span></div><div class="line">        <span class="keyword">if</span> key!.isEmpty &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="type">MyError</span>.<span class="type">NotExist</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**判断Value是否是空值*/</span></div><div class="line">        <span class="keyword">if</span> value == <span class="literal">nil</span>  &#123;</div><div class="line">            <span class="keyword">self</span>.setMyNilValue(key!)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**判断Value是否是NSObject类型*/</span></div><div class="line">        <span class="keyword">if</span> !(value <span class="keyword">is</span> <span class="type">NSObject</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="type">MyError</span>.<span class="type">NotNSObjectType</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**判断是否存在setKey方法，如果有执行这个方法*/</span></div><div class="line">        <span class="keyword">let</span> funcName = <span class="string">"set"</span> + (key?.capitalizedString)! + <span class="string">":"</span></div><div class="line">        </div><div class="line">        <span class="keyword">let</span> selector = <span class="type">NSSelectorFromString</span>(funcName)</div><div class="line">        <span class="comment">//let selector = Selector.init(funcName)</span></div><div class="line">        <span class="comment">//let selector = #selector(Address.setCity(_:))</span></div><div class="line">        <span class="comment">//print(self.respondsToSelector(selector))</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.respondsToSelector(selector)&#123;</div><div class="line">            <span class="keyword">self</span>.performSelector((selector), withObject: value)</div><div class="line">            <span class="comment">//print("执行setKey方法")</span></div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/**判断该类中是否存在 key、_key、iskey成员，如果有给这个成员赋值*/</span></div><div class="line">        <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">UInt32</span> = <span class="number">0</span></div><div class="line">        <span class="keyword">var</span> flag: <span class="type">Bool</span> = <span class="literal">false</span></div><div class="line">        <span class="keyword">let</span> iVars = class_copyIvarList(<span class="keyword">self</span>.<span class="keyword">dynamicType</span>, &amp;<span class="built_in">count</span>)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</div><div class="line">            <span class="keyword">let</span> iVar = iVars[<span class="type">Int</span>(i)]</div><div class="line">            <span class="keyword">let</span> keyName = <span class="type">NSString</span>(<span class="type">CString</span>: ivar_getName(iVar), encoding: <span class="type">NSUTF8StringEncoding</span>)</div><div class="line">            <span class="keyword">if</span> keyName == key! || keyName == <span class="string">"_"</span> + key! || keyName == <span class="string">"is"</span> + key!&#123;</div><div class="line">                flag = <span class="literal">true</span></div><div class="line">                </div><div class="line">                object_setIvar(<span class="keyword">self</span>, iVar, value)</div><div class="line">                <span class="comment">//print("\(self) \(iVar) \(value)")</span></div><div class="line">                <span class="comment">//print("给\(keyName)赋值")</span></div><div class="line">                <span class="keyword">break</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/**如果以上的成员和方法都不存在，调用未找到key的方法*/</span></div><div class="line">        <span class="keyword">if</span> !flag &#123;</div><div class="line">            <span class="keyword">self</span>.setMyValue(value!, forUndefinedKey: key!)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setMyNilValue</span><span class="params">(key: String?)</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"无法修改<span class="subst">\(key)</span>的值，因为传入的是空值"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setMyValue</span><span class="params">(value: AnyObject, forUndefinedKey key: String)</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"无法将<span class="subst">\(key)</span>的值修改为，因为传入的是空值"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myValueForKey</span><span class="params">(key: String?)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">AnyObject</span>? &#123;</div><div class="line">        </div><div class="line">        <span class="comment">/**判断Key是否是空值*/</span></div><div class="line">        <span class="keyword">if</span> key!.isEmpty &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="type">MyError</span>.<span class="type">NotExist</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**判断是否存在getKey方法，如果有执行这个方法*/</span></div><div class="line">        <span class="keyword">let</span> funcName = <span class="string">"get"</span> + (key?.capitalizedString)! + <span class="string">":"</span></div><div class="line">        <span class="keyword">let</span> selector = <span class="type">NSSelectorFromString</span>(funcName)</div><div class="line">        <span class="comment">//let selector = Selector.init(funcName)</span></div><div class="line">        <span class="comment">//let selector = #selector(Address.setCity(_:))</span></div><div class="line">        <span class="comment">//print(self.respondsToSelector(selector))</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.respondsToSelector(selector)&#123;</div><div class="line">            <span class="keyword">let</span> result =  <span class="keyword">self</span>.performSelector(selector)</div><div class="line">            <span class="comment">//print("执行getKey方法")</span></div><div class="line">            <span class="keyword">return</span> result <span class="keyword">as</span>? <span class="type">AnyObject</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/**判断该类中是否存在 key、_key、iskey成员，如果有给这个成员赋值*/</span></div><div class="line">        <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">UInt32</span> = <span class="number">0</span></div><div class="line">        <span class="keyword">var</span> flag: <span class="type">Bool</span> = <span class="literal">false</span></div><div class="line">        <span class="keyword">let</span> iVars = class_copyIvarList(<span class="keyword">self</span>.<span class="keyword">dynamicType</span>, &amp;<span class="built_in">count</span>)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</div><div class="line">            <span class="keyword">let</span> iVar = iVars[<span class="type">Int</span>(i)]</div><div class="line">            <span class="keyword">let</span> keyName = <span class="type">NSString</span>(<span class="type">CString</span>: ivar_getName(iVar), encoding: <span class="type">NSUTF8StringEncoding</span>)</div><div class="line">            <span class="keyword">if</span> keyName == key! || keyName == <span class="string">"_"</span> + key! || keyName == <span class="string">"is"</span> + key!&#123;</div><div class="line">                flag = <span class="literal">true</span></div><div class="line">                <span class="built_in">print</span>(<span class="string">"取出<span class="subst">\(keyName)</span>的值"</span>)</div><div class="line">                <span class="comment">//print("\(self) \(iVar) \(value)")</span></div><div class="line">                <span class="keyword">return</span> object_getIvar(<span class="keyword">self</span>, iVar)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/**如果以上的成员和方法都不存在，调用未找到key的方法*/</span></div><div class="line">        <span class="keyword">if</span> !flag &#123;</div><div class="line">            <span class="keyword">self</span>.myValueForUndefinedKey(key!)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myValueForUndefinedKey</span><span class="params">(key: String)</span></span> -&gt; <span class="type">AnyObject</span>?&#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"无法取出<span class="subst">\(key)</span>的值，因为属性不存在"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**执行*/</span></div><div class="line"><span class="keyword">let</span> add = <span class="type">Address</span>()</div><div class="line"></div><div class="line">add._country = <span class="string">"China"</span></div><div class="line">add._province = <span class="string">"HeBei"</span></div><div class="line">add._city = <span class="string">"ShiJiaZhuang"</span></div><div class="line">add._province = <span class="string">"ChangAnQu"</span></div><div class="line"></div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">try</span> add.setMyValue(value: <span class="string">"BeiJing"</span>, forKey: <span class="string">"city"</span>)</div><div class="line">    <span class="keyword">try</span> add.setMyValue(value: <span class="string">"USA"</span>, forKey: <span class="string">"country"</span>)</div><div class="line">    <span class="keyword">try</span> add.setMyValue(value: <span class="string">"South"</span>, forKey: <span class="string">""</span>)</div><div class="line">    <span class="keyword">try</span> add.setMyValue(value: <span class="string">"300169"</span>, forKey: <span class="string">"postCode"</span>)</div><div class="line">    <span class="built_in">print</span>(<span class="string">"country:<span class="subst">\(add._country)</span> city:<span class="subst">\(add._city)</span> province:<span class="subst">\(add._province)</span> district<span class="subst">\(add._district)</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> <span class="type">MyError</span>.<span class="type">NotExist</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"key是空的"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> <span class="type">MyError</span>.<span class="type">NotNSObjectType</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"value不是NSObject类型"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"传值出错"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">let</span> country = <span class="keyword">try</span> add.myValueForKey(<span class="string">"country"</span>)</div><div class="line">    <span class="keyword">let</span> city = <span class="keyword">try</span> add.myValueForKey(<span class="string">"city"</span>)</div><div class="line">    <span class="built_in">print</span>(<span class="string">"----------------/n <span class="subst">\(country)</span> <span class="subst">\(city)</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> <span class="type">MyError</span>.<span class="type">NotExist</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"key是空的"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"取值出错"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是根据KVC执行顺序自定义的一段代码，当然也省略了一些功能，总体上的逻辑还是比较清楚的，但是有一点问题，在使用<code>object_setIvar</code>和<code>object_getIvar</code>这两个runtime函数时，程序会频繁崩溃，而自己对runtime认识不足，以后再完整这段代码吧。</p>
<p>关于KVC，除去存取方法，底层执行顺序，错误处理以外，还有几点需要了解：</p>
<h2 id="Value合法性校验"><a href="#Value合法性校验" class="headerlink" title="Value合法性校验"></a>Value合法性校验</h2><p>KVC提供了校验key对应的value是否合法的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">validateValue</span><span class="params">(ioValue: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, forKey inKey: String)</span></span> <span class="keyword">throws</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">validateValue</span><span class="params">(ioValue: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, forKeyPath inKeyPath: String)</span></span> <span class="keyword">throws</span></div></pre></td></tr></table></figure>
<p>如果使用这个方法，需要进行重写，它的使用方法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> _country: <span class="type">String</span>?</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">validateValue</span><span class="params">(ioValue: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, forKey inKey: String)</span></span> <span class="keyword">throws</span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> country = ioValue.memory <span class="keyword">as</span>! <span class="type">String</span></div><div class="line">        <span class="keyword">if</span> country == <span class="string">"Janpan"</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="type">MyError</span>.<span class="type">NotExist</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="type">MyError</span>.<span class="type">Nothing</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**执行*/</span></div><div class="line"><span class="keyword">let</span> add = <span class="type">Address</span>()</div><div class="line"><span class="keyword">var</span> value: <span class="type">AnyObject</span>? = <span class="string">"Janpan"</span></div><div class="line"></div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">try</span> add.validateValue(&amp;value, forKey: <span class="string">"_country"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> <span class="type">MyError</span>.<span class="type">NotExist</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"输入有误，请重新输入"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> <span class="type">MyError</span>.<span class="type">Nothing</span> &#123;</div><div class="line">    add.setValue(value, forKey: <span class="string">"_country"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> &#123;&#125;</div><div class="line"><span class="built_in">print</span>(add._country)</div><div class="line"></div><div class="line"><span class="comment">/**当 var value: AnyObject? = "Janpan" 时输出*/</span></div><div class="line">输入有误，请重新输入</div><div class="line"><span class="literal">nil</span></div><div class="line"><span class="comment">/**当 var value: AnyObject? = "Chain" 时输出*/</span></div><div class="line"><span class="type">Optional</span>(<span class="string">"China"</span>)</div></pre></td></tr></table></figure>
<p>这样就实现了先对传入值的合法性进行校验，无误后再进行赋值，如上面的代码，当我们需要验证能不能用KVC设定某个值时，可以将其重写后调用</p>
<blockquote>
<p><code>validateValue: forKey:</code></p>
</blockquote>
<p>这个方法来验证，那么KVC就会直接调用这个方法来返回。<strong>需要注意的是即使重写了该方法，如果我们没有主动进行调用，KVC也不会主动去做验证，所以这个方法需要手动调用。</strong></p>
<h2 id="KVC的应用场景"><a href="#KVC的应用场景" class="headerlink" title="KVC的应用场景"></a>KVC的应用场景</h2><p>作为iOS平台的知名黑魔法，KVC有很多奇特的作用，KVC在iOS开发中是绝不可少的利器，这种基于运行时的编程方式极大地提高了灵活性，简化了代码，它的常见作用有以下几点：</p>
<h2 id="动态的存值和取值"><a href="#动态的存值和取值" class="headerlink" title="动态的存值和取值"></a>动态的存值和取值</h2><p>🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 🙃 </p>
<h2 id="访问和修改私有的成员"><a href="#访问和修改私有的成员" class="headerlink" title="访问和修改私有的成员"></a>访问和修改私有的成员</h2><p>对于类里的私有属性，无论Swift还是Objective-C都是无法直接访问的，但是KVC是可以的。</p>
<h2 id="Model和字典的互相转换"><a href="#Model和字典的互相转换" class="headerlink" title="Model和字典的互相转换"></a>Model和字典的互相转换</h2><p>这是KVC又一个强大之处，只需要很少的代码量即可完成很多功能。</p>
<h2 id="修改控件的内部属性"><a href="#修改控件的内部属性" class="headerlink" title="修改控件的内部属性"></a>修改控件的内部属性</h2><p>这也是iOS开发中必不可少的小技巧。众所周知很多UI控件都由很多内部UI控件组合而成的，但是Apple没有提供这访问这些控件的API，这样我们就无法正常地访问和修改这些控件的样式。</p>
<p>而KVC在大多数情况可下可以解决这个问题。比如个性化UITextField中的placeHolderText，一般情况下可以运用runtime来获取Apple不想开放的属性名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**执行*/</span></div><div class="line"><span class="keyword">let</span> <span class="built_in">count</span>:<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">UInt32</span>&gt; =  <span class="literal">nil</span></div><div class="line"><span class="keyword">var</span> properties = class_copyIvarList(<span class="type">UITextField</span>.<span class="keyword">self</span>, <span class="built_in">count</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span> properties.memory.debugDescription !=  <span class="string">"0x0000000000000000"</span>&#123;</div><div class="line">    <span class="keyword">let</span> t = ivar_getName(properties.memory)</div><div class="line">    <span class="keyword">let</span> n = <span class="type">NSString</span>(<span class="type">CString</span>: t, encoding: <span class="type">NSUTF8StringEncoding</span>)</div><div class="line">    <span class="built_in">print</span>(n)</div><div class="line">    properties = properties.successor()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**输出*/</span></div><div class="line">......</div><div class="line"><span class="type">Optional</span>(_background)</div><div class="line"><span class="type">Optional</span>(_disabledBackground)</div><div class="line"><span class="type">Optional</span>(_clearButtonMode)</div><div class="line"><span class="type">Optional</span>(_leftView)</div><div class="line"><span class="type">Optional</span>(_leftViewMode)</div><div class="line"><span class="type">Optional</span>(_rightView)</div><div class="line"><span class="type">Optional</span>(_rightViewMode)</div><div class="line"><span class="type">Optional</span>(_traits)</div><div class="line"><span class="type">Optional</span>(_nonAtomTraits)</div><div class="line"><span class="type">Optional</span>(_fullFontSize)</div><div class="line"><span class="type">Optional</span>(_padding)</div><div class="line"><span class="type">Optional</span>(_selectionRangeWhenNotEditing)</div><div class="line">......</div></pre></td></tr></table></figure>
<p>可以从里面看到其他还有很多东西可以修改，运用KVC设值可以获得自己想要的效果。</p>
<h2 id="KVC操作集合"><a href="#KVC操作集合" class="headerlink" title="KVC操作集合"></a>KVC操作集合</h2><p>Apple对KVC的<code>valueForKey:</code>方法作了一些特殊的实现，比如说NSArray和NSSet这样的容器类就实现了这些方法，所以可以用KVC很方便地操作集合。</p>
<h3 id="高阶信息传递"><a href="#高阶信息传递" class="headerlink" title="高阶信息传递"></a>高阶信息传递</h3><p>当对容器类使用KVC时，<code>valueForKey:</code>将会被传递给容器中的每一个对象，而不是容器本身进行操作。结果会被添加进返回的容器中，这样，开发者可以很方便的操作集合来返回另一个集合：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**执行*/</span></div><div class="line"><span class="keyword">let</span> arrStr: <span class="type">NSArray</span> = [<span class="string">"english"</span>, <span class="string">"franch"</span>, <span class="string">"chinese"</span>]</div><div class="line"><span class="keyword">let</span> arrCapStr = arrStr.value(forKey: <span class="string">"capitalizedString"</span>)</div><div class="line"><span class="built_in">print</span>(arrCapStr <span class="keyword">as</span>! <span class="type">NSArray</span>)</div><div class="line"></div><div class="line"><span class="keyword">let</span> arrStrLength = arrStr.value(forKeyPath: <span class="string">"capitalizedString.length"</span>)</div><div class="line"><span class="built_in">print</span>(arrStrLength! <span class="keyword">as</span>! <span class="type">NSArray</span>)</div><div class="line"></div><div class="line"><span class="comment">/**输出*/</span></div><div class="line">(</div><div class="line">    <span class="type">English</span>,</div><div class="line">    <span class="type">Franch</span>,</div><div class="line">    <span class="type">Chinese</span></div><div class="line">)</div><div class="line">(</div><div class="line">    <span class="number">7</span>,</div><div class="line">    <span class="number">6</span>,</div><div class="line">    <span class="number">7</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>方法<code>capitalizedString</code>被传递到NSArray中的每一项，这样，NSArray的每一员都会执行<code>capitalizedString</code>并返回一个包含结果的新的NSArray。从打印结果可以看出，所有String都成功以转成了大写。<br>同样如果要执行多个方法也可以用<code>valueForKeyPath:</code>方法。它先会对每一个成员调用 <code>capitalizedString</code>方法，然后再调用length，因为lenth方法返回是一个数字，所以返回结果以NSNumber的形式保存在新数组里。</p>
<h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p>当然了，KVC除了传值取值，访问和修改私有变量，修改控件属性，操作集合、字典和模型，更重要的就是KVO了。</p>
<h2 id="Demo下载请点击这里"><a href="#Demo下载请点击这里" class="headerlink" title="Demo下载请点击这里"></a>Demo下载请<a href="https://github.com/tianziyao/MyCustomKVC" target="_blank" rel="external">点击这里</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天面试在KVC的问题上有所欠缺，对于底层了解不够，因此写下这篇文章。这篇文章主要是使用KVC对Key的搜索原理，自己写代码来实现KVC。&lt;/p&gt;
&lt;p&gt;关于Apple是如何实现KVC这个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙃 🙃 我也不知道…… &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为没有办法打印出调用过的函数，所以KVC背后的一切还是很神秘的，只能通过几个有限的API来猜想，&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;setValue:forKey:&lt;/code&gt; ，在setter存在的情况，KVC 会直接发送&lt;code&gt;set&amp;lt;Key&amp;gt;:&lt;/code&gt; 消息赋值；&lt;/p&gt;
&lt;p&gt;在setter不在的情况下，且&lt;code&gt;accessInstanceVariablesDirectly&lt;/code&gt;方法是true的情况下，会按&lt;code&gt;（_&amp;lt;key&amp;gt;, _&amp;lt;isKey&amp;gt;, &amp;lt;key&amp;gt;, is&amp;lt;Key&amp;gt;）&lt;/code&gt;的顺序去查找实例变量，检查其是否存在之后通过&lt;code&gt;object_setIvar&lt;/code&gt;给它赋值。&lt;/p&gt;
&lt;p&gt;如果都没有就调用&lt;code&gt;setValue:forUNdefinedKey:&lt;/code&gt;抛出错误。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;setValue:forKeyPath:&lt;/code&gt;，递归地检查keyPath中的属性是否存在，到达目标路径时再调用&lt;code&gt;setValue:forKey:&lt;/code&gt; 完成赋值。&lt;/p&gt;
&lt;p&gt;大致上我准备按上面的执行顺序进行实现，由于集合、字典和模型、KeyPath的情况比较复杂，所以我只实现了最普通的存值和取值，下面进入正题：&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="KVC" scheme="http://yoursite.com/tags/KVC/"/>
    
  </entry>
  
  <entry>
    <title>Xcode错误 - Plist和转义符「/」</title>
    <link href="http://yoursite.com/2016/11/26/Plist%20%E5%92%8C%E8%BD%AC%E4%B9%89%E7%AC%A6/"/>
    <id>http://yoursite.com/2016/11/26/Plist 和转义符/</id>
    <published>2016-11-25T18:24:00.000Z</published>
    <updated>2017-01-24T15:58:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两天遇到一个 Plist 和转义符的问题，这个问题我翻了 Google 十几页，但是并没有找到解决的方法，也没有找到关于这个问题的描述，因此我想先记录下来，如果有人和我遇到同样的问题，可以知道结果是怎样的。</p>
<p>当然，由于我的才疏学浅，我没能解决不一定大家都不能解决，如果你有解决的思路，欢迎邮件我啊！</p>
<p><strong>如果不想看过程，可以直接翻到最下面看验证的结果</strong>。</p>
<p>问题是这样的，我创建了一个 Plist 文件，希望用来存储用户的设置选项，遇到的第一个坑是 KVC 不支持 Bool 类型，这个是我没想起了，使用 0 和 1 来替代解决了，现在要讲的是第二个坑。</p>
<p>因为我在项目中使用了字体图标，它类似 Emoji 表情：使用 Unicode 编码，获取特定的图标。在其他的页面中，我使用了全局变量 + UILabel 转 UIImage 的方式，获取并使用字体图标，代码如下：</p>
   <a id="more"></a>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> settingIconCode = <span class="string">"\u&#123;e702&#125;"</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">image</span>(<span class="title">withIconCode</span> <span class="title">iconCode</span>: <span class="title">String</span>, <span class="title">fontName</span>: <span class="title">String</span>, <span class="title">size</span>: <span class="title">CGFloat</span>, <span class="title">color</span>: <span class="title">UIColor</span>?) -&gt; <span class="title">UIImage</span>? </span>&#123;</div><div class="line">                </div><div class="line">        <span class="keyword">let</span> imageSize = <span class="type">CGSize</span>(width: size, height: size)</div><div class="line">        <span class="type">UIGraphicsBeginImageContextWithOptions</span>(imageSize, <span class="literal">false</span>, <span class="type">UIScreen</span>.main.scale)</div><div class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: size, height: size))</div><div class="line">        label.font = <span class="type">UIFont</span>(name: fontName, size: size)</div><div class="line">        label.text = iconCode</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (color != <span class="literal">nil</span>) &#123;</div><div class="line">            label.textColor = color</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            label.textColor = <span class="type">UIColor</span>.white</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        label.layer.render(<span class="keyword">in</span>: <span class="type">UIGraphicsGetCurrentContext</span>()!)</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> image = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>() &#123;</div><div class="line">            <span class="keyword">return</span> image</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"绘制失败"</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我写到设置页面时，决定用 Plist 作为本地化存储的方案，因此我创建了一个 Plist 文件，然后每个 Item 包含以下 4 个属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 设置项名称</span></div><div class="line"><span class="keyword">var</span> name: <span class="type">String</span>!</div><div class="line"><span class="comment">/// 设置项图标</span></div><div class="line"><span class="keyword">var</span> iconCode: <span class="type">String</span>!</div><div class="line"><span class="comment">/// 是否显示 Switch 控件</span></div><div class="line"><span class="keyword">var</span> switchHide: <span class="type">String</span>!</div><div class="line"><span class="comment">/// 设置项状态</span></div><div class="line"><span class="keyword">var</span> state: <span class="type">String</span>!</div></pre></td></tr></table></figure>
<p>讲道理这时我已经可以转模型然后在 Cell 里面使用了，但是在我使用上面写的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">image</span>(<span class="title">withIconCode</span> <span class="title">iconCode</span>: <span class="title">String</span>, <span class="title">fontName</span>: <span class="title">String</span>, <span class="title">size</span>: <span class="title">CGFloat</span>, <span class="title">color</span>: <span class="title">UIColor</span>?) -&gt; <span class="title">UIImage</span>?</span></div></pre></td></tr></table></figure>
<p>发现这个方法失效了，返回的是 <code>…</code> 图片，而不是应该获取的字体图标，这个省略号自然是因为超出 <code>UILabel</code> 的显示范围形成的，下面为了叙述方便，我用 <code>\u{e702}</code> 来代入。</p>
<p>之前我的全局变量 <code>settingIconCode</code> ，传入到 <code>imageWithIconCode</code> 方法时没有问题，但是将 <code>\u{e702}</code> 写在 Plist 中赋值给 <code>iconCode</code>，再转为模型后出错，于是我打印了 <code>iconCode</code> 参数，结果和我预期是一样的 <code>\u{e702}</code>，然后我将 <code>iconCode</code> 和 <code>\u{e702}</code> 一起打印，输出结果如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(<span class="string">"\u&#123;e702&#125;"</span>, iconCode)		<span class="comment">//？ \u&#123;e702&#125;</span></div></pre></td></tr></table></figure>
<p>这说明两者虽然都是 String 类型，Value 看起来也一样，但是并不是同一个东西，于是我想到<strong>会不会是因为 <code>\u{e702}</code> 是经过转换的 String，而 <code>iconCode</code> 是单纯的 String？</strong></p>
<p>我们知道，<code>\u{e702}</code> 等同于 <code>U+\e702</code> ，也就是 16 进制的 <code>e702</code> ，因此我在 Plist 中，将 <code>iconCode</code> 修改为 16 进制的 <code>0x1E702</code> ，然后我通过 <code>\u{\(iconCode)}</code> 进行转换，但是出错了， <strong>这里的<code>{}</code> 中不允许使用 <code>\()</code>，因此不能使用字符串拼接</strong>。</p>
<p>于是我放弃了这个方法，回想是不是<strong>对象是不是被修改了</strong>，因此我找到最初读取到 Plist 的地方，打印获取的 Plist 数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> settingDicts = <span class="type">NSArray</span>(contentsOfFile: <span class="type">Bundle</span>.main.path(forResource: <span class="string">"Setting.plist"</span>, ofType: <span class="literal">nil</span>)!)</div><div class="line"><span class="built_in">print</span>(settingDicts?.firstObject)</div></pre></td></tr></table></figure>
<p>我得到的结果是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="type">Optional</span>(&#123;</div><div class="line">    iconCode = <span class="string">"\\u&#123;e702&#125;"</span>;</div><div class="line">    name = <span class="string">"\U81ea\U52a8\U5b9a\U4f4d\U5230\U6700\U8fd1\U7ad9\U70b9"</span>;</div><div class="line">    state = <span class="number">0</span>;</div><div class="line">    switchHide = <span class="number">1</span>;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>从这里可以看到，打印结果多出了一个  <code>\</code>，因此我猜想，Plist 并不能理解转义符，因此将 <code>\</code> 当做字符来处理，所以  <code>\ = \\</code>，为了验证这个猜想，我又修改了 Value 并打印，得到的结果如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iconCode = \(iconCode)		<span class="comment">//iconCode = "\\(iconCode)";</span></div><div class="line">iconCode = (iconCode)		<span class="comment">//iconCode = "(iconCode)";</span></div><div class="line">iconCode = \\(iconCode)		<span class="comment">//iconCode = "\\\\(iconCode)";</span></div></pre></td></tr></table></figure>
<p> <strong>因此我们可以得出结论，Plist 并不能理解转义符，因此会将 <code>\</code> 当做字符来处理，而不是当做转义符来处理</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天遇到一个 Plist 和转义符的问题，这个问题我翻了 Google 十几页，但是并没有找到解决的方法，也没有找到关于这个问题的描述，因此我想先记录下来，如果有人和我遇到同样的问题，可以知道结果是怎样的。&lt;/p&gt;
&lt;p&gt;当然，由于我的才疏学浅，我没能解决不一定大家都不能解决，如果你有解决的思路，欢迎邮件我啊！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果不想看过程，可以直接翻到最下面看验证的结果&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;问题是这样的，我创建了一个 Plist 文件，希望用来存储用户的设置选项，遇到的第一个坑是 KVC 不支持 Bool 类型，这个是我没想起了，使用 0 和 1 来替代解决了，现在要讲的是第二个坑。&lt;/p&gt;
&lt;p&gt;因为我在项目中使用了字体图标，它类似 Emoji 表情：使用 Unicode 编码，获取特定的图标。在其他的页面中，我使用了全局变量 + UILabel 转 UIImage 的方式，获取并使用字体图标，代码如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Xcode错误" scheme="http://yoursite.com/categories/Xcode%E9%94%99%E8%AF%AF/"/>
    
    
      <category term="Xcode错误" scheme="http://yoursite.com/tags/Xcode%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式 - Notification</title>
    <link href="http://yoursite.com/2016/11/24/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20Notification/"/>
    <id>http://yoursite.com/2016/11/24/iOS设计模式 - Notification/</id>
    <published>2016-11-23T18:24:00.000Z</published>
    <updated>2017-01-24T15:46:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 中的观察者 Observer 模式包含了通知机制（Notification）和KVO（Key-Value-Observing）机制，我们知道对象之间的通讯有以下几种常见的方式：</p>
<blockquote>
<p>Delegate、Block、KVO、Notification；</p>
</blockquote>
<p>其中 Delegate 使用的是委托机制，是一对一的对象之间的通信；而 KVO 和 Notification 通知机制是广播，也就是一对多的对象之间的通信。那么对象之间的通讯又是做什么呢？简单来说就是在 A 类中创建的方法，在 B 类中执行，且 A 类可以传递数据给 B 类，我们知道当说起通知时，有以下几种：</p>
<blockquote>
<p>本地通知、推送通知、广播通知；</p>
</blockquote>
<p>这三种通知是不同的，本地通知使用的是 <code>UILocalNotification</code> 实现，是我们的 APP 运行时，给用户的通知；推送通知是使用 <code>UIUserNotification</code> 实现，是用户同意推送后，由我们的服务器提交给 APNS，再由 APNS 转发给用户的。</p>
<p>而我们本文要探讨的是，程序中的对象与对象之间的通知，也就是最后一项，广播通知。</p>
   <a id="more"></a>
<h2 id="Notification的概念"><a href="#Notification的概念" class="headerlink" title="Notification的概念"></a>Notification的概念</h2><p>Notification 是 iOS 提供的一种同步的消息通知机制，观察者只要向消息中心注册，即可接受其他对象发送来的消息，消息发送者和接收者两者可以互相一无所知，完全解耦。</p>
<p>它是 Foundation 框架的一个子系统，它向应用程序中注册为某个事件观察者的所有对象广播消息，也就是通知。该事件可以是发生在应用程序中的任何事情，例如进入后台状态，或者用户开始在文本栏中键入。Notification 告诉观察者，事件已经发生或即将发生，因此让观察者有机会以合适的方式响应。通过通知中心来传播通知，是增加应用程序对象间合作和内聚力的一种途径。</p>
<p>虽然任何对象都可以观察通知，但要做到这一点，该对象必须注册，以接收通知。在注册时，它必须指定选择器，以确定由通知传送所调用的方法，方法签名必须只有一个参数，也就是通知对象；注册后，观察者也可以指定发布对象。Notification 可以应用于任何对象，观察者可以有多个，所以消息具有广播的性质。</p>
<p>需要注意的是，观察者向消息中心注册以后，在不需要接收消息时需要从消息中心移除，这种消息传递机制是典型的观察者模式。</p>
<p>每一个应用都有一个通知中心（Notification）实例。当应用发生某一事件时，任何对象都可以向通知中心发布通知；同时，通知的监听者监听到该通知的发布后，根据通知传入的信息（UserInfo），进行对应的操作或处理。</p>
<h2 id="NotificationCenter的使用"><a href="#NotificationCenter的使用" class="headerlink" title="NotificationCenter的使用"></a>NotificationCenter的使用</h2><p>使用通知模式主要是以下三个步骤：</p>
<ol>
<li>获取通知中心的实例并指定发布者；</li>
<li>注册成为观察者以接收发布者通知的信息；</li>
<li>当观察者不再关注该通知的信息时，可以向通知中心发送解除注册的信息，之后都不再接收到通知。</li>
</ol>
<p>通知机制常常用于在向服务器端请求数据或者提交数据的场景，在和服务器端成功交互后，需要处理服务器端返回的数据，或发送响应消息等，就需要用到通知机制。</p>
<h3 id="获取通知中心"><a href="#获取通知中心" class="headerlink" title="获取通知中心"></a>获取通知中心</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span></div></pre></td></tr></table></figure>
<p>NotificationCenter 的原理是一个观察者模式，只有通过调用静态方法 <code>default</code> 才可以获取这个通知中心的对象。它同时也是一个单例，这个对象会一直存在于一个应用的生命周期。</p>
<p>发布、注册、解除通知都需要使用<strong>通知中心</strong>，它负责协助不同对象、不同类之间的消息通信。</p>
<p>NotificationCenter 提供了一个中心化的枢纽，通过它，应用的任何部分都可以向其他部分发送通知，或者接收来自别人的通知。</p>
<p>观察者通过在通知中心进行注册，并对特定的事件注册特定的响应动作。每次这个事件发生时，如果有必要，通知中心将通知进行分发之后，所有注册这个事件的观察者都会获得通知。</p>
<h3 id="指定发布者"><a href="#指定发布者" class="headerlink" title="指定发布者"></a>指定发布者</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">post</span><span class="params">(<span class="number">_</span> notification: Notification)</span></span></div><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">post</span><span class="params">(name aName: NSNotification.Name, object anObject: Any?)</span></span></div><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">post</span><span class="params">(name aName: NSNotification.Name, object anObject: Any?, userInfo aUserInfo: [AnyHashable : Any]? = <span class="literal">nil</span>)</span></span></div></pre></td></tr></table></figure>
<p>我们可以看到，这个3个方法实际并无区别，传入的都是一个 <code>NSNotification</code> 类型，它是消息携带的载体，通过它，我们才可以把消息内容传递给观察者，它的结构如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">open <span class="class"><span class="keyword">class</span> <span class="title">NSNotification</span> : <span class="title">NSObject</span>, <span class="title">NSCopying</span>, <span class="title">NSCoding</span> </span>&#123;</div><div class="line">    open <span class="keyword">var</span> name: <span class="type">NSNotification</span>.<span class="type">Name</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    open <span class="keyword">var</span> object: <span class="type">Any</span>? &#123; <span class="keyword">get</span> &#125;</div><div class="line">    open <span class="keyword">var</span> userInfo: [<span class="type">AnyHashable</span> : <span class="type">Any</span>]? &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>name：指定消息名称；</li>
<li>object：指定发消息者；</li>
<li>userInfo：通知中用于传递参数的载体；</li>
</ul>
<p>userInfo 里的键值应该定义成字符串常量，在文档中应该清晰地注明哪个键对应哪种类型的值，因为编译器不能像针对对象那样对字典类型中的值类型进行限制。name 和 object 用来控制通知分发的作用域，开发者们应当在对象发送通知和接收通知的方式上保持一致，而且把通知的行为在公共接口文档中进行清晰的说明。</p>
<p>由于通知分发是在发送通知的线程上进行的，所以可能会需要使用：</p>
<blockquote>
<p>dispatch_async     &amp;     dispatch_get_main_queue() </p>
</blockquote>
<p>来保证通知的处理是在主线程进行，大部分情况下我们不需要考虑这点，不过还是要把这一点记在心里。</p>
<h3 id="注册观察者"><a href="#注册观察者" class="headerlink" title="注册观察者"></a>注册观察者</h3><p>各种各样的通知车水马龙地通过 NotificationCenter，然而一个通知本身不会有任何实际作用，除非有人在监听着它，传统的添加观察者的方式是使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">addObserver</span><span class="params">(<span class="number">_</span> observer: Any, selector aSelector: Selector, name aName: NSNotification.Name?, object anObject: Any?)</span></span></div></pre></td></tr></table></figure>
<p>进行注册，一个对象（通常是 self）把自己添加进去，当某个通知发出时，通知中心就会把发布者发送的通知信息，广播给注册过该通知的观察者，执行自己特定的 selector，观察者只能接收到通知中心的信息，但无法知道通知是谁投送的，这也是通知的解耦性的体现之一，它的几个参数作用如下：</p>
<ul>
<li>observer：观察者的实例，通常是 self；</li>
</ul>
<ul>
<li><p>selector：回调方法，在本类中对通知进行相应的处理；它只有一个参数, 参数就是消息对象本身, 通过这个参数回调方法可以取得消息对象的成员变量(userinfo) 用于传值注册、取消通知的代码放在哪里等操作。</p>
</li>
<li><p>object：相对于发布者的 object，如果同时设置了 name 和 object 那么只有来自特定对象的对应名称的通知才会响应。如果为 nil，那么观察者将收到任何对象发出的通知消息；</p>
</li>
<li><p>name：相对于发布者的 name，如果设置了 name，那么只有对应名称的通知会触发。如果为 nil，那么观察者将接收到 object 对象的所有消息，但是无法确定接收这些消息的顺序；</p>
</li>
<li><p>如果 name 和 object 都为 nil，那么该观察者将收到所有对象的所有消息。</p>
</li>
</ul>
<p>需要注意的有两点：</p>
<ol>
<li><p>对于一个任意的观察者observer，如果不能保证其对应的selector有本类自定义的方法，可采用：</p>
<blockquote>
<p>observer.responds(to: NSSelectorFromString(“myFunc:”)) </p>
</blockquote>
<p>进行检查，判断其方法确实存在后再进行注册。</p>
</li>
<li><p>控制好我们的代码！一个普通的 iOS 应用在启动之后的几秒钟内就会发出几十个通知，其中的大部分我们可能都没有听说过，也不需要去关心。</p>
</li>
</ol>
<h4 id="Notification-Block"><a href="#Notification-Block" class="headerlink" title="Notification Block"></a>Notification Block</h4><p>现代的基于 block 的用于添加通知观察者的 API 是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">addObserver</span><span class="params">(forName name: NSNotification.Name?, object obj: Any?, queue: OperationQueue?, using block: @escaping <span class="params">(Notification)</span></span></span> -&gt; <span class="type">Swift</span>.<span class="type">Void</span>) -&gt; <span class="type">NSObjectProtocol</span></div></pre></td></tr></table></figure>
<p>它是 iOS 4.0之后，Apple 又提供了一个以 block 方式实现的添加观察者的方法，与前面提到的把一个已有的对象注册成观察者不同，这个方法创建一个匿名对象作为观察者。</p>
<p>当收到对应的通知时，它在指定的队列（如果队列参数为 nil 的话就在调用者的线程）里执行一个 block。另外一点和基于 selector 的方法不同的是，这个方法会返回构造出的观察者对象，此方法需要考虑 block 的循环引用问题，并不经常用到。</p>
<h3 id="移除观察者"><a href="#移除观察者" class="headerlink" title="移除观察者"></a>移除观察者</h3><p>由于通知中心不会 retain 观察者对象，因此注册过的对象必须在释放之前注销掉，如果不这样的话，当该通知再次出现时，通知中心会向已释放的观察者对象发送消息，从而导致应用崩溃。</p>
<p>在 ARC 下，系统会自动回收无用的通知对象内存，但是由于系统回收机制 ARC 有一定的延迟性，所以即使不会出错，也建议养成习惯，对无用的通知进行手动释放。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">removeObserver</span><span class="params">(<span class="number">_</span> observer: Any)</span></span>	</div><div class="line"><span class="comment">//释放所有的通知</span></div><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">removeObserver</span><span class="params">(<span class="number">_</span> observer: Any, name aName: NSNotification.Name?, object anObject: Any?)</span></span></div><div class="line"><span class="comment">//释放指定 name 或 object 的通知</span></div></pre></td></tr></table></figure>
<p>一般我们在对象的析构函数中将通知移除，我们可以选择将这个对象中的所有通知移除，也可以选择一个一个按照通知的 name 来移除，移除的时机和事件有关，如果是和视图相关的，比如键盘、UI事件等，可以使用：</p>
<blockquote>
<p>viewWillAppear    &amp;    viewWillDisappear</p>
</blockquote>
<p>如果是和 ViewController 相关的，比如和网络、异步IO等相关的通知，可以使用：</p>
<blockquote>
<p>viewDidLoad        &amp;    dealloc</p>
</blockquote>
<h2 id="KVO-NotificationCenter"><a href="#KVO-NotificationCenter" class="headerlink" title="KVO != NotificationCenter"></a>KVO != NotificationCenter</h2><p>有一点经常让我们犯糊涂，NotificationCenter 的方法签名和 Key-Value Observing 非常相似。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">addObserver</span><span class="params">(<span class="number">_</span> observer: Any, selector aSelector: Selector, name aName: NSNotification.Name?, object anObject: Any?)</span></span></div><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">addObserver</span><span class="params">(<span class="number">_</span> observer: NSObject, forKeyPath keyPath: String, options: NSKeyValueObservingOptions = [], context: UnsafeMutableRawPointer?)</span></span></div></pre></td></tr></table></figure>
<p><strong>Key-Value Observing 是在 keypaths 上添加观察者，而 NotificationCenter 是在通知上添加观察者。</strong>牢记这个区别，就可以自信地去使用这两套 API 了。</p>
<h2 id="Notification的栗子"><a href="#Notification的栗子" class="headerlink" title="Notification的栗子"></a>Notification的栗子</h2><blockquote>
<p>Talk is cheap. Show me the code.</p>
</blockquote>
<p>上面我们撸完概念，下面开始撸代码了，我们要做两个页面，在第二个页面中输入文字，在第一个页面中展示输入的文字。首先我们创建一个视图 FirstVC，添加一个 Label 属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> observerLabel: <span class="type">UILabel</span>!</div></pre></td></tr></table></figure>
<p>然后创建一个方法，在我们获得通知时，更新 Label 的文字：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">upDataForLabel</span><span class="params">(notification: NSNotification)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> dict = notification.userInfo!</div><div class="line">    <span class="keyword">let</span> str = dict[<span class="string">"toFirstVCLabel"</span>]</div><div class="line">    observerLabel.text = str <span class="keyword">as</span>? <span class="type">String</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 viewDidLoad 方法中，我们将 FirstVC 自己注册为观察者：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">    <span class="keyword">let</span> selector = <span class="type">NSSelectorFromString</span>(<span class="string">"upDataForLabelWithNotification:"</span>)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.responds(to: selector) &#123;</div><div class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>,</div><div class="line">                                               selector: selector,</div><div class="line">                                               name: <span class="type">NSNotification</span>.<span class="type">Name</span>(rawValue: <span class="string">"upDataForLabel"</span>),</div><div class="line">                                               object: <span class="literal">nil</span>)</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们创建第二个页面：SecondVC，添加一个 UITextField 用于用户输入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> posterTextField: <span class="type">UITextField</span>!</div></pre></td></tr></table></figure>
<p>添加一个 Button，点击时返回到 FirstVC，并且发送消息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">saveAndJumpButtonDidTouch</span><span class="params">(<span class="number">_</span> sender: AnyObject)</span></span> &#123;</div><div class="line">    <span class="keyword">self</span>.dismiss(animated: <span class="literal">true</span>) &#123; </div><div class="line">        <span class="keyword">let</span> str = <span class="keyword">self</span>.posterTextField.text</div><div class="line">        <span class="keyword">let</span> notification = <span class="type">Notification</span>(name: <span class="type">NSNotification</span>.<span class="type">Name</span>(rawValue: <span class="string">"upDataForLabel"</span>),</div><div class="line">                                        object: <span class="literal">nil</span>,</div><div class="line">                                        userInfo: [<span class="string">"toFirstVCLabel"</span>:str])</div><div class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(notification)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样前面的目标就完成了。从 FirstVC 跳转到 SecondVC，在 SecondVC 中输入文字，点击 Button 后跳转回 FirstVC，并显示之前输入的文字。</p>
<h3 id="NSNotification-Name"><a href="#NSNotification-Name" class="headerlink" title="NSNotification.Name"></a>NSNotification.Name</h3><p>NSNotification.Name 并不仅仅可以为我们自己的通知进行标识，它还具有很多 API，可以监控 APP 的运行状态，我们接着完善这个小程序，这次我们的目标是当程序进入非活动状态时，更改 FirstVC 的 Label 的背景颜色。我们在 FirstVC 的 viewDidLoad 中再注册一个观察者：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>,</div><div class="line">                                           selector: #selector(<span class="type">FirstVC</span>.colorChangeForAppState),</div><div class="line">                                           name: <span class="type">NSNotification</span>.<span class="type">Name</span>.<span class="type">UIApplicationWillResignActive</span>,</div><div class="line">                                           object: <span class="literal">nil</span>)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>NSNotification.Name.UIApplicationWillResignActive 代表的是一个程序进入后台运行的通知，然后实现对应通知的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">colorChangeForAppState</span><span class="params">()</span></span> &#123;</div><div class="line">    observerLabel.backgroundColor = <span class="type">UIColor</span>.<span class="keyword">init</span>(red: <span class="number">168</span>/<span class="number">255</span>, green: <span class="number">21</span>/<span class="number">255</span>, blue: <span class="number">42</span>/<span class="number">255</span>, alpha: <span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们按两次 Home 键，在任务管理中可以看到，Label 的颜色已经发生改变。最后，不要忘记移除观察者：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.didReceiveMemoryWarning()</div><div class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>每一个运行的 Cocoa 程序都有一个自己管理的默认通知中心 NotificationCenter；</p>
<p>NotificationCenter 可以有许多的通知消息发送者 NSNotification；</p>
<p>每一个发送者 NSNotification 可以有很多的观察者 Observer 来接收通知。</p>
<p>每一个 Notification 对象都必须具有有：</p>
<ul>
<li>name，它描述的是通知的名称；</li>
<li>object 对象，它表示是谁发布的通知；</li>
<li>userInfo，一个字典类型，包含发布者要传递给通知接收者的一些额外内容；</li>
</ul>
<p>举个例子，UITextField 在每次文本发生变化时，都会发出一个名为 <code>UITextFieldTextDidChangeNotification</code> 的 NSNotification，这个通知关联的对象就是文本框本身，对于 <code>UIKeyboardWillShowNotification</code> 这个通知来说，<code>userInfo</code> 中存入了 frame 的位置和动画时间，关联的 <code>object</code> 是 nil。</p>
<h2 id="Demo下载请点击这里"><a href="#Demo下载请点击这里" class="headerlink" title="Demo下载请点击这里"></a>Demo下载请<a href="https://github.com/tianziyao/MyNotification" target="_blank" rel="external">点击这里</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 中的观察者 Observer 模式包含了通知机制（Notification）和KVO（Key-Value-Observing）机制，我们知道对象之间的通讯有以下几种常见的方式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Delegate、Block、KVO、Notification；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中 Delegate 使用的是委托机制，是一对一的对象之间的通信；而 KVO 和 Notification 通知机制是广播，也就是一对多的对象之间的通信。那么对象之间的通讯又是做什么呢？简单来说就是在 A 类中创建的方法，在 B 类中执行，且 A 类可以传递数据给 B 类，我们知道当说起通知时，有以下几种：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本地通知、推送通知、广播通知；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这三种通知是不同的，本地通知使用的是 &lt;code&gt;UILocalNotification&lt;/code&gt; 实现，是我们的 APP 运行时，给用户的通知；推送通知是使用 &lt;code&gt;UIUserNotification&lt;/code&gt; 实现，是用户同意推送后，由我们的服务器提交给 APNS，再由 APNS 转发给用户的。&lt;/p&gt;
&lt;p&gt;而我们本文要探讨的是，程序中的对象与对象之间的通知，也就是最后一项，广播通知。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Notification" scheme="http://yoursite.com/tags/Notification/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发 - 在一个工程中开发多个APP</title>
    <link href="http://yoursite.com/2016/10/11/iOS%E5%BC%80%E5%8F%91%20-%20%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B%E4%B8%AD%E5%BC%80%E5%8F%91%E5%A4%9A%E4%B8%AAAPP/"/>
    <id>http://yoursite.com/2016/10/11/iOS开发 - 在一个工程中开发多个APP/</id>
    <published>2016-10-10T18:24:00.000Z</published>
    <updated>2016-10-10T16:49:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般情况下，我们是一个 App 应用对应一个<code>Xcode Project</code>，但是如果你需要同时开发多个产品，而这些产品 90% 的数据结构以及交互方式都一样，呈现在用户面前的这两个产品，最大的不一样就是UI元素以及某些配色时，如果这个时候还是一个 App 一个<code>Xcode Project</code>，普遍的做法是：</p>
<p>你会先开发完成一个产品，然后在复制到其他的产品中，非常的麻烦而且效率很低，你需要一个一个文件去比对。如果你使用模块的方式，开发完一个模块，然后再利用<code>Pod</code>的方式导入到其他产品中，虽然这样可行，但是涉及到产品的迭代开发以及产品的随时会变的交互，模块的细化分很难实现。</p>
<p>如果你也面临这样的问题，不放考虑一下下面讲的<code>一个工程来开发多个App</code>：</p>
   <a id="more"></a>
<h2 id="创建新的Target"><a href="#创建新的Target" class="headerlink" title="创建新的Target"></a>创建新的Target</h2><p> 如果现在你已经有个一个产品叫<code>ProjectOfApps</code>，如下图所示：</p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/QQ20161010-0.png" alt="http://oboehz2ag.bkt.clouddn.com/QQ20161010-0"></p>
<p>这时你想添加一个叫<code>ProjectOfApps_B</code>的产品，你需要做的是按如下的步奏进行创建： 选择<code>Project -&gt; Targets -&gt; 右击ProjectOfApps -&gt; 选择Duplicate</code>，这时我们就按照<code>ProjectOfApps</code>复制了一个产品<code>ProjectOfApps copy</code>，并且你会看到多出了一个文件<code>ProjectOfApps copy-Info.plist</code>，如下图所示： </p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/QQ20161010-1.png" alt="http://oboehz2ag.bkt.clouddn.com/QQ20161010-1"></p>
<p>双击<code>ProjectOfApps copy</code>或选中回车，将 Target 名改为 <code>ProjectOfApps_B</code>。</p>
<h2 id="编辑Plist文件"><a href="#编辑Plist文件" class="headerlink" title="编辑Plist文件"></a>编辑Plist文件</h2><p>当我们创建新的<code>Target</code>后会多出一个<code>ProjectOfApps copy-Info.plist</code>文件，这个<code>plist</code>文件就是控制<code>ProjectOfApps_B</code>的名称，版本等信息的文件，我们为了统一将他改为<code>ProjectOfApps_B-Info.plist</code>，在修改名字之前你需要在<code>ProjectOfApps_B</code>的<code>Build Settings</code>中找到<code>ProjectOfApps copy-Info.plist</code>一项，待会儿我们修改完这个<code>plist</code>文件以后，还需要在这里填入它正切的位置信息。这样程序执行时才能找到它，不然程序是不能通过编译的：</p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/QQ20161010-2.png" alt="http://oboehz2ag.bkt.clouddn.com/QQ20161010-2"></p>
<p>我们的原项目<code>ProjectOfApps</code>也可以这样修改，来达到命名的统一。如果有必要，我们也可以修改<code>plist</code>文件里面的选项以符合我们的预期，和<code>Info.plist</code>的使用并无不同。</p>
<h2 id="判断当前编译的-Target"><a href="#判断当前编译的-Target" class="headerlink" title="判断当前编译的 Target"></a>判断当前编译的 Target</h2><p>现在我们的工程里面同时包含了两个<code>Target</code>，现在工程里面的类是这两个<code>Target</code>公用的，如果你想在一个类里面区分是<code>ProjectOfApps_A</code>还是<code>ProjectOfApps_B</code>，根据开发语言的不同有两种方案：</p>
<h3 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective - C"></a>Objective - C</h3><p>Objective - C 需要设置<code>Preprocessor Macros</code>，它的定义很简单，选中一个<code>Target</code>，然后在<code>Build Settings</code>里面搜索<code>Preprocessor Macros</code>一项，然后在里面添加表明是<code>ProjectOfApps_A</code>的宏： </p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/QQ20161010-3.png" alt="http://oboehz2ag.bkt.clouddn.com/QQ20161010-3"></p>
<p>然后就可以判断当前编译的 Target 是哪一个了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)someFunction </div><div class="line">&#123;</div><div class="line">#ifdef ProjectOfApps_A</div><div class="line">    NSLog(@&quot;Build For Target ProjectOfApps_A!&quot;);</div><div class="line">#else</div><div class="line">    NSLog(@&quot;Build For Target ProjectOfApps_B!&quot;);</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><p>Swift 下的处理和 Objective - C 有所不同，需要设置<code>Custom Flags</code>，选中一个<code>Target</code>，然后在<code>Build Settings</code>里面搜索<code>Custom Flags</code>一项，然后在里面添加表明是<code>ProjectOfApps_A</code>的宏：</p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/QQ20161011-0.png" alt="http://oboehz2ag.bkt.clouddn.com/QQ20161011-0"></p>
<p>需要注意的是，这里要使用<code>－D</code>的格式。对应的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">()</span></span> &#123;</div><div class="line">    #<span class="keyword">if</span> <span class="type">ProjectOfApps_A</span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"Build For Target ProjectOfApps_A!"</span>)</div><div class="line">    #elseif <span class="type">ProjectOfApps_B</span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"Build For Target ProjectOfApps_B!"</span>)</div><div class="line">    #<span class="keyword">else</span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"Other"</span>)</div><div class="line">    #endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="修改Scheme"><a href="#修改Scheme" class="headerlink" title="修改Scheme"></a>修改Scheme</h2><p>现在的 Scheme 还是<code>ProjectOfApps copy</code>和<code>ProjectOfApps</code>，我们可以通过<code>Manage Schemes</code>将两个 Scheme 修改一下： </p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/QQ20161011-1.png" alt="http://oboehz2ag.bkt.clouddn.com/QQ20161011-1"></p>
<h2 id="资源文件和类文件"><a href="#资源文件和类文件" class="headerlink" title="资源文件和类文件"></a>资源文件和类文件</h2><p>如果需要为不同的 Target 区别不同的资源文件和类文件，可以使用 Xcode 的<code>Target Membership</code>功能，来选择该类属于哪个<code>Target</code>。Assets、控件也是如此。 </p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/QQ20161011-2.png" alt="http://oboehz2ag.bkt.clouddn.com/QQ20161011-2"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://summertreee.github.io/blog/2016/01/23/ioszhong-ru-he-zai-%5B%3F%5D-ge-gong-cheng-chuang-jian-duo-ge-app/" target="_blank" rel="external">iOS中如何在一个工程创建多个App</a> - 夏树正茂</p>
<p><a href="http://stackoverflow.com/questions/24003291/ifdef-replacement-in-swift-language" target="_blank" rel="external">#ifdef replacement in swift language</a> - stackoverflow</p>
<h2 id="Demo下载请点击这里"><a href="#Demo下载请点击这里" class="headerlink" title="Demo下载请点击这里"></a>Demo下载请<a href="https://github.com/tianziyao/ProjectOfApps" target="_blank" rel="external">点击这里</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般情况下，我们是一个 App 应用对应一个&lt;code&gt;Xcode Project&lt;/code&gt;，但是如果你需要同时开发多个产品，而这些产品 90% 的数据结构以及交互方式都一样，呈现在用户面前的这两个产品，最大的不一样就是UI元素以及某些配色时，如果这个时候还是一个 App 一个&lt;code&gt;Xcode Project&lt;/code&gt;，普遍的做法是：&lt;/p&gt;
&lt;p&gt;你会先开发完成一个产品，然后在复制到其他的产品中，非常的麻烦而且效率很低，你需要一个一个文件去比对。如果你使用模块的方式，开发完一个模块，然后再利用&lt;code&gt;Pod&lt;/code&gt;的方式导入到其他产品中，虽然这样可行，但是涉及到产品的迭代开发以及产品的随时会变的交互，模块的细化分很难实现。&lt;/p&gt;
&lt;p&gt;如果你也面临这样的问题，不放考虑一下下面讲的&lt;code&gt;一个工程来开发多个App&lt;/code&gt;：&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="Custom Flags" scheme="http://yoursite.com/tags/Custom-Flags/"/>
    
  </entry>
  
  <entry>
    <title>Xcode错误 - Pch file not found</title>
    <link href="http://yoursite.com/2016/09/26/Xcode%E9%94%99%E8%AF%AF%20-%20Pch%20file%20not%20found/"/>
    <id>http://yoursite.com/2016/09/26/Xcode错误 - Pch file not found/</id>
    <published>2016-09-25T21:46:00.000Z</published>
    <updated>2016-09-26T10:45:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>这种问题出现的原因大多是路径问题，当 Mac 拷贝了工程或是工程的位置发生了变化，导致 Pch 文件的路径出错，解决方法如下：</p>
<ol>
<li><code>Targets -&gt; Build Settings -&gt; Apple llvm - Language</code> ，将项目里的的 Pch 文件直接拖到这边，设置为 YES；</li>
<li><code>⌘ + ⇧ + K</code> 清除工程；</li>
<li><code>⌘ + B</code> 编译工程；</li>
</ol>
<p><img src="http://oboehz2ag.bkt.clouddn.com/pchnotfound.png" alt="pchnotfound"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://stackoverflow.com/questions/25840720/xcode-6-pch-file-not-found" target="_blank" rel="external">http://stackoverflow.com/questions/25840720/xcode-6-pch-file-not-found</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这种问题出现的原因大多是路径问题，当 Mac 拷贝了工程或是工程的位置发生了变化，导致 Pch 文件的路径出错，解决方法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Targets -&amp;gt; Build Settings -&amp;gt; Apple llvm - Langua
    
    </summary>
    
      <category term="Xcode错误" scheme="http://yoursite.com/categories/Xcode%E9%94%99%E8%AF%AF/"/>
    
    
      <category term="Xcode错误" scheme="http://yoursite.com/tags/Xcode%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>Xcode错误 - Expected a type</title>
    <link href="http://yoursite.com/2016/09/15/Xcode%E9%94%99%E8%AF%AF%20-%20Expected%20a%20type%20/"/>
    <id>http://yoursite.com/2016/09/15/Xcode错误 - Expected a type /</id>
    <published>2016-09-14T18:24:00.000Z</published>
    <updated>2016-11-26T01:15:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>需要自己手动导入库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div></pre></td></tr></table></figure>
<p>参考链接：<a href="http://stackoverflow.com/questions/26412635/ios-8-expected-a-type" target="_blank" rel="external">http://stackoverflow.com/questions/26412635/ios-8-expected-a-type</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;需要自己手动导入库：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;p
    
    </summary>
    
      <category term="Xcode错误" scheme="http://yoursite.com/categories/Xcode%E9%94%99%E8%AF%AF/"/>
    
    
      <category term="Xcode错误" scheme="http://yoursite.com/tags/Xcode%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>微信开发 - 接口简介</title>
    <link href="http://yoursite.com/2016/09/05/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%20-%20%E6%8E%A5%E5%8F%A3%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2016/09/05/微信开发 - 接口简介/</id>
    <published>2016-09-04T18:24:00.000Z</published>
    <updated>2016-09-05T12:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于用户体验和安全性方面的考虑，微信公众号的注册有一定门槛，某些高级接口的权限需要微信认证后才可以获取。所以，为了帮助开发者快速了解和上手微信公众号开发，熟悉各个接口的调用，需要开通测试账号。</p>
<p>开通测试账号的路径为：</p>
<blockquote>
<p>微信公众平台 &gt; 开发者工具 &gt; 公众平台测试帐号 &gt; 进入</p>
</blockquote>
<p>或点击<a href="http://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;t=sandbox/index" target="_blank" rel="external">传送门</a>，需要填写的为以下几项：</p>
<blockquote>
<p>URL：接口文档所在的路径，如：<code>https://localhost/filepath/wxapifile.php</code></p>
<p>Token：接口文档中设定的Token</p>
<p>域名：网址或主机名，如：<code>localhost</code></p>
</blockquote>
<p>如对以上步骤陌生的同学可以先看<a href="https://tianziyao.github.io/2016/09/02/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%20-%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" target="_blank" rel="external">这篇文章</a>。</p>
   <a id="more"></a>
<h2 id="接口频率限制"><a href="#接口频率限制" class="headerlink" title="接口频率限制"></a>接口频率限制</h2><p>公众号调用接口并不是无限制的。为了防止公众号的程序错误而引发微信服务器负载异常，默认情况下，每个公众号调用接口都不能超过一定限制，当超过一定限制时，调用对应接口会收到如下错误返回码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;errcode&quot;:45009,&quot;errmsg&quot;:&quot;api freq out of limit&quot;&#125;</div></pre></td></tr></table></figure>
<p>接口频率限制的说明请点击<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433744592&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">传送门</a>。</p>
<h2 id="全局返回码"><a href="#全局返回码" class="headerlink" title="全局返回码"></a>全局返回码</h2><p>公众号每次调用接口时，可能获得正确或错误的返回码，开发者可以根据返回码信息调试接口，排查错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;errcode&quot;:45009,&quot;errmsg&quot;:&quot;api freq out of limit&quot;&#125;</div></pre></td></tr></table></figure>
<p>如上的返回码<code>45009</code>表达的就是<code>接口调用超过限制</code>。接口频率限制的说明请点击<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433744592&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">传送门</a>。</p>
<h2 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h2><p>access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。开发者需要进行妥善保存。</p>
<p>access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。</p>
<p>access_token相当于开发者的服务器访问微信服务器的一把钥匙，而微信服务器提供的各种API是一个个门，具有正确的access_token才可以得到门后面的东西。</p>
<h3 id="获取微信服务器IP接口"><a href="#获取微信服务器IP接口" class="headerlink" title="获取微信服务器IP接口"></a>获取微信服务器IP接口</h3><p>如果公众号基于安全等考虑，需要获知微信服务器的IP地址列表，以便进行相关限制，它一般是为了判断请求是否来自于微信，如不是微信服务器则可以返回非法访问等操作。</p>
<h3 id="长链接转短链接接口"><a href="#长链接转短链接接口" class="headerlink" title="长链接转短链接接口"></a>长链接转短链接接口</h3><p>顾名思义，就是将一条长链接转成短链接。它的主要使用场景是，如果开发者用于生成二维码的原链接（商品、支付二维码等）太长导致扫码速度和成功率下降，将原长链接通过此接口转成短链接再生成二维码将大大提升扫码速度和成功率。</p>
<h3 id="获取用户列表接口"><a href="#获取用户列表接口" class="headerlink" title="获取用户列表接口"></a>获取用户列表接口</h3><p>公众号可通过本接口来获取帐号的关注者列表，关注者列表由一串OpenID（加密后的微信号，每个用户对每个公众号的OpenID是唯一的）组成。一次拉取调用最多拉取10000个关注者的OpenID，可以通过多次拉取的方式来满足需求。</p>
<p>它主要用于获取和保存用户信息，在高级群发接口中也会使用到。</p>
<h3 id="获取用户基本信息接口"><a href="#获取用户基本信息接口" class="headerlink" title="获取用户基本信息接口"></a>获取用户基本信息接口</h3><p>在关注者与公众号产生消息交互后，公众号可获得关注者的OpenID（加密后的微信号，每个用户对每个公众号的OpenID是唯一的。对于不同公众号，同一用户的openid不同）。</p>
<p>公众号可通过本接口来根据OpenID获取用户基本信息，包括<strong>昵称、头像、性别、所在城市、语言和关注时间</strong>。</p>
<h4 id="UnionID机制"><a href="#UnionID机制" class="headerlink" title="UnionID机制"></a>UnionID机制</h4><p>开发者可通过OpenID来获取用户基本信息。特别需要注意的是，<strong>如果开发者拥有多个移动应用、网站应用和公众帐号，可通过获取用户基本信息中的unionid来区分用户的唯一性</strong>。</p>
<p>因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号，用户的unionid是唯一的，换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。 </p>
<p><strong>这也就是说，openid是开发者的唯一用户标识，unionid是整个微信的唯一用户标识，openid是获取unionid的先决条件，两种标识都需要用户关注或使用应用后才能获取。</strong></p>
<h3 id="网页授权接口"><a href="#网页授权接口" class="headerlink" title="网页授权接口"></a>网页授权接口</h3><p>如果用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息。</p>
<h4 id="网页授权的两种范围"><a href="#网页授权的两种范围" class="headerlink" title="网页授权的两种范围"></a>网页授权的两种范围</h4><ul>
<li>以snsapi_base为scope发起的网页授权，是用来<strong>获取进入页面的用户的openid的</strong>，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面）。</li>
<li>以snsapi_userinfo为scope发起的网页授权，是用来<strong>获取用户的基本信息的</strong>。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。 </li>
<li>用户管理类接口中的“获取用户基本信息接口”，是在用户和公众号产生消息交互或关注后事件推送后，才能根据用户OpenID来获取用户基本信息。这个接口，包括其他微信接口，都是<strong>需要该用户（即openid）关注了公众号后，才能调用成功的</strong>。 </li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">snsapi_userinfo演示</th>
<th style="text-align:center">可能是snsapi_base</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://oboehz2ag.bkt.clouddn.com/snsapi_userinfo.jpg" alt="snsapi_userinfo"></td>
<td style="text-align:center"><img src="http://oboehz2ag.bkt.clouddn.com/snsapi_base.jpg" alt="snsapi_base"></td>
</tr>
</tbody>
</table>
<h3 id="高级群发接口"><a href="#高级群发接口" class="headerlink" title="高级群发接口"></a>高级群发接口</h3><p>在公众平台网站上，为订阅号提供了每天一条的群发权限，为服务号提供每月（自然月）4条的群发权限。而对于某些具备开发能力的公众号运营者，可以通过高级群发接口，实现更灵活的群发能力。</p>
<p>高级群发具有两个优点：</p>
<ul>
<li>可根据用户标签或openid进行群发，普通群发只可针对标签和全部进行群发，高级群发的针对性更强；</li>
<li>高级群发图文内容支持HTML</li>
</ul>
<h3 id="JS-SDK接口"><a href="#JS-SDK接口" class="headerlink" title="JS-SDK接口"></a>JS-SDK接口</h3><p>微信JS-SDK是微信公众平台面向网页开发者提供的基于微信内的网页开发工具包。</p>
<p>通过使用微信JS-SDK，网页开发者可借助微信高效地使用拍照、选图、语音、位置等手机系统的能力，同时可以直接使用微信分享、扫一扫、卡券、支付等微信特有的能力，为微信用户提供更优质的网页体验。</p>
<p>例如分享功能，JS-SDK可以提供自定义分享标题，内容和图片的支持，还有调用相机，位置等接口。</p>
<h3 id="模板消息接口"><a href="#模板消息接口" class="headerlink" title="模板消息接口"></a>模板消息接口</h3><p>公众号可以主动向用户发送消息，用户可以收到服务号每月4条，订阅号每天1条的消息，超出后公众号发送的消息将对此用户屏蔽，这样的限制是不能满足我们的开发需求的。</p>
<p>当用户在公众号进行特定行为时，可以使用模板消息。模板消息仅用于公众号向用户发送重要的服务通知，只能用于符合其要求的服务场景中，如信用卡刷卡通知，商品购买成功通知等。</p>
<p>不支持广告等营销类消息以及其它所有可能对用户造成骚扰的消息。</p>
<table>
<thead>
<tr>
<th style="text-align:center">JS-SDK分享演示</th>
<th style="text-align:center">模板消息演示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://oboehz2ag.bkt.clouddn.com/JSSDK.PNG" alt="JSSDK"></td>
<td style="text-align:center"><img src="http://oboehz2ag.bkt.clouddn.com/%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF.PNG" alt="模板消息"></td>
</tr>
</tbody>
</table>
<h2 id="开发前确定需要的接口"><a href="#开发前确定需要的接口" class="headerlink" title="开发前确定需要的接口"></a>开发前确定需要的接口</h2><p>案例如下：</p>
<p>某公司希望将自己的PC商城和自己的微信公众平台进行对接，也就是在微信上绑定PC商城账号的功能，以实现在微信中点击菜单无需登录即可查看自己账号的详情，购物记录等。</p>
<p>那么如何得知需要的接口有哪些呢？首先我们需要：</p>
<h3 id="确定功能的流程"><a href="#确定功能的流程" class="headerlink" title="确定功能的流程"></a>确定功能的流程</h3><p> <img src="http://oboehz2ag.bkt.clouddn.com/%E5%8A%9F%E8%83%BD%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B.gif" alt="功能流程示例"></p>
<p>将功能的流程罗列好以后，即可按照每个流程的需求来确定需要调用的接口。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于用户体验和安全性方面的考虑，微信公众号的注册有一定门槛，某些高级接口的权限需要微信认证后才可以获取。所以，为了帮助开发者快速了解和上手微信公众号开发，熟悉各个接口的调用，需要开通测试账号。&lt;/p&gt;
&lt;p&gt;开通测试账号的路径为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;微信公众平台 &amp;gt; 开发者工具 &amp;gt; 公众平台测试帐号 &amp;gt; 进入&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或点击&lt;a href=&quot;http://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;amp;t=sandbox/index&quot;&gt;传送门&lt;/a&gt;，需要填写的为以下几项：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;URL：接口文档所在的路径，如：&lt;code&gt;https://localhost/filepath/wxapifile.php&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Token：接口文档中设定的Token&lt;/p&gt;
&lt;p&gt;域名：网址或主机名，如：&lt;code&gt;localhost&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如对以上步骤陌生的同学可以先看&lt;a href=&quot;https://tianziyao.github.io/2016/09/02/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%20-%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="微信开发" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="微信开发" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>微信开发 - access_token</title>
    <link href="http://yoursite.com/2016/09/05/%E5%BE%AE%E4%BF%A1%E6%8E%A5%E5%8F%A3%20-%20access%20token/"/>
    <id>http://yoursite.com/2016/09/05/微信接口 - access token/</id>
    <published>2016-09-04T18:24:00.000Z</published>
    <updated>2016-09-05T12:08:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>在微信公众平台接口开发中，access_token占据了一个很重要的地位，它相当于进入各种接口的钥匙，拿到这个钥匙才有调用其他各种特殊接口的权限。</p>
<p>同样微信服务器也是通过access_token识别是哪个公众号，以及该公众号是否有权限调用该接口。</p>
<p>access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。开发者需要进行妥善保存。access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。</p>
<p><strong>公众号可以使用AppID和AppSecret调用本接口来获取access_token。AppID和AppSecret可在开发模式中获得，注意调用所有微信接口时均需使用https协议。</strong></p>
   <a id="more"></a>
<h2 id="access-token开发策略"><a href="#access-token开发策略" class="headerlink" title="access_token开发策略"></a>access_token开发策略</h2><p>因为access_token具有每天2000次的访问限制，而access_token又是很重要的属性，调用非常频繁，基本上所有的接口都需要使用access_token来进行访问权限的验证，当频繁调用微信API时，很有可能会超出2000次的限制。因此普遍的解决方案是将一次获取的access_token保存到数据库，在两个小时后再更新数据库，在这两个小时内，所有需要access_token的地方全部到数据库来取。 </p>
<p><img src="http://oboehz2ag.bkt.clouddn.com/access_token%E5%BC%80%E5%8F%91%E7%AD%96%E7%95%A5.gif" alt="access_token开发策略"></p>
<h2 id="接口调用请求说明"><a href="#接口调用请求说明" class="headerlink" title="接口调用请求说明"></a>接口调用请求说明</h2><p>使用HTTP请求，请求方式为GET：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</div></pre></td></tr></table></figure>
<p>请求中附带的参数为：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>grant_type</td>
<td>是</td>
<td>获取access_token填写client_credential</td>
</tr>
<tr>
<td>appid</td>
<td>是</td>
<td>第三方用户唯一凭证</td>
</tr>
<tr>
<td>secret</td>
<td>是</td>
<td>第三方用户唯一凭证密钥，即appsecret</td>
</tr>
</tbody>
</table>
<h2 id="返回说明"><a href="#返回说明" class="headerlink" title="返回说明"></a>返回说明</h2><p>正常情况下，微信会返回下述JSON数据包给公众号：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="attr">"access_token"</span>:<span class="string">"ACCESS_TOKEN"</span>,<span class="attr">"expires_in"</span>:<span class="number">7200</span>&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>access_token</td>
<td>获取到的凭证</td>
</tr>
<tr>
<td>expires_in</td>
<td>凭证有效时间，单位：秒</td>
</tr>
</tbody>
</table>
<h2 id="获取粉丝头像"><a href="#获取粉丝头像" class="headerlink" title="获取粉丝头像"></a>获取粉丝头像</h2><p>下面我们用获取粉丝头像的例子来演示如何使用access_token。</p>
<p>首先写一个PHP文件，来获取access_token：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">getaccesstoken.php</div><div class="line"></div><div class="line"><span class="meta">&lt;?php</span></div><div class="line">define(<span class="string">'appid'</span>, <span class="string">'wx5d649f3295ce323a'</span>);</div><div class="line">define(<span class="string">'app_secret'</span>, <span class="string">'a17ecddd3fb0699814fce90fa6376b8e'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_access_token</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    $url = <span class="string">"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid="</span>.appid.<span class="string">"&amp;secret="</span>.app_secret;</div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    $ch = curl_init();</div><div class="line">    <span class="comment">//设置选项，包括URL</span></div><div class="line">    curl_setopt($ch, CURLOPT_URL, $url);</div><div class="line">    curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_USERAGENT, <span class="number">1</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_ENCODING, <span class="string">"gzip"</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">//执行并获取HTML文档内容</span></div><div class="line">    $output = curl_exec($ch);</div><div class="line">    <span class="comment">//释放curl句柄</span></div><div class="line">    curl_close($ch);</div><div class="line">    <span class="comment">//打印获得的数据</span></div><div class="line">    <span class="comment">//print_r($output);</span></div><div class="line">    $access_taken_arr = json_decode($output, <span class="keyword">true</span>);</div><div class="line">    $access_token = $access_taken_arr[<span class="string">"access_token"</span>];</div><div class="line">    <span class="comment">//print_r($access_taken_arr);</span></div><div class="line">    <span class="keyword">return</span> $access_token;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>新建另一个PHP文件，首先获取粉丝列表，提取出粉丝的openid组成数组：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_user_list</span><span class="params">($access_token)</span> </span>&#123;</div><div class="line"></div><div class="line">    $url = <span class="string">"https://api.weixin.qq.com/cgi-bin/user/get?access_token="</span>.$access_token;</div><div class="line">    <span class="comment">//echo $access_token;</span></div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    $ch = curl_init();</div><div class="line">    <span class="comment">//设置选项，包括URL</span></div><div class="line">    curl_setopt($ch, CURLOPT_URL, $url);</div><div class="line">    curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_USERAGENT, <span class="number">1</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_ENCODING, <span class="string">"gzip"</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">//执行并获取HTML文档内容</span></div><div class="line">    $output = curl_exec($ch);</div><div class="line">    <span class="comment">//释放curl句柄</span></div><div class="line">    curl_close($ch);</div><div class="line">    <span class="comment">//打印获得的数据</span></div><div class="line">    <span class="comment">//print_r($output);</span></div><div class="line">    $user_list_arr = json_decode($output, <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">return</span> ($user_list_arr[<span class="string">"data"</span>][<span class="string">"openid"</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后利用openid获取粉丝的用户信息：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_user_info</span><span class="params">($access_token, $openid)</span> </span>&#123;</div><div class="line"></div><div class="line">    $url = <span class="string">"https://api.weixin.qq.com/cgi-bin/user/info?access_token="</span>.$access_token.<span class="string">"&amp;openid="</span>.$openid.<span class="string">"&amp;lang=zh_CN"</span>;</div><div class="line"></div><div class="line">    $ch = curl_init();</div><div class="line">    curl_setopt($ch, CURLOPT_URL, $url);</div><div class="line">    curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_USERAGENT, <span class="number">1</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_ENCODING, <span class="string">"gzip"</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    $output = curl_exec($ch);</div><div class="line">    curl_close($ch);</div><div class="line"></div><div class="line">    $user_info_arr = json_decode($output, <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">return</span> ($user_info_arr[<span class="string">"headimgurl"</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后从用户信息中提取出用户头像的url，并传给iOS客户端：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ($i=<span class="number">0</span>; $i&lt;<span class="number">3</span>; $i++) &#123;</div><div class="line">    $openid = $openids[$i];</div><div class="line">    $use_info = get_user_info($access_token, $openid);</div><div class="line">    $user_image = substr($use_info, <span class="number">0</span>, strlen($str)<span class="number">-2</span>).<span class="string">"/132"</span>;</div><div class="line">    <span class="comment">//echo $user_image;</span></div><div class="line">    array_push($user_images, $user_image);</div><div class="line">&#125;</div><div class="line"><span class="keyword">echo</span> json_encode($user_images);</div></pre></td></tr></table></figure>
<p>在Xcode中创建工程，使用NSURLSession获取PHP服务器传来的包含粉丝头像url的数组，利用url获取粉丝头像，并将其设置为工程中ImageView的Image，这里需要注意的是，<strong>UI操作要转到主线程进行</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getWechatFansHeadImgs</span><span class="params">()</span></span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">self</span>.pleaseWait()</div><div class="line">        </div><div class="line">        <span class="comment">//let request = NSURLRequest(URL: NSURL(string: "http://localhost:8888/i/wechat/getuserinfo.php")!)</span></div><div class="line">        <span class="keyword">let</span> request = <span class="type">NSURLRequest</span>(<span class="type">URL</span>: <span class="type">NSURL</span>(string: <span class="string">"http://123.206.27.127/wechat/getuserinfo.php"</span>)!)</div><div class="line"></div><div class="line">        <span class="keyword">let</span> task = <span class="type">NSURLSession</span>.sharedSession().dataTaskWithRequest(request) &#123; (data, resp, error) <span class="keyword">in</span></div><div class="line">            </div><div class="line">            <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</div><div class="line">                <span class="built_in">print</span>(error?.localizedDescription)</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">var</span> imgLinks: [<span class="type">String</span>] = []</div><div class="line">                <span class="keyword">let</span> readingOprions = <span class="type">NSJSONReadingOptions</span>.<span class="type">MutableContainers</span></div><div class="line">                imgLinks = <span class="keyword">try</span>! <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(data!, options: readingOprions) <span class="keyword">as</span>! <span class="type">Array</span><span class="comment">//nil</span></div><div class="line">                <span class="built_in">print</span>(imgLinks)</div><div class="line">                </div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;imgLinks.<span class="built_in">count</span> &#123;</div><div class="line">                    <span class="keyword">if</span> imgLinks[i] != <span class="string">""</span> &#123;</div><div class="line">                        <span class="keyword">let</span> data = <span class="type">NSData</span>(contentsOfURL: <span class="type">NSURL</span>(string: imgLinks[i])!)</div><div class="line">                        dispatch_async(dispatch_get_main_queue(), &#123;</div><div class="line">                            <span class="keyword">self</span>.headImageViews[i].image = data != <span class="literal">nil</span> ? <span class="type">UIImage</span>(data: data!) : <span class="literal">nil</span></div><div class="line">                            <span class="built_in">print</span>(i)</div><div class="line">                        &#125;)</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="built_in">print</span>(<span class="type">NSThread</span>.currentThread())</div><div class="line">                dispatch_async(dispatch_get_main_queue(), &#123;</div><div class="line">                    <span class="keyword">self</span>.clearAllNotice()</div><div class="line">                    <span class="keyword">self</span>.noticeSuccess(<span class="string">"获取成功"</span>, autoClear: <span class="literal">true</span>, autoClearTime: <span class="number">2</span>)</div><div class="line">                &#125;)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        task.resume()</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>最后使用点击事件触发这个方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">showHeadImageButtonDidTouch</span><span class="params">(sender: AnyObject)</span></span> &#123;</div><div class="line">    </div><div class="line">    getWechatFansHeadImgs()</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Demo下载请点击这里"><a href="#Demo下载请点击这里" class="headerlink" title="Demo下载请点击这里"></a>Demo下载请<a href="https://github.com/tianziyao/demo" target="_blank" rel="external">点击这里</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在微信公众平台接口开发中，access_token占据了一个很重要的地位，它相当于进入各种接口的钥匙，拿到这个钥匙才有调用其他各种特殊接口的权限。&lt;/p&gt;
&lt;p&gt;同样微信服务器也是通过access_token识别是哪个公众号，以及该公众号是否有权限调用该接口。&lt;/p&gt;
&lt;p&gt;access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。开发者需要进行妥善保存。access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公众号可以使用AppID和AppSecret调用本接口来获取access_token。AppID和AppSecret可在开发模式中获得，注意调用所有微信接口时均需使用https协议。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="微信开发" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="微信开发" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程 - 下载及图片缓存</title>
    <link href="http://yoursite.com/2016/09/03/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%8F%8A%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2016/09/03/iOS多线程下载及图片缓存/</id>
    <published>2016-09-02T18:46:00.000Z</published>
    <updated>2017-01-24T15:48:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>线程可以理解为下载的通道，一个线程就是一个文件的下载通道，多线程也就是同时开起好几个下载通道.当服务器提供下载服务时，使用下载者是共享带宽的，在优先级相同的情况下，总服务器会对总下载线程进行平均分配。不难理解，如果你线程多的话，那下载的越快。现流行的下载软件都支持多线程。</p>
</blockquote>
<p>下面我们通过代码来了解以下几个知识点：</p>
<ol>
<li>多线程下载；</li>
<li>自定义 NSOperation ；</li>
<li>NSCache 增删改查；</li>
<li>NSFileManager 增删改查；</li>
<li>代理模式；</li>
<li>闭包反向传值；</li>
<li>扩展方法；</li>
<li>Plist 文件解析；</li>
</ol>
<a id="more"></a>
<p>首先我们给 String 类型添加扩展方法，获取字符串的MD5值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> md5 : <span class="type">String</span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> str = <span class="keyword">self</span>.cStringUsingEncoding(<span class="type">NSUTF8StringEncoding</span>)</div><div class="line">        <span class="keyword">let</span> strLen = <span class="type">CC_LONG</span>(<span class="keyword">self</span>.lengthOfBytesUsingEncoding(<span class="type">NSUTF8StringEncoding</span>))</div><div class="line">        <span class="keyword">let</span> digestLen = <span class="type">Int</span>(<span class="type">CC_MD5_DIGEST_LENGTH</span>)</div><div class="line">        <span class="keyword">let</span> result = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">CUnsignedChar</span>&gt;.alloc(digestLen);</div><div class="line"></div><div class="line">        <span class="type">CC_MD5</span>(str!, strLen, result);</div><div class="line"></div><div class="line">        <span class="keyword">let</span> hash = <span class="type">NSMutableString</span>();</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; digestLen &#123;</div><div class="line">            hash.appendFormat(<span class="string">"%02x"</span>, result[i]);</div><div class="line">        &#125;</div><div class="line">        result.destroy();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="type">String</span>(format: hash <span class="keyword">as</span> <span class="type">String</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们来自定义一个 NSOperation ，新建一个继承自 NSOperation 的类，并声明以下属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadOperation</span>: <span class="title">NSOperation</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> memCache: <span class="type">NSCache</span>!</div><div class="line">    <span class="keyword">var</span> fileMgr: <span class="type">NSFileManager</span>!</div><div class="line">    <span class="keyword">var</span> diskCachePath: <span class="type">String</span>!</div><div class="line"></div><div class="line">    <span class="keyword">var</span> operations: [<span class="type">NSOperation</span>] = []</div><div class="line">    <span class="keyword">var</span> getImageQueue: <span class="type">NSOperationQueue</span>!</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后声明一个闭包：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typealias</span> <span class="type">Block</span> = (<span class="type">UIImage</span>) -&gt; (<span class="type">Void</span>)</div></pre></td></tr></table></figure>
<p>最后声明一个协议，并创建两个代理方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DownloadDelegate</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userCache</span> <span class="params">(operation: DownloadOperation, imageCache:NSCache)</span></span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">cleanCache</span> <span class="params">(operation: DownloadOperation, imageCache:NSCache)</span></span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们重写自定义 NSOperation 的 init 方法，用来创建沙盒目录，实例 NSCache NSFileManager NSOperationQueue ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="keyword">init</span>() &#123;</div><div class="line"></div><div class="line">    memCache = <span class="type">NSCache</span>()</div><div class="line">    fileMgr = <span class="type">NSFileManager</span>()</div><div class="line"></div><div class="line">    <span class="keyword">let</span> paths = <span class="type">NSSearchPathForDirectoriesInDomains</span>(<span class="type">NSSearchPathDirectory</span>.<span class="type">DocumentDirectory</span>,</div><div class="line">                                                    <span class="type">NSSearchPathDomainMask</span>.<span class="type">UserDomainMask</span>,</div><div class="line">                                                    <span class="literal">true</span>)</div><div class="line">    <span class="keyword">self</span>.diskCachePath = paths.first?.stringByAppendingString(<span class="string">"/ImageCache"</span>)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> !(<span class="type">NSFileManager</span>.defaultManager().fileExistsAtPath(<span class="keyword">self</span>.diskCachePath!)) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">try</span>! <span class="type">NSFileManager</span>.defaultManager().createDirectoryAtPath(<span class="keyword">self</span>.diskCachePath!,</div><div class="line">                                                                  withIntermediateDirectories: <span class="literal">true</span>,</div><div class="line">                                                                  attributes: <span class="literal">nil</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getImageQueue = <span class="type">NSOperationQueue</span>()</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是闭包反向传值的第一步，初始化闭包：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ininWithblock</span><span class="params">(block: Block)</span></span> &#123;</div><div class="line">    showImage = block</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们利用文件名获得要保存的路径：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">diskPathForKey</span><span class="params">(key: String)</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (diskCachePath?.stringByAppendingString(<span class="string">"/<span class="subst">\(key.md5)</span>"</span>))!</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们利用文件名判断这个文件在内存中是否存在：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">cacheIsExist</span><span class="params">(key: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> data = memCache.objectForKey(key)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> data != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们利用文件名判断这个文件在磁盘中是否存在：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">fileIsExist</span><span class="params">(key: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fileMgr.fileExistsAtPath(diskPathForKey(key))</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们实现利用文件名从内存中获取文件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFromeMem</span><span class="params">(key: String)</span></span> -&gt; <span class="type">UIImage</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> image = memCache.objectForKey(key) <span class="keyword">as</span>! <span class="type">UIImage</span></div><div class="line">    <span class="keyword">return</span> image</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们实现利用文件名从磁盘中获取文件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFromeDisk</span><span class="params">(key: String)</span></span> -&gt; <span class="type">UIImage</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span>  data = fileMgr.contentsAtPath(diskPathForKey(key))</div><div class="line">    <span class="keyword">let</span> image = <span class="type">UIImage</span>(data: data!)</div><div class="line">    <span class="keyword">return</span> image!</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们实现利用链接下载文件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">download</span><span class="params">(key: String)</span></span> -&gt; <span class="type">UIImage</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: key)</div><div class="line">    <span class="keyword">let</span> data = <span class="type">NSData</span>(contentsOfURL: url!)</div><div class="line">    <span class="keyword">let</span> image = <span class="type">UIImage</span>(data: data!)</div><div class="line">    <span class="keyword">return</span> image!</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面实现将文件写入内存：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">saveToMem</span><span class="params">(image: UIImage, key: String)</span></span> &#123;</div><div class="line"></div><div class="line">    memCache.setObject(image, forKey: key)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下载实现将文件写入磁盘：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">saveToDisk</span><span class="params">(image: UIImage, key: String)</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> key = diskPathForKey(key)</div><div class="line"></div><div class="line">    fileMgr.createFileAtPath(key,</div><div class="line">                             contents: <span class="type">UIImageJPEGRepresentation</span>(image, <span class="number">1.0</span>),</div><div class="line">                             attributes: <span class="literal">nil</span>)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面实现利用链接下载文件，并将下载的文件写入内存和磁盘：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">saveToMemAndDisk</span><span class="params">(key: String, toDisk: Bool)</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> image = download(key)</div><div class="line"></div><div class="line">    saveToMem(image, key: key)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> toDisk &#123;</div><div class="line">        saveToDisk(image, key: key)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面实现读取文件，如果内存中有就从内存读取，如果磁盘中有就从磁盘读取，并写入到内存，如果都没有，就下载并写入到内存和磁盘：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">readImage</span><span class="params">(key: String)</span></span> -&gt; <span class="type">UIImage</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> cacheIsExist(key) &#123;</div><div class="line">        <span class="keyword">let</span> image = readFromeMem(key)</div><div class="line">        <span class="keyword">return</span> image</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> fileIsExist(key) &#123;</div><div class="line">        <span class="keyword">let</span> image = readFromeDisk(key)</div><div class="line">        saveToMem(image, key: key)</div><div class="line">        <span class="keyword">return</span> image</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    saveToMemAndDisk(key, toDisk: <span class="literal">true</span>)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> readFromeMem(key)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面实现利用存放链接的数组，批量下载文件，设置下载线程的最大值并使用 block 执行 ViewController 预设的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getImage</span><span class="params">(keys: [String], <span class="built_in">max</span>: Int)</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> keys &#123;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> operation = <span class="type">NSBlockOperation</span>(block: &#123;</div><div class="line"></div><div class="line">            <span class="keyword">let</span> image = <span class="keyword">self</span>.readImage(key)</div><div class="line">            <span class="keyword">self</span>.showImage!(image)</div><div class="line">        &#125;)</div><div class="line"></div><div class="line">        operations.append(operation)</div><div class="line">    &#125;</div><div class="line">    getImageQueue.maxConcurrentOperationCount = <span class="built_in">max</span></div><div class="line">    getImageQueue.addOperations(operations, waitUntilFinished: <span class="literal">true</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面实现利用文件名删除文件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteFile</span><span class="params">(key: String)</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> fileMgr.isDeletableFileAtPath(key) &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"删除成功"</span>)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>下面实现调用代理的两个方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">showImg</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.delegete != <span class="literal">nil</span>) &amp;&amp; (<span class="keyword">self</span>.delegete?.userCache != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.delegete?.userCache(<span class="keyword">self</span>, imageCache: <span class="keyword">self</span>.memCache)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteImg</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.delegete != <span class="literal">nil</span>) &amp;&amp; (<span class="keyword">self</span>.delegete?.cleanCache != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.delegete?.cleanCache(<span class="keyword">self</span>, imageCache: <span class="keyword">self</span>.memCache)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们回到 ViewController 中，声明以下几个属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> keys: <span class="type">NSArray</span>!</div><div class="line">    <span class="keyword">var</span> imgView: <span class="type">UIImageView</span>!</div><div class="line">    <span class="keyword">var</span> downloadBtn: <span class="type">UIButton</span>?</div><div class="line">    <span class="keyword">var</span> cleanBtn: <span class="type">UIButton</span>?</div><div class="line"></div><div class="line">    <span class="keyword">var</span> operation: <span class="type">DownloadOperation</span>!</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们创建 block 要执行的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">showImage</span><span class="params">(image: UIImage)</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.imgView = <span class="type">UIImageView</span>(frame: <span class="keyword">self</span>.view.bounds)</div><div class="line">    <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.imgView!)</div><div class="line">    <span class="keyword">self</span>.imgView.image = image</div><div class="line">    <span class="built_in">print</span>(<span class="string">"block 加载图片"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们解析 Plist 文件为数组，并将包含下载链接的数组传给自定义 NSOperation 的获取文件方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadForKeys</span><span class="params">(<span class="built_in">max</span>: Int)</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> imgPaths = <span class="type">NSBundle</span>.mainBundle().pathForResource(<span class="string">"ImageLinks"</span>, ofType: <span class="string">"plist"</span>)</div><div class="line">    <span class="keyword">let</span> imgUrls = <span class="type">NSURL</span>(fileURLWithPath: imgPaths!)</div><div class="line">    <span class="keyword">self</span>.keys = <span class="type">NSArray</span>(contentsOfURL: imgUrls)!</div><div class="line">    operation.getImage(keys <span class="keyword">as</span>! [<span class="type">String</span>], <span class="built_in">max</span>: <span class="built_in">max</span>)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们给 ViewController 添加两个 Button ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">addButton</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> width = <span class="keyword">self</span>.view.bounds.size.width</div><div class="line">    <span class="keyword">let</span> height = <span class="keyword">self</span>.view.bounds.size.height</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.downloadBtn = <span class="type">UIButton</span>(type: .<span class="type">Custom</span>)</div><div class="line">    <span class="keyword">let</span> downloadBtnframe = <span class="type">CGRectMake</span>(<span class="number">20</span>, height-<span class="number">60</span>, <span class="number">80</span>, <span class="number">40</span>)</div><div class="line">    <span class="keyword">self</span>.downloadBtn?.frame = downloadBtnframe</div><div class="line">    <span class="keyword">self</span>.downloadBtn?.backgroundColor = <span class="type">UIColor</span>.lightGrayColor()</div><div class="line">    <span class="keyword">self</span>.downloadBtn?.titleLabel?.font = <span class="type">UIFont</span>.systemFontOfSize(<span class="number">18</span>)</div><div class="line">    <span class="keyword">self</span>.downloadBtn?.setTitle(<span class="string">"下载"</span>, forState: .<span class="type">Normal</span>)</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.cleanBtn = <span class="type">UIButton</span>(type: .<span class="type">Custom</span>)</div><div class="line">    <span class="keyword">let</span> cleanBtnframe = <span class="type">CGRectMake</span>(width-<span class="number">80</span>-<span class="number">20</span>, height-<span class="number">60</span>, <span class="number">80</span>, <span class="number">40</span>)</div><div class="line">    <span class="keyword">self</span>.cleanBtn?.frame = cleanBtnframe</div><div class="line">    <span class="keyword">self</span>.cleanBtn?.backgroundColor = <span class="type">UIColor</span>.lightGrayColor()</div><div class="line">    <span class="keyword">self</span>.cleanBtn?.titleLabel?.font = <span class="type">UIFont</span>.systemFontOfSize(<span class="number">18</span>)</div><div class="line">    <span class="keyword">self</span>.cleanBtn?.setTitle(<span class="string">"清除"</span>, forState: .<span class="type">Normal</span>)</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.downloadBtn?.addTarget(<span class="keyword">self</span>,</div><div class="line">                                action: #selector(<span class="type">ViewController</span>.downloadBtnClicked),</div><div class="line">                                forControlEvents: .<span class="type">TouchUpInside</span>)</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.cleanBtn?.addTarget(<span class="keyword">self</span>,</div><div class="line">                                action: #selector(<span class="type">ViewController</span>.cleanBtnClicked),</div><div class="line">                                forControlEvents: .<span class="type">TouchUpInside</span>)</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.downloadBtn!)</div><div class="line">    <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.cleanBtn!)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们实现 Button 的响应事件方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadBtnClicked</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">    operation.showImg()</div><div class="line">    addButton()</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">cleanBtnClicked</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">    operation.deleteImg()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们实现代理方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">userCache</span><span class="params">(operation: DownloadOperation, imageCache: NSCache)</span></span> &#123;</div><div class="line"></div><div class="line">    imgView.removeFromSuperview()</div><div class="line"></div><div class="line">    <span class="keyword">let</span> width = <span class="keyword">self</span>.view.bounds.size.width</div><div class="line">    <span class="keyword">let</span> imgHeight = <span class="keyword">self</span>.view.bounds.size.height / <span class="type">CGFloat</span>(<span class="type">Float</span>(keys.<span class="built_in">count</span>))</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; keys.<span class="built_in">count</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> frame = <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="type">CGFloat</span>(i) * imgHeight, width, imgHeight)</div><div class="line">        <span class="keyword">let</span> imageView = <span class="type">UIImageView</span>(frame: frame)</div><div class="line">        <span class="keyword">let</span> key = keys[i] <span class="keyword">as</span>! <span class="type">String</span></div><div class="line">        <span class="keyword">let</span> image = operation.readImage(key)</div><div class="line">        imageView.image = image</div><div class="line">        imageView.contentMode = .<span class="type">ScaleToFill</span></div><div class="line">        <span class="keyword">self</span>.view.addSubview(imageView)</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">cleanCache</span> <span class="params">(operation: DownloadOperation, imageCache:NSCache)</span></span> &#123;</div><div class="line"></div><div class="line">    imageCache.removeAllObjects()</div><div class="line"></div><div class="line">    <span class="keyword">for</span> subView <span class="keyword">in</span> <span class="keyword">self</span>.view.subviews &#123;</div><div class="line">        subView.removeFromSuperview()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> keys &#123;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> temKey = operation.diskPathForKey(key <span class="keyword">as</span>! <span class="type">String</span>)</div><div class="line">        operation.deleteFile(temKey)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    addButton()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们引入代理协议，实例化自定义的  ，实例化代理对象，实例化 block，以上几个功能点就完成了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">DownloadDelegate</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> keys: <span class="type">NSArray</span>!</div><div class="line">    <span class="keyword">var</span> imgView: <span class="type">UIImageView</span>!</div><div class="line">    <span class="keyword">var</span> downloadBtn: <span class="type">UIButton</span>?</div><div class="line">    <span class="keyword">var</span> cleanBtn: <span class="type">UIButton</span>?</div><div class="line">    <span class="keyword">var</span> operation: <span class="type">DownloadOperation</span>!</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">        operation = <span class="type">DownloadOperation</span>()</div><div class="line">        operation.ininWithblock(showImage)</div><div class="line">        operation.delegete = <span class="keyword">self</span></div><div class="line">        downloadForKeys(<span class="number">3</span>)</div><div class="line">        addButton()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> md5 : <span class="type">String</span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> str = <span class="keyword">self</span>.cStringUsingEncoding(<span class="type">NSUTF8StringEncoding</span>)</div><div class="line">        <span class="keyword">let</span> strLen = <span class="type">CC_LONG</span>(<span class="keyword">self</span>.lengthOfBytesUsingEncoding(<span class="type">NSUTF8StringEncoding</span>))</div><div class="line">        <span class="keyword">let</span> digestLen = <span class="type">Int</span>(<span class="type">CC_MD5_DIGEST_LENGTH</span>)</div><div class="line">        <span class="keyword">let</span> result = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">CUnsignedChar</span>&gt;.alloc(digestLen);</div><div class="line"></div><div class="line">        <span class="type">CC_MD5</span>(str!, strLen, result);</div><div class="line"></div><div class="line">        <span class="keyword">let</span> hash = <span class="type">NSMutableString</span>();</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; digestLen &#123;</div><div class="line">            hash.appendFormat(<span class="string">"%02x"</span>, result[i]);</div><div class="line">        &#125;</div><div class="line">        result.destroy();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="type">String</span>(format: hash <span class="keyword">as</span> <span class="type">String</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typealias</span> <span class="type">Block</span> = (<span class="type">UIImage</span>) -&gt; (<span class="type">Void</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DownloadDelegate</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userCache</span> <span class="params">(operation: DownloadOperation, imageCache:NSCache)</span></span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">cleanCache</span> <span class="params">(operation: DownloadOperation, imageCache:NSCache)</span></span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadOperation</span>: <span class="title">NSOperation</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> memCache: <span class="type">NSCache</span>!</div><div class="line">    <span class="keyword">var</span> fileMgr: <span class="type">NSFileManager</span>!</div><div class="line">    <span class="keyword">var</span> diskCachePath: <span class="type">String</span>!</div><div class="line"></div><div class="line">    <span class="keyword">var</span> operations: [<span class="type">NSOperation</span>] = []</div><div class="line">    <span class="keyword">var</span> getImageQueue: <span class="type">NSOperationQueue</span>!</div><div class="line"></div><div class="line">    <span class="keyword">var</span> showImage: <span class="type">Block</span>?</div><div class="line">    <span class="keyword">var</span> delegete:<span class="type">DownloadDelegate</span>?</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</div><div class="line"></div><div class="line">        memCache = <span class="type">NSCache</span>()</div><div class="line">        fileMgr = <span class="type">NSFileManager</span>()</div><div class="line"></div><div class="line">        <span class="keyword">let</span> paths = <span class="type">NSSearchPathForDirectoriesInDomains</span>(<span class="type">NSSearchPathDirectory</span>.<span class="type">DocumentDirectory</span>,</div><div class="line">                                                        <span class="type">NSSearchPathDomainMask</span>.<span class="type">UserDomainMask</span>,</div><div class="line">                                                        <span class="literal">true</span>)</div><div class="line">        <span class="keyword">self</span>.diskCachePath = paths.first?.stringByAppendingString(<span class="string">"/ImageCache"</span>)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> !(<span class="type">NSFileManager</span>.defaultManager().fileExistsAtPath(<span class="keyword">self</span>.diskCachePath!)) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">try</span>! <span class="type">NSFileManager</span>.defaultManager().createDirectoryAtPath(<span class="keyword">self</span>.diskCachePath!,</div><div class="line">                                                                      withIntermediateDirectories: <span class="literal">true</span>,</div><div class="line">                                                                      attributes: <span class="literal">nil</span>)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        getImageQueue = <span class="type">NSOperationQueue</span>()</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">ininWithblock</span><span class="params">(block: Block)</span></span> &#123;</div><div class="line">        showImage = block</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">diskPathForKey</span><span class="params">(key: String)</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (diskCachePath?.stringByAppendingString(<span class="string">"/<span class="subst">\(key.md5)</span>"</span>))!</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fileIsExist</span><span class="params">(key: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> fileMgr.fileExistsAtPath(diskPathForKey(key))</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">cacheIsExist</span><span class="params">(key: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> data = memCache.objectForKey(key)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> data != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">readFromeMem</span><span class="params">(key: String)</span></span> -&gt; <span class="type">UIImage</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> image = memCache.objectForKey(key) <span class="keyword">as</span>! <span class="type">UIImage</span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"内存读取"</span>)</div><div class="line">        <span class="keyword">return</span> image</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">readFromeDisk</span><span class="params">(key: String)</span></span> -&gt; <span class="type">UIImage</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">let</span>  data = fileMgr.contentsAtPath(diskPathForKey(key))</div><div class="line">        <span class="keyword">let</span> image = <span class="type">UIImage</span>(data: data!)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"文件读取"</span>)</div><div class="line">        <span class="keyword">return</span> image!</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">deleteFile</span><span class="params">(key: String)</span></span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> fileMgr.isDeletableFileAtPath(key) &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"删除成功"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">download</span><span class="params">(key: String)</span></span> -&gt; <span class="type">UIImage</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: key)</div><div class="line">        <span class="keyword">let</span> data = <span class="type">NSData</span>(contentsOfURL: url!)</div><div class="line">        <span class="keyword">let</span> image = <span class="type">UIImage</span>(data: data!)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"下载"</span>)</div><div class="line">        <span class="keyword">return</span> image!</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">saveToMemAndDisk</span><span class="params">(key: String, toDisk: Bool)</span></span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> image = download(key)</div><div class="line"></div><div class="line">        saveToMem(image, key: key)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> toDisk &#123;</div><div class="line">            saveToDisk(image, key: key)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">saveToMem</span><span class="params">(image: UIImage, key: String)</span></span> &#123;</div><div class="line"></div><div class="line">        memCache.setObject(image, forKey: key)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"写入内存"</span>)</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">saveToDisk</span><span class="params">(image: UIImage, key: String)</span></span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> key = diskPathForKey(key)</div><div class="line"></div><div class="line">        fileMgr.createFileAtPath(key,</div><div class="line">                                 contents: <span class="type">UIImageJPEGRepresentation</span>(image, <span class="number">1.0</span>),</div><div class="line">                                 attributes: <span class="literal">nil</span>)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"写入文件"</span>)</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">readImage</span><span class="params">(key: String)</span></span> -&gt; <span class="type">UIImage</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> cacheIsExist(key) &#123;</div><div class="line">            <span class="keyword">let</span> image = readFromeMem(key)</div><div class="line">            <span class="keyword">return</span> image</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> fileIsExist(key) &#123;</div><div class="line">            <span class="keyword">let</span> image = readFromeDisk(key)</div><div class="line">            saveToMem(image, key: key)</div><div class="line">            <span class="keyword">return</span> image</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        saveToMemAndDisk(key, toDisk: <span class="literal">true</span>)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> readFromeMem(key)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getImage</span><span class="params">(keys: [String], <span class="built_in">max</span>: Int)</span></span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> keys &#123;</div><div class="line"></div><div class="line">            <span class="keyword">let</span> operation = <span class="type">NSBlockOperation</span>(block: &#123;</div><div class="line"></div><div class="line">                <span class="keyword">let</span> image = <span class="keyword">self</span>.readImage(key)</div><div class="line">                <span class="keyword">self</span>.showImage!(image)</div><div class="line">            &#125;)</div><div class="line"></div><div class="line">            operations.append(operation)</div><div class="line">        &#125;</div><div class="line">        getImageQueue.maxConcurrentOperationCount = <span class="built_in">max</span></div><div class="line">        getImageQueue.addOperations(operations, waitUntilFinished: <span class="literal">true</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showImg</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.delegete != <span class="literal">nil</span>) &amp;&amp; (<span class="keyword">self</span>.delegete?.userCache != <span class="literal">nil</span>) &#123;</div><div class="line">            <span class="keyword">self</span>.delegete?.userCache(<span class="keyword">self</span>, imageCache: <span class="keyword">self</span>.memCache)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">deleteImg</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.delegete != <span class="literal">nil</span>) &amp;&amp; (<span class="keyword">self</span>.delegete?.cleanCache != <span class="literal">nil</span>) &#123;</div><div class="line">            <span class="keyword">self</span>.delegete?.cleanCache(<span class="keyword">self</span>, imageCache: <span class="keyword">self</span>.memCache)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">DownloadDelegate</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> keys: <span class="type">NSArray</span>!</div><div class="line">    <span class="keyword">var</span> imgView: <span class="type">UIImageView</span>!</div><div class="line">    <span class="keyword">var</span> downloadBtn: <span class="type">UIButton</span>?</div><div class="line">    <span class="keyword">var</span> cleanBtn: <span class="type">UIButton</span>?</div><div class="line">    <span class="keyword">var</span> operation: <span class="type">DownloadOperation</span>!</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">        operation = <span class="type">DownloadOperation</span>()</div><div class="line">        operation.ininWithblock(showImage)</div><div class="line">        operation.delegete = <span class="keyword">self</span></div><div class="line"></div><div class="line">        downloadForKeys(<span class="number">3</span>)</div><div class="line">        addButton()</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">downloadForKeys</span><span class="params">(<span class="built_in">max</span>: Int)</span></span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> imgPaths = <span class="type">NSBundle</span>.mainBundle().pathForResource(<span class="string">"ImageLinks"</span>, ofType: <span class="string">"plist"</span>)</div><div class="line">        <span class="keyword">let</span> imgUrls = <span class="type">NSURL</span>(fileURLWithPath: imgPaths!)</div><div class="line">        <span class="keyword">self</span>.keys = <span class="type">NSArray</span>(contentsOfURL: imgUrls)!</div><div class="line">        operation.getImage(keys <span class="keyword">as</span>! [<span class="type">String</span>], <span class="built_in">max</span>: <span class="built_in">max</span>)</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showImage</span><span class="params">(image: UIImage)</span></span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">self</span>.imgView = <span class="type">UIImageView</span>(frame: <span class="keyword">self</span>.view.bounds)</div><div class="line">        <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.imgView!)</div><div class="line">        <span class="keyword">self</span>.imgView.image = image</div><div class="line">        <span class="built_in">print</span>(<span class="string">"block 加载图片"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addButton</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> width = <span class="keyword">self</span>.view.bounds.size.width</div><div class="line">        <span class="keyword">let</span> height = <span class="keyword">self</span>.view.bounds.size.height</div><div class="line"></div><div class="line">        <span class="keyword">self</span>.downloadBtn = <span class="type">UIButton</span>(type: .<span class="type">Custom</span>)</div><div class="line">        <span class="keyword">let</span> downloadBtnframe = <span class="type">CGRectMake</span>(<span class="number">20</span>, height-<span class="number">60</span>, <span class="number">80</span>, <span class="number">40</span>)</div><div class="line">        <span class="keyword">self</span>.downloadBtn?.frame = downloadBtnframe</div><div class="line">        <span class="keyword">self</span>.downloadBtn?.backgroundColor = <span class="type">UIColor</span>.lightGrayColor()</div><div class="line">        <span class="keyword">self</span>.downloadBtn?.titleLabel?.font = <span class="type">UIFont</span>.systemFontOfSize(<span class="number">18</span>)</div><div class="line">        <span class="keyword">self</span>.downloadBtn?.setTitle(<span class="string">"下载"</span>, forState: .<span class="type">Normal</span>)</div><div class="line"></div><div class="line">        <span class="keyword">self</span>.cleanBtn = <span class="type">UIButton</span>(type: .<span class="type">Custom</span>)</div><div class="line">        <span class="keyword">let</span> cleanBtnframe = <span class="type">CGRectMake</span>(width-<span class="number">80</span>-<span class="number">20</span>, height-<span class="number">60</span>, <span class="number">80</span>, <span class="number">40</span>)</div><div class="line">        <span class="keyword">self</span>.cleanBtn?.frame = cleanBtnframe</div><div class="line">        <span class="keyword">self</span>.cleanBtn?.backgroundColor = <span class="type">UIColor</span>.lightGrayColor()</div><div class="line">        <span class="keyword">self</span>.cleanBtn?.titleLabel?.font = <span class="type">UIFont</span>.systemFontOfSize(<span class="number">18</span>)</div><div class="line">        <span class="keyword">self</span>.cleanBtn?.setTitle(<span class="string">"清除"</span>, forState: .<span class="type">Normal</span>)</div><div class="line"></div><div class="line">        <span class="keyword">self</span>.downloadBtn?.addTarget(<span class="keyword">self</span>,</div><div class="line">                                    action: #selector(<span class="type">ViewController</span>.downloadBtnClicked),</div><div class="line">                                    forControlEvents: .<span class="type">TouchUpInside</span>)</div><div class="line"></div><div class="line">        <span class="keyword">self</span>.cleanBtn?.addTarget(<span class="keyword">self</span>,</div><div class="line">                                    action: #selector(<span class="type">ViewController</span>.cleanBtnClicked),</div><div class="line">                                    forControlEvents: .<span class="type">TouchUpInside</span>)</div><div class="line"></div><div class="line">        <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.downloadBtn!)</div><div class="line">        <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.cleanBtn!)</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userCache</span><span class="params">(operation: DownloadOperation, imageCache: NSCache)</span></span> &#123;</div><div class="line"></div><div class="line">        imgView.removeFromSuperview()</div><div class="line"></div><div class="line">        <span class="keyword">let</span> width = <span class="keyword">self</span>.view.bounds.size.width</div><div class="line">        <span class="keyword">let</span> imgHeight = <span class="keyword">self</span>.view.bounds.size.height / <span class="type">CGFloat</span>(<span class="type">Float</span>(keys.<span class="built_in">count</span>))</div><div class="line"></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; keys.<span class="built_in">count</span> &#123;</div><div class="line"></div><div class="line">            <span class="keyword">let</span> frame = <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="type">CGFloat</span>(i) * imgHeight, width, imgHeight)</div><div class="line">            <span class="keyword">let</span> imageView = <span class="type">UIImageView</span>(frame: frame)</div><div class="line">            <span class="keyword">let</span> key = keys[i] <span class="keyword">as</span>! <span class="type">String</span></div><div class="line">            <span class="keyword">let</span> image = operation.readImage(key)</div><div class="line">            imageView.image = image</div><div class="line">            imageView.contentMode = .<span class="type">ScaleToFill</span></div><div class="line">            <span class="keyword">self</span>.view.addSubview(imageView)</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">cleanCache</span> <span class="params">(operation: DownloadOperation, imageCache:NSCache)</span></span> &#123;</div><div class="line"></div><div class="line">        imageCache.removeAllObjects()</div><div class="line"></div><div class="line">        <span class="keyword">for</span> subView <span class="keyword">in</span> <span class="keyword">self</span>.view.subviews &#123;</div><div class="line">            subView.removeFromSuperview()</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> keys &#123;</div><div class="line"></div><div class="line">            <span class="keyword">let</span> temKey = operation.diskPathForKey(key <span class="keyword">as</span>! <span class="type">String</span>)</div><div class="line">            operation.deleteFile(temKey)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        addButton()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">downloadBtnClicked</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">        operation.showImg()</div><div class="line">        addButton()</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">cleanBtnClicked</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">        operation.deleteImg()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;线程可以理解为下载的通道，一个线程就是一个文件的下载通道，多线程也就是同时开起好几个下载通道.当服务器提供下载服务时，使用下载者是共享带宽的，在优先级相同的情况下，总服务器会对总下载线程进行平均分配。不难理解，如果你线程多的话，那下载的越快。现流行的下载软件都支持多线程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面我们通过代码来了解以下几个知识点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多线程下载；&lt;/li&gt;
&lt;li&gt;自定义 NSOperation ；&lt;/li&gt;
&lt;li&gt;NSCache 增删改查；&lt;/li&gt;
&lt;li&gt;NSFileManager 增删改查；&lt;/li&gt;
&lt;li&gt;代理模式；&lt;/li&gt;
&lt;li&gt;闭包反向传值；&lt;/li&gt;
&lt;li&gt;扩展方法；&lt;/li&gt;
&lt;li&gt;Plist 文件解析；&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="闭包" scheme="http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="文件管理" scheme="http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
      <category term="代理模式" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Plist" scheme="http://yoursite.com/tags/Plist/"/>
    
  </entry>
  
  <entry>
    <title>微信开发 - 快速入门</title>
    <link href="http://yoursite.com/2016/09/02/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%20-%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2016/09/02/微信开发 - 快速入门/</id>
    <published>2016-09-01T18:24:00.000Z</published>
    <updated>2016-09-02T12:03:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>微信是一个生活方式，张小龙提出的这个愿景已经得到了越来越清晰的体现。</p>
</blockquote>
<p>群聊、语音、视频，照片/视频/位置共享，支付和商店都有了，还能通过公众账号来获取各种资源……</p>
<p>如今的微信就是在日中天的状态，公众平台带来的影响有目共睹，所以很多公司和个人都希望有自己的公众号，想充分利用却无处下手，下面我们分为几篇文章，由浅入深的了解微信开发。</p>
<p>在下面的学习中，需要你具有PHP语言的基础，并拥有一台具有PHP运行环境的主机，如果还没有可以通过新浪SAE，阿里云ECS等进行搭建。</p>
<p>下面进入正题！</p>
   <a id="more"></a>
<h2 id="接入开发者模式"><a href="#接入开发者模式" class="headerlink" title="接入开发者模式"></a>接入开发者模式</h2><p>接入开发者模式非常简单，主要分下面几个步骤：</p>
<ol>
<li>下载官方接口文件；</li>
<li>简单调整接口文件的代码；</li>
<li>将调整好的接口文件上传到服务器；</li>
<li>在开发者后台进行接口的验证；</li>
</ol>
<p>首先下载PHP接口文件，下载地址请点击<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421135319&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信公众平台开发者文档</a>。</p>
<p>将原有的代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">define(<span class="string">"TOKEN"</span>, <span class="string">"weixin"</span>);</div><div class="line">$wechatObj = <span class="keyword">new</span> wechatCallbackapiTest();</div><div class="line">$wechatObj-&gt;valid();</div></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">define(<span class="string">"TOKEN"</span>, <span class="string">"wechat"</span>);</div><div class="line"></div><div class="line">$wechatObj = <span class="keyword">new</span> wechatCallbackapiTest();</div><div class="line"></div><div class="line"><span class="keyword">if</span> ($_GET[<span class="string">"echostr"</span>]) &#123;</div><div class="line">    $wechatObj-&gt;valid();</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    $wechatObj-&gt;responseMsg();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后将修改后的PHP文件上传至你的服务器，进入：</p>
<blockquote>
<p>微信公众平台 &gt; 开发 &gt; 基本配置 &gt; 服务器配置 &gt; 修改配置</p>
</blockquote>
<p>在弹出的<strong>基本配置/ 填写服务器配置</strong>中：</p>
<blockquote>
<p>URL填写你的PHP文件地址，如：<code>https://localhost/filepath/wx_sample.php</code> ；</p>
<p>Token填写你在PHP文件中设定的值，如：<code>define(&quot;TOKEN&quot;, &quot;wechat&quot;);</code>，填写<code>wechat</code> ；</p>
<p>EncodingAESKey使用<code>随机生成</code>即可；</p>
<p>消息加解密方式选择<code>明文模式</code>即可；</p>
</blockquote>
<p>点击提交，就完成了开发者模式的接入。</p>
<h2 id="开发者模式下数据传输及处理"><a href="#开发者模式下数据传输及处理" class="headerlink" title="开发者模式下数据传输及处理"></a>开发者模式下数据传输及处理</h2><p> <img src="http://oboehz2ag.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93.gif" alt="微信开发模式数据传输"></p>
<p>了解开发者模式下的数据传输后，我们开始编写第一个程序。</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>没错，就是从它开始……</p>
<p>实现Hello World非常简单，首先编写程序代码，将PHP文件中原代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>( $keyword )) &#123;</div><div class="line">	$msgType = <span class="string">"text"</span>;</div><div class="line">	$contentStr = <span class="string">"Welcome to wechat world!"</span>;</div><div class="line">	$resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">	<span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"Input something..."</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>( $keyword )) &#123;</div><div class="line">	$msgType = <span class="string">"text"</span>;</div><div class="line">	$contentStr = $keyword.<span class="string">"World"</span>;</div><div class="line">	$resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">	<span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"Input something..."</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时，向你的公众号发送一个<code>Hello</code>，就会返回一个<code>Hello World</code>，相信大家都已经明白，<strong><code>$keyword</code>这个变量，就是用户发送的文本信息</strong>。</p>
<p>这时当用户发送语音，图片，位置等信息时，因为PHP文件对此没有进行对应的处理，所以用户设备会收到<strong>该公众号暂时无法提供服务，请稍后再试</strong>。</p>
<h2 id="被动回复消息"><a href="#被动回复消息" class="headerlink" title="被动回复消息"></a>被动回复消息</h2><p>当用户发送消息给公众号时（或某些特定的用户操作引发的事件推送时），会产生一个POST请求，开发者可以在响应包（Get）中返回特定XML结构，来对该消息进行响应（现支持回复文本、图片、图文、语音、视频、音乐）。严格来说，发送被动响应消息其实并不是一种接口，而是对微信服务器发过来消息的一次回复。</p>
<p><strong>一旦遇到以下情况，微信都会在公众号会话中，向用户下发系统提示“该公众号暂时无法提供服务，请稍后再试”：</strong></p>
<blockquote>
<p>1、开发者在5秒内未回复任何内容</p>
<p>2、开发者回复了异常数据，比如JSON数据等</p>
</blockquote>
<p>另外，请注意，回复图片等多媒体消息时需要预先通过素材管理接口上传临时素材到微信服务器，可以使用素材管理中的临时素材，也可以使用永久素材。</p>
<p>被动回复支持的消息类型有：</p>
<p><strong>文本、图片、语音、视频、音乐</strong></p>
<p>当然，还有可以包括以上所有类型的<strong>图文消息</strong>。</p>
<p>各消息类型是由XML数据包构成，关于数据包的格式请访问<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140543&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信开发者文档</a>。</p>
<h2 id="关注事件处理"><a href="#关注事件处理" class="headerlink" title="关注事件处理"></a>关注事件处理</h2><p>用户在关注与取消关注公众号时，微信会把这个事件推送到开发者填写的URL。方便开发者给用户下发欢迎消息或者做帐号的解绑。</p>
<p><strong>关注事件实际上是获取Event事件类型，并设置不同消息类型的XML数据包推送到用户设备</strong>。</p>
<p>推送XML数据包示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[FromUser]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>123456789<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[event]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Event</span>&gt;</span>&lt;![CDATA[subscribe]]&gt;<span class="tag">&lt;/<span class="name">Event</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></div></pre></td></tr></table></figure>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ToUserName</td>
<td>开发者微信号</td>
</tr>
<tr>
<td>FromUserName</td>
<td>发送方帐号（一个OpenID）</td>
</tr>
<tr>
<td>CreateTime</td>
<td>消息创建时间 （整型）</td>
</tr>
<tr>
<td>MsgType</td>
<td>消息类型，event</td>
</tr>
<tr>
<td>Event</td>
<td>事件类型，subscribe(订阅)、unsubscribe(取消订阅)</td>
</tr>
</tbody>
</table>
<h3 id="关注事件文字回复"><a href="#关注事件文字回复" class="headerlink" title="关注事件文字回复"></a>关注事件文字回复</h3><p>首先我们需要获取Event参数，并对Event进行相应的处理：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$postObj = simplexml_load_string($postStr, <span class="string">'SimpleXMLElement'</span>, LIBXML_NOCDATA);</div><div class="line">$fromUsername = $postObj-&gt;FromUserName;</div><div class="line">$toUsername = $postObj-&gt;ToUserName;</div><div class="line">$keyword = trim($postObj-&gt;Content);</div><div class="line">$event = $postObj-&gt;Event;</div><div class="line">$time = time();</div><div class="line">$textTpl = <span class="string">"&lt;xml&gt;</span></div><div class="line">			&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;</div><div class="line">			&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;</div><div class="line">			&lt;CreateTime&gt;%s&lt;/CreateTime&gt;</div><div class="line">			&lt;MsgType&gt;&lt;![CDATA[%s]]&gt;&lt;/MsgType&gt;</div><div class="line">			&lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt;</div><div class="line">			&lt;FuncFlag&gt;0&lt;/FuncFlag&gt;</div><div class="line">			&lt;/xml&gt;";</div><div class="line"></div><div class="line"><span class="keyword">if</span> ($event == <span class="string">"subscribe"</span>) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"订阅事件"</span>;</div><div class="line">    $msgType = <span class="string">"text"</span>;</div><div class="line">    $contentStr = <span class="string">"欢迎关注superliar"</span>;</div><div class="line">    $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">    <span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">elseif</span> ($event == <span class="string">"unsubscribe"</span>) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"取消订阅事件"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时我们取消关注的公众号，再重新关注它，会收到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">欢迎关注superliar</div></pre></td></tr></table></figure>
<h3 id="关注事件图文回复"><a href="#关注事件图文回复" class="headerlink" title="关注事件图文回复"></a>关注事件图文回复</h3><p>图文消息的XML包结构如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[fromUser]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>12345678<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[news]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ArticleCount</span>&gt;</span>2<span class="tag">&lt;/<span class="name">ArticleCount</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Articles</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Title</span>&gt;</span>&lt;![CDATA[title1]]&gt;<span class="tag">&lt;/<span class="name">Title</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">Description</span>&gt;</span>&lt;![CDATA[description1]]&gt;<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">PicUrl</span>&gt;</span>&lt;![CDATA[picurl]]&gt;<span class="tag">&lt;/<span class="name">PicUrl</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Url</span>&gt;</span>&lt;![CDATA[url]]&gt;<span class="tag">&lt;/<span class="name">Url</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Title</span>&gt;</span>&lt;![CDATA[title]]&gt;<span class="tag">&lt;/<span class="name">Title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Description</span>&gt;</span>&lt;![CDATA[description]]&gt;<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">PicUrl</span>&gt;</span>&lt;![CDATA[picurl]]&gt;<span class="tag">&lt;/<span class="name">PicUrl</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Url</span>&gt;</span>&lt;![CDATA[url]]&gt;<span class="tag">&lt;/<span class="name">Url</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">Articles</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></div></pre></td></tr></table></figure>
<p>参数说明如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ToUserName</td>
<td>是</td>
<td>接收方帐号（收到的OpenID）</td>
</tr>
<tr>
<td>FromUserName</td>
<td>是</td>
<td>开发者微信号</td>
</tr>
<tr>
<td>CreateTime</td>
<td>是</td>
<td>消息创建时间 （整型）</td>
</tr>
<tr>
<td>MsgType</td>
<td>是</td>
<td>news</td>
</tr>
<tr>
<td>ArticleCount</td>
<td>是</td>
<td>图文消息个数，限制为10条以内</td>
</tr>
<tr>
<td>Articles</td>
<td>是</td>
<td>多条图文消息信息，默认第一个item为大图,注意，如果图文数超过10，则将会无响应</td>
</tr>
<tr>
<td>Title</td>
<td>否</td>
<td>图文消息标题</td>
</tr>
<tr>
<td>Description</td>
<td>否</td>
<td>图文消息描述</td>
</tr>
<tr>
<td>PicUrl</td>
<td>否</td>
<td>图片链接，支持JPG、PNG格式，较好的效果为大图360<em>200，小图200</em>200</td>
</tr>
<tr>
<td>Url</td>
<td>否</td>
<td>点击图文消息跳转链接</td>
</tr>
</tbody>
</table>
<p><code>MsgTyp</code>描述的是推送消息的类型，如<code>text\image\voice\video\music\news</code>等。</p>
<p>首先定义一个图文消息类型的XML包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">$newsTpl = "<span class="tag">&lt;<span class="name">xml</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[%s]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[%s]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>%s<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[%s]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">ArticleCount</span>&gt;</span>2<span class="tag">&lt;/<span class="name">ArticleCount</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">Articles</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">item</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">Title</span>&gt;</span>&lt;![CDATA[欢迎关注superliar]]&gt;<span class="tag">&lt;/<span class="name">Title</span>&gt;</span> </div><div class="line">           <span class="tag">&lt;<span class="name">Description</span>&gt;</span>&lt;![CDATA[superliar是一个真人秀节目,balabalabalabalabalabalabalabala]]&gt;<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">PicUrl</span>&gt;</span>&lt;![CDATA[http://i2.hdslb.com/bfs/archive/e4d44a24ef5b838db63ac6c4c5fda0302102fb23.jpg]]&gt;<span class="tag">&lt;/<span class="name">PicUrl</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">Url</span>&gt;</span>&lt;![CDATA[http://www.panda.tv/]]&gt;<span class="tag">&lt;/<span class="name">Url</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">item</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">Title</span>&gt;</span>&lt;![CDATA[玩狼人杀有什么独家技巧?]]&gt;<span class="tag">&lt;/<span class="name">Title</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">Description</span>&gt;</span>&lt;![CDATA[一个玩家做了什么不重要，重要的是要知道ta为什么这么做。]]&gt;<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">PicUrl</span>&gt;</span>&lt;![CDATA[http://i0.hdslb.com/bfs/archive/b957f527aadaddc3c32287f0ff5c1858df696658.jpg]]&gt;<span class="tag">&lt;/<span class="name">PicUrl</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">Url</span>&gt;</span>&lt;![CDATA[https://www.zhihu.com/question/25833846]]&gt;<span class="tag">&lt;/<span class="name">Url</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">Articles</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">xml</span>&gt;</span>";</div></pre></td></tr></table></figure>
<p>然后将订阅的Event事件处理修改为：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ($event == <span class="string">"subscribe"</span>) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"订阅事件"</span>;</div><div class="line">    $msgType = <span class="string">"news"</span>;</div><div class="line">    $resultStr = sprintf($newsTpl, $fromUsername, $toUsername, $time, $msgType);</div><div class="line">    <span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">elseif</span> ($event == <span class="string">"unsubscribe"</span>) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"取消订阅事件"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时再重新关注，收到的就是一条图文消息了，其他类型的消息也是同样的原理。</p>
<h2 id="关键字触发事件"><a href="#关键字触发事件" class="headerlink" title="关键字触发事件"></a>关键字触发事件</h2><p>关键字触发一般用于运营活动中，即用户发送一条特定的消息，服务器返回一条特定的消息。</p>
<h3 id="返回文本消息"><a href="#返回文本消息" class="headerlink" title="返回文本消息"></a>返回文本消息</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>( $keyword )) &#123;</div><div class="line">    <span class="keyword">if</span> ($keyword == <span class="string">"text"</span>) &#123;</div><div class="line">        $msgType = <span class="string">"text"</span>;</div><div class="line">        $contentStr = <span class="string">"您发送了"</span>.$keyword;</div><div class="line">        $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">        <span class="keyword">echo</span> $resultStr;</div><div class="line">    &#125;</div><div class="line">	$msgType = <span class="string">"text"</span>;</div><div class="line">	$contentStr = <span class="string">"Hello World"</span>;</div><div class="line">	$resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">	<span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"Input something..."</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时用户输入<code>text</code>，就会收到服务器返回的<code>您发送了text</code>。用户发送其他信息，则返回<code>Hello World</code>。</p>
<h3 id="返回图文消息"><a href="#返回图文消息" class="headerlink" title="返回图文消息"></a>返回图文消息</h3><p>重新定义一个图文消息XML数据包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$newsNoImgTpl = "<span class="tag">&lt;<span class="name">xml</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[%s]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[%s]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>%s<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[%s]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">ArticleCount</span>&gt;</span>1<span class="tag">&lt;/<span class="name">ArticleCount</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">Articles</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">item</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">Title</span>&gt;</span>&lt;![CDATA[欢迎关注superliar]]&gt;<span class="tag">&lt;/<span class="name">Title</span>&gt;</span> </div><div class="line">            <span class="tag">&lt;<span class="name">Description</span>&gt;</span>&lt;![CDATA[superliar是一个真人秀节目,balabalabalabalabalabalabalabala]]&gt;<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">Url</span>&gt;</span>&lt;![CDATA[http://www.panda.tv/]]&gt;<span class="tag">&lt;/<span class="name">Url</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">Articles</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">xml</span>&gt;</span>";</div></pre></td></tr></table></figure>
<p>触发事件设置为：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>( $keyword )) &#123;</div><div class="line">    <span class="keyword">if</span> ($keyword == <span class="string">"text"</span>) &#123;</div><div class="line">        $msgType = <span class="string">"text"</span>;</div><div class="line">        $contentStr = <span class="string">"您发送了"</span>.$keyword;</div><div class="line">        $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">        <span class="keyword">echo</span> $resultStr;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ($keyword == <span class="string">"news"</span>) &#123;</div><div class="line">        $msgType = <span class="string">"news"</span>;</div><div class="line">        $resultStr = sprintf($newsNoImgTpl, $fromUsername, $toUsername, $time, $msgType);</div><div class="line">        <span class="keyword">echo</span> $resultStr;</div><div class="line">    &#125;</div><div class="line">	$msgType = <span class="string">"text"</span>;</div><div class="line">	$contentStr = <span class="string">"Hello World"</span>;</div><div class="line">	$resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">	<span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"Input something..."</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时当用户发送news时，就会收到一条无图的图文消息。</p>
<h2 id="接收不同类型消息"><a href="#接收不同类型消息" class="headerlink" title="接收不同类型消息"></a>接收不同类型消息</h2><p>如果要接收处理不同类型的消息，首先要获取用户发送的消息类型：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$msgType = $postObj-&gt;MsgType;</div></pre></td></tr></table></figure>
<p>此时可针对用户发送的不同类型的消息，进行对应的处理：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ($msgType == <span class="string">"image"</span>) &#123;</div><div class="line">    $msgType = <span class="string">"text"</span>;</div><div class="line">    $contentStr = <span class="string">"您发送了image类型的消息,服务器返回text类型消息"</span>;</div><div class="line">    $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">    <span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">elseif</span> ($msgType == <span class="string">"voice"</span>) &#123;</div><div class="line">    $msgType = <span class="string">"text"</span>;</div><div class="line">    $contentStr = <span class="string">"您发送了voice类型的消息,服务器返回text类型消息"</span>;</div><div class="line">    $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">    <span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">elseif</span> ($msgType == <span class="string">"video"</span>) &#123;</div><div class="line">    $msgType = <span class="string">"text"</span>;</div><div class="line">    $contentStr = <span class="string">"您发送了video类型的消息,服务器返回text类型消息"</span>;</div><div class="line">    $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">    <span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">elseif</span> ($msgType == <span class="string">"music"</span>) &#123;</div><div class="line">    $msgType = <span class="string">"text"</span>;</div><div class="line">    $contentStr = <span class="string">"您发送了music类型的消息,服务器返回text类型消息"</span>;</div><div class="line">    $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);</div><div class="line">    <span class="keyword">echo</span> $resultStr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Demo下载请点击这里"><a href="#Demo下载请点击这里" class="headerlink" title="Demo下载请点击这里"></a>Demo下载请<a href="https://github.com/tianziyao/demo" target="_blank" rel="external">点击这里</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;微信是一个生活方式，张小龙提出的这个愿景已经得到了越来越清晰的体现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;群聊、语音、视频，照片/视频/位置共享，支付和商店都有了，还能通过公众账号来获取各种资源……&lt;/p&gt;
&lt;p&gt;如今的微信就是在日中天的状态，公众平台带来的影响有目共睹，所以很多公司和个人都希望有自己的公众号，想充分利用却无处下手，下面我们分为几篇文章，由浅入深的了解微信开发。&lt;/p&gt;
&lt;p&gt;在下面的学习中，需要你具有PHP语言的基础，并拥有一台具有PHP运行环境的主机，如果还没有可以通过新浪SAE，阿里云ECS等进行搭建。&lt;/p&gt;
&lt;p&gt;下面进入正题！&lt;/p&gt;
    
    </summary>
    
      <category term="微信开发" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="微信开发" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>微信开发 - 公众平台简介</title>
    <link href="http://yoursite.com/2016/09/02/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%20-%20%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2016/09/02/微信开发 - 公众平台简介/</id>
    <published>2016-09-01T18:24:00.000Z</published>
    <updated>2016-09-02T11:50:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>微信开发即微信公众平台开发，将企业信息、服务、活动等内容通过微信网页的方式进行表现，用户通过简单的设置，就能生成微信3G网站。通过微信公众平台将企业品牌展示给微信用户，减少宣传成本，建立企业与消费者、客户的一对一互动和沟通，将消费者接入企业CRM系统，进行促销、推广、宣传、售后等。形成了一种主流的线上线下微信互动营销方式。</p>
<p>通过二次开发可以将公众账号由一个媒体型营销工具转化成提供服务的产品。而一旦成为用户需要的产品，公众账号的营销功能便会开启。<br>微信的核心是通讯工具，这一工具属性将用户牢牢地黏在了平台之上。用户和企业可以非常方便地在上面进行沟通，所以微信很自然地就成了企业的CRM(客户管理系统)平台来面对忠实用户，这也给了企业将服务引入平台的机会。</p>
   <a id="more"></a>
<h2 id="主要模板"><a href="#主要模板" class="headerlink" title="主要模板"></a>主要模板</h2><p>微信公众账号不会做太多深度的开放，为了把微信做得更“轻”。在2013年6月份的合作伙伴大会上，微信产品部助理曾鸣提出，微信公众账号不是一个纯粹的营销工具，让公众账号提供最体现企业价值的东西。</p>
<ul>
<li>在线营销：向终端客户推荐新品、促销策略等；</li>
<li>售后服务：通过微信平台，自动与客户进行交互，展示企业产品、售后支持；</li>
<li>电子商务：将企业网站或购物平台与微信对接，推荐到朋友圈获取免费宣传；</li>
<li>会员管理：企业会员可通过微信平台进行线下活动预约、积分管理等操作。</li>
</ul>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>公众平台是企业在OTT产品基础上新增的功能模块，基于“再小的个体也有自己品牌”这一理念。通过这一平台，个人和企业都可以打造一个公众号，并实现和特定群体的文字、图片、语音的全方位沟通、互动。同时，企业也可以利用公众平台进行CRM式管理，个人可以进行自媒体创作。</p>
<h3 id="微信官网"><a href="#微信官网" class="headerlink" title="微信官网"></a>微信官网</h3><ol>
<li>公司介绍：支持多级分类；</li>
<li>产品展示：产品支持多图显示，手指滑动浏览图片；</li>
<li>新闻资讯：对接微信公众平台消息推送；</li>
<li>联系方式：LBS地图位置标注，点击电话号码直接拨打；</li>
<li>信息推送：以微信官方规定的消息推送为标准。</li>
</ol>
<h3 id="微信客服"><a href="#微信客服" class="headerlink" title="微信客服"></a>微信客服</h3><ol>
<li>多人工客服：实现多个人工客服在线与微信公众平台客户沟通；</li>
<li>LBS位置服务：用户经过微信提供位置，公众平台自动应答离用户最近的门店、经销商；</li>
<li>建议/投诉/售后：微信平台内嵌售后服务表单。</li>
</ol>
<h3 id="微信商城"><a href="#微信商城" class="headerlink" title="微信商城"></a>微信商城</h3><ol>
<li>在线订购：支持现有商城系统进行对接；</li>
<li>会员系统：支持现有会员系统进行对接；</li>
<li>在线支付：支持在线支付功能，若无需在线支付，则只记录订单信息与流程。</li>
</ol>
<h3 id="活动与促销"><a href="#活动与促销" class="headerlink" title="活动与促销"></a>活动与促销</h3><ol>
<li>活动发布：软商系统直接对接微信平台发布；</li>
<li>抽奖刮刮卡：支持系统自定义奖品。</li>
<li>抽奖转盘：支持系统自定义奖品。</li>
</ol>
<h2 id="开放接口"><a href="#开放接口" class="headerlink" title="开放接口"></a>开放接口</h2><p>公众平台推出新的认证体系，微信将免费开放地理位置、客服、语音等九大高级技术接口 。针对服务号领域，微信还将推出一些垂直领域定制。微信产品部模式识别中心总监陈波透露，图像识别还将与微信支付结合，提供购买流程。这两个技术主要为公众平台提供服务，后续将向App开放。</p>
<ol>
<li>语音识别接口</li>
<li>客服接口</li>
<li>OAuth2.0 网页授权接口</li>
<li>生成带参数的二维码接口</li>
<li>获取用户地理位置接口</li>
<li>获取用户基本信息接口</li>
<li>获取关注者列表接口</li>
<li>用户分组接口</li>
<li>上传下载多媒体文件接口</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信开发即微信公众平台开发，将企业信息、服务、活动等内容通过微信网页的方式进行表现，用户通过简单的设置，就能生成微信3G网站。通过微信公众平台将企业品牌展示给微信用户，减少宣传成本，建立企业与消费者、客户的一对一互动和沟通，将消费者接入企业CRM系统，进行促销、推广、宣传、售后等。形成了一种主流的线上线下微信互动营销方式。&lt;/p&gt;
&lt;p&gt;通过二次开发可以将公众账号由一个媒体型营销工具转化成提供服务的产品。而一旦成为用户需要的产品，公众账号的营销功能便会开启。&lt;br&gt;微信的核心是通讯工具，这一工具属性将用户牢牢地黏在了平台之上。用户和企业可以非常方便地在上面进行沟通，所以微信很自然地就成了企业的CRM(客户管理系统)平台来面对忠实用户，这也给了企业将服务引入平台的机会。&lt;/p&gt;
    
    </summary>
    
      <category term="微信开发" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="微信开发" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程 - 同步线程</title>
    <link href="http://yoursite.com/2016/08/24/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%20%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/08/24/iOS多线程之 同步线程/</id>
    <published>2016-08-23T21:09:00.000Z</published>
    <updated>2017-01-24T15:48:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>比如你去银行存10K，在用ATM存的同时，又使用网银取了10K，如果线程同步做的不好的话， 虽然取10K元的操作会有记录，但是可能不会反映在余额上。如果要解决这样的问题，就需要用到线程同步，线程同步在开发过程中是非常常见的。下面我们以12306为例，尝试解决如何保证一张票不会被不同窗口，不同客户端重复购买。</p>
</blockquote>
<p>首先我们来认识一下互斥锁的概念：</p>
<blockquote>
<p><strong>互斥锁</strong>（英语：Mutual exclusion，缩写 Mutex）是一种用于<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%BA%BF%E7%A8%8B" target="_blank" rel="external">多线程</a><a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B" target="_blank" rel="external">编程</a>中，防止两条<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B" target="_blank" rel="external">线程</a>同时对同一公共资源（比如<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F" target="_blank" rel="external">全局变量</a>）进行读写的机制。该目的通过将代码切片成一个一个的<a href="https://zh.wikipedia.org/wiki/%E4%B8%B4%E7%95%8C%E5%8C%BA%E5%9F%9F" target="_blank" rel="external">临界区域</a>（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。</p>
</blockquote>
<p>以上是维基百科给出的解释，如需了解更多请 <a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E6%96%A5%E9%94%81" target="_blank" rel="external">点击这里</a>。</p>
<p>简单来讲，互斥锁是为了防止多个线程访问同一个对象、方法、变量、文件等引起的数据错误。</p>
<a id="more"></a>
<p>当上一个线程的任务没有执行完毕的时候（被锁住），那么下一个线程会进入睡眠状态等待任务执行完毕， 当上一个线程的任务执行完毕，下一个线程会自动唤醒然后执行任务。</p>
<p>互斥锁是同步锁的一种，与它同级的还有递归锁、条件锁、自旋锁。其余几种作者认识并不是很深入，先简单提一下。下面我们使用代码来了解互斥锁：</p>
<h4 id="objc-sync-enter-和-objc-sync-exit"><a href="#objc-sync-enter-和-objc-sync-exit" class="headerlink" title="objc_sync_enter 和 objc_sync_exit"></a>objc_sync_enter 和 objc_sync_exit</h4><p>表达式如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">objc_sync_enter(<span class="keyword">self</span>)</div><div class="line"><span class="comment">//需要执行的代码块</span></div><div class="line">objc_sync_exit(<span class="keyword">self</span>)</div></pre></td></tr></table></figure>
<p>其中的 <code>self</code> 代表一把锁，它的传入值是任意一个对象，如果多线程访问同一个资源，那么必须使用同一把锁才能锁住。因为必须使用同一把锁，开发中如果需要加锁，通常我们可以直接使用 <code>self</code> 即可。</p>
<p>下面我们来运用 <code>objc_sync_enter</code> 和 <code>objc_sync_exit</code>。</p>
<p>首先创建一个变量，代表当前车票的数量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> iTicketCount: <span class="type">Int</span> = <span class="number">10</span></div></pre></td></tr></table></figure>
<p>接下来，我们使用 <code>NSBlockOperation</code> 实例并添加任务，当票数大于 0 时，票数就可以自减 1，直到票数等于 0，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let saleTicketOne = NSBlockOperation()</div><div class="line">saleTicketOne.addExecutionBlock &#123;</div><div class="line"></div><div class="line">    while self.iTicketCount &gt; 0 &#123;</div><div class="line">        objc_sync_enter(self)</div><div class="line">            self.iTicketCount -= 1</div><div class="line">            print("当前线程是 \(NSThread.currentThread()) 剩余票数\</div><div class="line">            objc_sync_exit(self)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道，<code>NSBlockOperation</code> 本身是不具备开线程的能力的，<code>NSBlockOperationQueue</code>才可以开线程，而 <code>NSBlockOperationQueue</code> 是否可以开线程，又取决于任务的数量，现在我们的任务数只有一个，如果要使用线程同步，必须是两个以上的线程，所以我们再创建一个 <code>NSBlockOperation</code>。将两个任务添加到队列中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> saleTicketTwo = <span class="type">NSBlockOperation</span>()</div><div class="line">saleTicketTwo.addExecutionBlock &#123;</div><div class="line">    <span class="keyword">while</span> <span class="keyword">self</span>.iTicketCount &gt; <span class="number">0</span> &#123;</div><div class="line">        objc_sync_enter(<span class="keyword">self</span>)</div><div class="line">        <span class="keyword">self</span>.iTicketCount -= <span class="number">1</span></div><div class="line">            <span class="built_in">print</span>(<span class="string">"当前线程是 <span class="subst">\(NSThread.currentThread()</span>) 剩余票数<span class="subst">\(<span class="keyword">self</span>.iTicketCount)</span>"</span> )</div><div class="line">        objc_sync_exit(<span class="keyword">self</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> queue = <span class="type">NSOperationQueue</span>()</div><div class="line">queue.addOperation(saleTicketOne)</div><div class="line">queue.addOperation(saleTicketTwo)</div></pre></td></tr></table></figure>
<p>打印日志如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b6635d0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125; 剩余票数<span class="number">9</span></div><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b6653c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125; 剩余票数<span class="number">8</span></div><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b6635d0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125; 剩余票数<span class="number">7</span></div><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b6653c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125; 剩余票数<span class="number">6</span></div><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b6635d0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125; 剩余票数<span class="number">5</span></div><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b6653c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125; 剩余票数<span class="number">4</span></div><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b6635d0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125; 剩余票数<span class="number">3</span></div><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b6653c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125; 剩余票数<span class="number">2</span></div><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b6635d0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125; 剩余票数<span class="number">1</span></div><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b6653c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125; 剩余票数<span class="number">0</span></div><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b6635d0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125; 剩余票数-<span class="number">1</span></div></pre></td></tr></table></figure>
<p>可以看出我们开启了两条线程，使用互斥锁执行同一个任务，结果是两条线程交叉执行这个任务，结果基本符合预期，但是在票数上却有问题，那么造成这个问题的原因是什么呢？</p>
<p>因为这两个线程是并发执行，在票数等于 1 时，一个线程通过 <code>while self.iTicketCount &gt; 0</code> 的判断，然后一个线程也进入了这个判断，前面的进程遇到 <code>objc_sync_enter(self)</code>  ，进入加锁执行，输出了 0，然后解锁。另一个进程也进入加锁执行，此时了票数为 0，所以输出了 -1。</p>
<p>如果说因为条件判断通过，所以造成了结果的错误，那么我们将条件判断 <code>while self.iTicketCount &gt; 0</code> 也加入锁的范围内，会怎样呢？</p>
<p>我们将代码改成这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let saleTicketOne = NSBlockOperation()</div><div class="line">saleTicketOne.addExecutionBlock &#123;</div><div class="line">    objc_sync_enter(self)</div><div class="line">    while self.iTicketCount &gt; 0 &#123;</div><div class="line">            self.iTicketCount -= 1</div><div class="line">            print("当前线程是 \(NSThread.currentThread()) 剩余票数\</div><div class="line">    &#125;</div><div class="line">    objc_sync_exit(self)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印日志如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b74f560</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125; 剩余票数<span class="number">9</span></div><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b74f560</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125; 剩余票数<span class="number">8</span></div><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b74f560</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125; 剩余票数<span class="number">7</span></div><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b74f560</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125; 剩余票数<span class="number">6</span></div><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b74f560</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125; 剩余票数<span class="number">5</span></div><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b74f560</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125; 剩余票数<span class="number">4</span></div><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b74f560</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125; 剩余票数<span class="number">3</span></div><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b74f560</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125; 剩余票数<span class="number">2</span></div><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b74f560</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125; 剩余票数<span class="number">1</span></div><div class="line">当前线程是 &lt;<span class="type">NSThread</span>: <span class="number">0x7b74f560</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125; 剩余票数<span class="number">0</span></div></pre></td></tr></table></figure>
<p>可以看出，只有一条线程执行任务，那么可以说明，只会有一个线程执行完整个任务后，另一个进程才会执行，但此时它已经没有任务可做了。这样也不对，那么正确做法是怎样的呢？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> saleTicketTwo = <span class="type">NSBlockOperation</span>()</div><div class="line">saleTicketTwo.addExecutionBlock &#123;</div><div class="line">    <span class="keyword">while</span> <span class="keyword">self</span>.iTicketCount &gt; <span class="number">0</span> &#123;</div><div class="line">        objc_sync_enter(<span class="keyword">self</span>)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.iTicketCount &gt; <span class="number">0</span> &#123;</div><div class="line">            <span class="keyword">self</span>.iTicketCount -= <span class="number">1</span></div><div class="line">            <span class="built_in">print</span>(<span class="string">"当前线程是 <span class="subst">\(NSThread.currentThread()</span>) 剩余票数<span class="subst">\(<span class="keyword">self</span>.iTicketCount)</span>"</span> )</div><div class="line">            objc_sync_exit(<span class="keyword">self</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在 <code>objc_sync_enter(self)</code> 再加入一条判断，<code>if self.iTicketCount &gt; 0</code> 那么输出的结果就没有问题了，可以看到，加锁的位置和条件的判断在同步进程中是非常重要的，如果同步线程的加锁位置和判断条件没有做好，可能会出现这段代码还没有执行，另一个线程中已经执行了，因此造成数据存取的不一致，下面我们来了解一下使用 <code>NSBlock</code> 来做同步线程：</p>
<h4 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h4><p>首先来看下 <code>NSLock</code> 的表达式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NSLock</span> : <span class="title">NSObject</span>, <span class="title">NSLocking</span> </span>&#123;</div><div class="line"></div><div class="line">   	<span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">tryLock</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></div><div class="line">   	<span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">lockBeforeDate</span><span class="params">(limit: NSDate)</span></span> -&gt; <span class="type">Bool</span></div><div class="line"></div><div class="line">   	<span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</div><div class="line">   	<span class="keyword">public</span> <span class="keyword">var</span> name: <span class="type">String</span>?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，<code>NSLock</code> 是一个类，包含两个实例方法 <code>tryLock</code> 和 <code>lockBeforeDate</code> 以及一个存储属性 <code>name</code>，并且继承了 <code>NSLocking</code> ，我们再来看下 <code>NSLocking</code> 这个父类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">NSLocking</span> </span>&#123;</div><div class="line"></div><div class="line">   	<span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">lock</span><span class="params">()</span></span></div><div class="line">   	<span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">unlock</span><span class="params">()</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>NSLocking</code> 中有两个实例方法，分别是加锁和解锁，关于 <code>NSLock</code> 还有一些其他的属性和方法，大家可以在帮助文档中找到，在此就不一一介绍了。</p>
<p>下面我们使用 <code>NSThread</code> 和 <code>NSBlock</code> 来实现和上面同样的功能，首先创建两个成员属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> iTicketCount: <span class="type">Int</span> = <span class="number">10</span>  <span class="comment">//表示当前剩余的票数</span></div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myLock: <span class="type">NSLock</span>!         <span class="comment">//表示一个锁</span></div></pre></td></tr></table></figure>
<p>下面我们将 <code>myLock</code> 进行实例化，创建两个线程并添加任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">self.myLock = NSLock()</div><div class="line">let threadOne = NSThread(target: self, selector: #selector(ViewController.saleTicket), object: nil)</div><div class="line">let threadTwo = NSThread(target: self, selector: #selector(ViewController.saleTicket), object: nil)</div><div class="line">threadOne.start()</div><div class="line">threadTwo.start()</div></pre></td></tr></table></figure>
<p>我们要执行的任务是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func saleTicket() &#123;</div><div class="line"></div><div class="line">    while self.iTicketCount &gt; 0 &#123;</div><div class="line"></div><div class="line">        self.myLock.lock()</div><div class="line"></div><div class="line">        if self.iTicketCount &gt; 0 &#123;</div><div class="line">            self.iTicketCount -= 1</div><div class="line">            print(&quot;当前线程是 \(NSThread.currentThread()) 剩余票数\(self.iTicketCount)&quot; )</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        self.myLock.unlock()</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>做好条件控制，在需要同步线程的代码上下分别启用 <code>myLock.lock()</code> 和 <code>myLock.unlock()</code> 就可以了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;比如你去银行存10K，在用ATM存的同时，又使用网银取了10K，如果线程同步做的不好的话， 虽然取10K元的操作会有记录，但是可能不会反映在余额上。如果要解决这样的问题，就需要用到线程同步，线程同步在开发过程中是非常常见的。下面我们以12306为例，尝试解决如何保证一张票不会被不同窗口，不同客户端重复购买。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先我们来认识一下互斥锁的概念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;互斥锁&lt;/strong&gt;（英语：Mutual exclusion，缩写 Mutex）是一种用于&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%BA%BF%E7%A8%8B&quot;&gt;多线程&lt;/a&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B&quot;&gt;编程&lt;/a&gt;中，防止两条&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B&quot;&gt;线程&lt;/a&gt;同时对同一公共资源（比如&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F&quot;&gt;全局变量&lt;/a&gt;）进行读写的机制。该目的通过将代码切片成一个一个的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%B8%B4%E7%95%8C%E5%8C%BA%E5%9F%9F&quot;&gt;临界区域&lt;/a&gt;（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上是维基百科给出的解释，如需了解更多请 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BA%92%E6%96%A5%E9%94%81&quot;&gt;点击这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;简单来讲，互斥锁是为了防止多个线程访问同一个对象、方法、变量、文件等引起的数据错误。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="互斥锁" scheme="http://yoursite.com/tags/%E4%BA%92%E6%96%A5%E9%94%81/"/>
    
      <category term="异步线程" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程锁" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E9%94%81/"/>
    
      <category term="同步线程" scheme="http://yoursite.com/tags/%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Xcode错误 - Failed to import &amp;&amp; .h file not found</title>
    <link href="http://yoursite.com/2016/08/05/Xcode%E9%94%99%E8%AF%AF%20-%20Failed%20to%20import%20&amp;&amp;%20.h%20file%20not%20found/"/>
    <id>http://yoursite.com/2016/08/05/Xcode错误 - Failed to import &amp;&amp; .h file not found/</id>
    <published>2016-08-04T21:46:00.000Z</published>
    <updated>2016-09-26T10:32:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>出现这两个问题时，首先要确保相关的库和依赖已经导入到工程，如果还是有提示，这说明出错的文件 Xcode 无法获取到。</p>
<p>首先进入工程的 Build Phases ，找到 Link Binary With Libraries ，点击 + 号将提示缺失的文件导入。</p>
<p><img src="http://ob2q6r0fn.bkt.clouddn.com/buildphases.png" alt=""></p>
<p>如果文件已经存在的话，进入工程的 Build Settings ，在 TARGETS 而不是 PROJECT 下，搜索 Search Paths，确保 Frameworks Search Paths 和 Header Search Paths 指向正确的文件路径。</p>
<a id="more"></a>
<p><img src="http://ob2q6r0fn.bkt.clouddn.com/buildsettings.png" alt=""></p>
<p>如果此时还提示 Failed to import 的话，尝试将 <code>#import &quot;xxx.h&quot;</code> 修改为 <code>#import &lt;xxx/xxx.h&gt;</code>。</p>
<p>如果此时还提示 file not found 的话，尝试 <code>⌘ + alt + ⇧ + k</code> 清理目录。</p>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="http://stackoverflow.com/questions/19447860/xcode-file-not-found" target="_blank" rel="external">http://stackoverflow.com/questions/19447860/xcode-file-not-found</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;出现这两个问题时，首先要确保相关的库和依赖已经导入到工程，如果还是有提示，这说明出错的文件 Xcode 无法获取到。&lt;/p&gt;
&lt;p&gt;首先进入工程的 Build Phases ，找到 Link Binary With Libraries ，点击 + 号将提示缺失的文件导入。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ob2q6r0fn.bkt.clouddn.com/buildphases.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果文件已经存在的话，进入工程的 Build Settings ，在 TARGETS 而不是 PROJECT 下，搜索 Search Paths，确保 Frameworks Search Paths 和 Header Search Paths 指向正确的文件路径。&lt;/p&gt;
    
    </summary>
    
      <category term="Xcode错误" scheme="http://yoursite.com/categories/Xcode%E9%94%99%E8%AF%AF/"/>
    
    
      <category term="Xcode错误" scheme="http://yoursite.com/tags/Xcode%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>iOS数据处理 - 转载·字符串MD5加密</title>
    <link href="http://yoursite.com/2016/08/03/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Swift%20-%20%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84MD5%E5%80%BC/"/>
    <id>http://yoursite.com/2016/08/03/【转载】Swift - 获取字符串的MD5值/</id>
    <published>2016-08-02T18:46:00.000Z</published>
    <updated>2016-08-24T04:46:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>MD5 即 Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。 其作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串）。</p>
</blockquote>
<p>首先，创建桥接头文件 <code>bridge.h</code> 来包含需要引用的 <code>Objective-C</code> 头文件，并在项目中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &lt;CommonCrypto/CommonDigest.h&gt;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>其次，对 <code>String</code> 增加 <code>MD5</code> 扩展：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Foundation</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</div><div class="line">   <span class="keyword">var</span> md5 : <span class="type">String</span>&#123;</div><div class="line">       <span class="keyword">let</span> str = <span class="keyword">self</span>.cStringUsingEncoding(<span class="type">NSUTF8StringEncoding</span>)</div><div class="line">       <span class="keyword">let</span> strLen = <span class="type">CC_LONG</span>(<span class="keyword">self</span>.lengthOfBytesUsingEncoding(<span class="type">NSUTF8StringEncoding</span>))</div><div class="line">       <span class="keyword">let</span> digestLen = <span class="type">Int</span>(<span class="type">CC_MD5_DIGEST_LENGTH</span>)</div><div class="line">       <span class="keyword">let</span> result = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">CUnsignedChar</span>&gt;.alloc(digestLen);</div><div class="line"></div><div class="line">       <span class="type">CC_MD5</span>(str!, strLen, result);</div><div class="line"></div><div class="line">       <span class="keyword">let</span> hash = <span class="type">NSMutableString</span>();</div><div class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; digestLen &#123;</div><div class="line">           hash.appendFormat(<span class="string">"%02x"</span>, result[i]);</div><div class="line">       &#125;</div><div class="line">       result.destroy();</div><div class="line"></div><div class="line">       <span class="keyword">return</span> <span class="type">String</span>(format: hash <span class="keyword">as</span> <span class="type">String</span>)</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用样例："><a href="#使用样例：" class="headerlink" title="使用样例："></a>使用样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(&quot;welcome to hangge.com&quot;.md5)		//输出：6ad70eb3a4a50011af9c62cc0674803a</div></pre></td></tr></table></figure>
<p>转载自：<a href="http://www.hangge.com/blog/cache/detail_650.html" target="_blank" rel="external">http://www.hangge.com/blog/cache/detail_650.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;MD5 即 Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。 其作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，创建桥接头文件 &lt;code&gt;bridge.h&lt;/code&gt; 来包含需要引用的 &lt;code&gt;Objective-C&lt;/code&gt; 头文件，并在项目中配置：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;#import &amp;lt;CommonCrypto/CommonDigest.h&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="MD5" scheme="http://yoursite.com/tags/MD5/"/>
    
  </entry>
  
  <entry>
    <title>iOS自定义控件 - 时间轴</title>
    <link href="http://yoursite.com/2016/07/22/%E5%AE%9E%E7%8E%B0%E6%97%B6%E9%97%B4%E8%BD%B4%E6%95%88%E6%9E%9C/"/>
    <id>http://yoursite.com/2016/07/22/实现时间轴效果/</id>
    <published>2016-07-21T17:21:00.000Z</published>
    <updated>2016-08-21T18:14:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>时间轴是大家都很熟悉的特效，在网络上也有很多现成的资源，虽然轮子已经有很多，但是我们自己尝试来做一个也不失为是一种乐趣，下面我们通过 StoryBoard 和代码来完成一个时间轴的界面。</p>
</blockquote>
<h4 id="配置-StoryBoard："><a href="#配置-StoryBoard：" class="headerlink" title="配置 StoryBoard："></a>配置 StoryBoard：</h4><p>首先我们创建新的 <code>Project</code> ，删掉默认的 <code>ViewController.swift</code>，和 <code>MainStoryBoard</code> 中的 <code>ViewControlle r Scene</code> ，现在我们就有了一个空的项目。</p>
<p>下面我们在 <code>Main.StoryBoard</code> 中拖进来一个 <code>TableViewController</code> 给它命名为 <code>NoteTableViewController</code> ，然后创建 <code>New File - File</code> ，选择 <code>Cocoa Touch Class</code> ，继承自 <code>UITableViewController</code> ，命名为 <code>NoteTableViewController</code> 。</p>
<p>然后将 <code>NoteTableViewController</code> 和 <code>NoteTableViewController.Class</code> 进行绑定，并给<code>Main.StoryBoard</code> 设置一个 <code>Identity</code> ，并勾选 <code>Is Initial View Controller</code> 。</p>
<p>下一步，选中 <code>NoteTableViewController</code> 下的 <code>TableView</code> ，将它的 <code>Row Height</code> 设置为60，<code>Prototype Cells</code> 设置为2。</p>
<p>下面，设置两个 <code>Cell</code> ，分别命名为 <code>RightCell 和 LeftCell</code> ，给每个 <code>Cell</code> 添加 <code>3个Buttonh 和 1个UIView</code>。3个按钮命名依次为：<code>middle delete edit</code> ，宽度30，高度30，并给按钮设置对应的背景图片，并让3个按钮对齐，<code>UIView</code> 的宽度是2，高度30，背景颜色为黑色。</p>
<p>给 <code>LeftCell</code> 添加一个<code>Label</code>，文本设置为右对齐，给 <code>RightCell</code> 添加一个 <code>Label</code>，文本设置为左对齐。</p>
<p>最后，勾选 <code>delete edit</code> 两个按钮的 <code>Hidden</code> 选项，然后创建 <code>New File - File</code> ，选择 <code>Cocoa Touch Class</code> ，继承自 <code>UITableViewCell</code> ，命名为 <code>NoteTableViewCell</code> 。</p>
<a id="more"></a>
<h4 id="自定义-TableViewCell"><a href="#自定义-TableViewCell" class="headerlink" title="自定义 TableViewCell"></a>自定义 TableViewCell</h4><p>在 <code>NoteTableViewCell</code> 中创建两个子类，继承自  <code>NoteTableViewCell</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class LeftNoteTableViewCell: NoteTableViewCell &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class RightNoteTableViewCell: NoteTableViewCell &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将 <code>RightCell 和 LeftCell</code> 和这两个子类绑定，并给这两个子类拖进来两个控件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class LeftNoteTableViewCell: NoteTableViewCell &#123;</div><div class="line">    @IBOutlet weak var descriptionLabel: UILabel!</div><div class="line">&#125;</div><div class="line"></div><div class="line">class RightNoteTableViewCell: NoteTableViewCell &#123;</div><div class="line">    @IBOutlet weak var descriptionLabel: UILabel!</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将三个通用的控件拖进 <code>NoteTableViewCell</code> 这个基类中，并设置一个 <code>Bool</code> 值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class NoteTableViewCell: UITableViewCell &#123;</div><div class="line"></div><div class="line">    @IBOutlet weak var deleteButton: UIButton!</div><div class="line">    @IBOutlet weak var editButton: UIButton!</div><div class="line">    @IBOutlet weak var middleButton: UIButton!</div><div class="line">    var isExpand = false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h4><p>新建一个文件命名为 <code>NoteItem</code> ，创建结构体并嵌入枚举：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct NoteItem &#123;</div><div class="line">    var cost: Float         </div><div class="line">    var content: String     </div><div class="line">    var type: NoteItemType  </div><div class="line">&#125;</div><div class="line"></div><div class="line">enum NoteItemType: Int &#123;</div><div class="line">    case income</div><div class="line">    case outcome</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用模型："><a href="#使用模型：" class="headerlink" title="使用模型："></a>使用模型：</h4><p>回到 <code>NoteTableViewCell</code> 中，创建配置方法 <code>configureCell</code> 将模型中的数据传给 <code>Cell</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">func configureCell(withItem item: NoteItem) &#123;</div><div class="line"></div><div class="line">        switch item.content &#123;</div><div class="line">        case &quot;购物&quot;:</div><div class="line">            middleButton.setImage(UIImage(named: &quot;shopping.png&quot;), forState: .Normal)</div><div class="line">        case &quot;服装&quot;:</div><div class="line">            middleButton.setImage(UIImage(named: &quot;clothes.png&quot;), forState: .Normal)</div><div class="line">        case &quot;食品&quot;:</div><div class="line">            middleButton.setImage(UIImage(named: &quot;restaurant.png&quot;), forState: .Normal)</div><div class="line">        case &quot;工资&quot;,&quot;奖金&quot;:</div><div class="line">            middleButton.setImage(UIImage(named: &quot;income.png&quot;), forState: .Normal)</div><div class="line"></div><div class="line">        default:</div><div class="line">            middleButton.setImage(UIImage(named: &quot;middle_button.png&quot;), forState: .Normal)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        let lableConeten = &quot;\(item.content) \(item.cost)&quot;</div><div class="line"></div><div class="line">        setValue(lableConeten, forKeyPath: &quot;descriptionLabel.text&quot;)</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>回到 <code>NoteTableViewController</code> 中，完善模型的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var datas: [NoteItem] = [NoteItem(cost: 1000, content: &quot;购物&quot;, type: .outcome),</div><div class="line">                         NoteItem(cost: 3000, content: &quot;宠物&quot;, type: .outcome),</div><div class="line">                         NoteItem(cost: 5000, content: &quot;工资&quot;, type: .income),</div><div class="line">                         NoteItem(cost: 2000, content: &quot;购物&quot;, type: .outcome),</div><div class="line">                         NoteItem(cost: 10000, content: &quot;奖金&quot;, type: .income),</div><div class="line">                         NoteItem(cost: 4000, content: &quot;服装&quot;, type: .outcome),</div><div class="line">                         NoteItem(cost: 8000, content: &quot;食品&quot;, type: .outcome),</div><div class="line">                         NoteItem(cost: 6000, content: &quot;购物&quot;, type: .outcome),]</div></pre></td></tr></table></figure>
<p>配置 <code>tableView</code> 的行数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> datas.<span class="built_in">count</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义 <code>Cell</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123;</div><div class="line"></div><div class="line">    let item = datas[indexPath.row]</div><div class="line">    var identifier = &quot;&quot;</div><div class="line"></div><div class="line">    switch item.type &#123;              </div><div class="line">    case .income:</div><div class="line">        identifier = &quot;LeftCell&quot;</div><div class="line">    case .outcome:</div><div class="line">        identifier = &quot;RightCell&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    let cell = tableView.dequeueReusableCellWithIdentifier(identifier) as? NoteTableViewCell</div><div class="line"></div><div class="line">    return cell!</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回到 <code>NoteTableViewCell</code> 中创建点击事件，让 <code>middleButton</code> 在点击时弹出隐藏的 <code>delete</code> 和 <code>edit</code> ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">middieButtonClicked</span><span class="params">(sender: AnyObject)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> !isExpand &#123;</div><div class="line">        expand()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        close()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现 <code>expand()</code> 和 <code>close()</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">func expand() &#123;</div><div class="line"></div><div class="line">        editButton.hidden = false</div><div class="line">        deleteButton.hidden = false</div><div class="line"></div><div class="line">        UIView.animateWithDuration(0.5, animations: &#123;</div><div class="line"></div><div class="line">            self.deleteButton.center.x = 30</div><div class="line">            self.editButton.center.x = self.frame.size.width - 30</div><div class="line"></div><div class="line">            &#125;) &#123; (done) in</div><div class="line">                self.isExpand = true</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">func close() &#123;</div><div class="line"></div><div class="line">        UIView.animateWithDuration(0.5, animations: &#123;</div><div class="line"></div><div class="line">            self.deleteButton.center = self.middleButton.center</div><div class="line">            self.editButton.center = self.middleButton.center</div><div class="line"></div><div class="line">            &#125;) &#123; (done) in</div><div class="line">                self.deleteButton.hidden = true</div><div class="line">                self.editButton.hidden = true</div><div class="line">                self.isExpand = false</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h4><p>将 <code>delete</code> 和 <code>edit</code> 的点击事件传递到 <code>TableViewController</code> ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NoteCellDelegate</span>: <span class="title">class</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">noteCellClickMiddleButtom</span><span class="params">(sender: NoteTableViewCell)</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>设置代理对象：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">NoteCellDelegate</span>?</div></pre></td></tr></table></figure>
<p>新建一个文件，命名为 <code>NoteTableViewContorller+NoteCellDelegate</code> ，将代理方法添加为扩展方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NoteTableViewController</span>: <span class="title">NoteCellDelegate</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">noteCellClickMiddleButtom</span><span class="params">(sender: NoteTableViewCell)</span></span>&#123;</div><div class="line">    <span class="keyword">let</span> indexPath = tableView.indexPathForCell(sender)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"cell <span class="subst">\(indexPath?.row)</span> clicked"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回到 <code>NoteTableViewCell</code> 中，完善 <code>middieButtonClicked</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">middieButtonClicked</span><span class="params">(sender: AnyObject)</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> !isExpand &#123;</div><div class="line">        expand()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        close()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.delegate?.noteCellClickMiddleButtom(<span class="keyword">self</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回到 <code>NoteTableViewController</code> 中，完善自定义 Cell 的方法，使用代理调用 <code>configureCell</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> item = datas[indexPath.row]     </div><div class="line">    <span class="keyword">var</span> identifier = <span class="string">""</span></div><div class="line"></div><div class="line">    <span class="keyword">switch</span> item.type &#123;                  </div><div class="line">    <span class="keyword">case</span> .income:</div><div class="line">        identifier = <span class="string">"LeftCell"</span></div><div class="line">    <span class="keyword">case</span> .outcome:</div><div class="line">        identifier = <span class="string">"RightCell"</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(identifier) <span class="keyword">as</span>? <span class="type">NoteTableViewCell</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> cell?.delegate == <span class="literal">nil</span> &#123;</div><div class="line"></div><div class="line">        cell?.delegate = <span class="keyword">self</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    cell?.configureCell(withItem: item)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> cell!</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，添加 <code>tableView</code> 的 <code>tableHeaderView</code> ，原型基本上就完成了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> frame = <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">70</span>)</div><div class="line"><span class="keyword">let</span> headerView = <span class="type">UIView</span>(frame: frame)</div><div class="line">headerView.backgroundColor = <span class="type">UIColor</span>.redColor()</div><div class="line">tableView.tableHeaderView = headerView</div></pre></td></tr></table></figure>
<p>下面将完整代码贴出来方便大家参考。</p>
<h4 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h4><p><code>NoteTableViewController</code> 文件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoteTableViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> datas: [<span class="type">NoteItem</span>] = [<span class="type">NoteItem</span>(cost: <span class="number">1000</span>, content: <span class="string">"购物"</span>, type: .outcome),</div><div class="line">                             <span class="type">NoteItem</span>(cost: <span class="number">3000</span>, content: <span class="string">"宠物"</span>, type: .outcome),</div><div class="line">                             <span class="type">NoteItem</span>(cost: <span class="number">5000</span>, content: <span class="string">"工资"</span>, type: .income),</div><div class="line">                             <span class="type">NoteItem</span>(cost: <span class="number">2000</span>, content: <span class="string">"购物"</span>, type: .outcome),</div><div class="line">                             <span class="type">NoteItem</span>(cost: <span class="number">10000</span>, content: <span class="string">"奖金"</span>, type: .income),</div><div class="line">                             <span class="type">NoteItem</span>(cost: <span class="number">4000</span>, content: <span class="string">"服装"</span>, type: .outcome),</div><div class="line">                             <span class="type">NoteItem</span>(cost: <span class="number">8000</span>, content: <span class="string">"食品"</span>, type: .outcome),</div><div class="line">                             <span class="type">NoteItem</span>(cost: <span class="number">6000</span>, content: <span class="string">"购物"</span>, type: .outcome),]      </div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">        <span class="keyword">let</span> frame = <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">70</span>)</div><div class="line">        <span class="keyword">let</span> headerView = <span class="type">UIView</span>(frame: frame)</div><div class="line">        headerView.backgroundColor = <span class="type">UIColor</span>.redColor()</div><div class="line">        tableView.tableHeaderView = headerView</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> datas.<span class="built_in">count</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> item = datas[indexPath.row]     </div><div class="line">        <span class="keyword">var</span> identifier = <span class="string">""</span></div><div class="line"></div><div class="line">        <span class="keyword">switch</span> item.type &#123;                  </div><div class="line">        <span class="keyword">case</span> .income:</div><div class="line">            identifier = <span class="string">"LeftCell"</span></div><div class="line">        <span class="keyword">case</span> .outcome:</div><div class="line">            identifier = <span class="string">"RightCell"</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(identifier) <span class="keyword">as</span>? <span class="type">NoteTableViewCell</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> cell?.delegate == <span class="literal">nil</span> &#123;</div><div class="line"></div><div class="line">            cell?.delegate = <span class="keyword">self</span></div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        cell?.configureCell(withItem: item)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> cell!</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>NoteTableViewContorller+NoteCellDelegate</code> 文件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NoteTableViewController</span>: <span class="title">NoteCellDelegate</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">noteCellClickMiddleButtom</span><span class="params">(sender: NoteTableViewCell)</span></span>&#123;</div><div class="line">    <span class="keyword">let</span> indexPath = tableView.indexPathForCell(sender)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"cell <span class="subst">\(indexPath?.row)</span> clicked"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>NoteTableViewCell</code> 文件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoteTableViewCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> deleteButton: <span class="type">UIButton</span>!</div><div class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> editButton: <span class="type">UIButton</span>!</div><div class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> middleButton: <span class="type">UIButton</span>!</div><div class="line"></div><div class="line">    <span class="keyword">var</span> isExpand = <span class="literal">false</span>    </div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">NoteCellDelegate</span>?</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">configureCell</span><span class="params">(withItem item: NoteItem)</span></span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> item.content &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"购物"</span>:</div><div class="line">            middleButton.setImage(<span class="type">UIImage</span>(named: <span class="string">"shopping.png"</span>), forState: .<span class="type">Normal</span>)</div><div class="line">        <span class="keyword">case</span> <span class="string">"服装"</span>:</div><div class="line">            middleButton.setImage(<span class="type">UIImage</span>(named: <span class="string">"clothes.png"</span>), forState: .<span class="type">Normal</span>)</div><div class="line">        <span class="keyword">case</span> <span class="string">"食品"</span>:</div><div class="line">            middleButton.setImage(<span class="type">UIImage</span>(named: <span class="string">"restaurant.png"</span>), forState: .<span class="type">Normal</span>)</div><div class="line">        <span class="keyword">case</span> <span class="string">"工资"</span>,<span class="string">"奖金"</span>:</div><div class="line">            middleButton.setImage(<span class="type">UIImage</span>(named: <span class="string">"income.png"</span>), forState: .<span class="type">Normal</span>)</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            middleButton.setImage(<span class="type">UIImage</span>(named: <span class="string">"middle_button.png"</span>), forState: .<span class="type">Normal</span>)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> lableConeten = <span class="string">"<span class="subst">\(item.content)</span> <span class="subst">\(item.cost)</span>"</span></div><div class="line"></div><div class="line">        setValue(lableConeten, forKeyPath: <span class="string">"descriptionLabel.text"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setNilValueForKey</span><span class="params">(key: String)</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.setNilValueForKey(key)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"KVC 的传值目标<span class="subst">\(key)</span> 没有找到"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">middieButtonClicked</span><span class="params">(sender: AnyObject)</span></span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> !isExpand &#123;</div><div class="line">            expand()</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            close()</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">self</span>.delegate?.noteCellClickMiddleButtom(<span class="keyword">self</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">expand</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">        editButton.hidden = <span class="literal">false</span></div><div class="line">        deleteButton.hidden = <span class="literal">false</span></div><div class="line"></div><div class="line">        <span class="type">UIView</span>.animateWithDuration(<span class="number">0.5</span>, animations: &#123;</div><div class="line"></div><div class="line">            <span class="keyword">self</span>.deleteButton.center.x = <span class="number">30</span></div><div class="line">            <span class="keyword">self</span>.editButton.center.x = <span class="keyword">self</span>.frame.size.width - <span class="number">30</span></div><div class="line"></div><div class="line">            &#125;) &#123; (done) <span class="keyword">in</span></div><div class="line"></div><div class="line">                <span class="keyword">self</span>.isExpand = <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">close</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">        <span class="type">UIView</span>.animateWithDuration(<span class="number">0.5</span>, animations: &#123;</div><div class="line"></div><div class="line">            <span class="keyword">self</span>.deleteButton.center = <span class="keyword">self</span>.middleButton.center</div><div class="line">            <span class="keyword">self</span>.editButton.center = <span class="keyword">self</span>.middleButton.center</div><div class="line"></div><div class="line">            &#125;) &#123; (done) <span class="keyword">in</span></div><div class="line">                <span class="keyword">self</span>.deleteButton.hidden = <span class="literal">true</span></div><div class="line">                <span class="keyword">self</span>.editButton.hidden = <span class="literal">true</span></div><div class="line">                <span class="keyword">self</span>.isExpand = <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NoteCellDelegate</span>: <span class="title">class</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">noteCellClickMiddleButtom</span><span class="params">(sender: NoteTableViewCell)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeftNoteTableViewCell</span>: <span class="title">NoteTableViewCell</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> descriptionLabel: <span class="type">UILabel</span>!</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RightNoteTableViewCell</span>: <span class="title">NoteTableViewCell</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> descriptionLabel: <span class="type">UILabel</span>!</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>NoteItem</code> 文件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoteItem</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> cost: <span class="type">Float</span>         </div><div class="line">    <span class="keyword">var</span> content: <span class="type">String</span>     </div><div class="line">    <span class="keyword">var</span> type: <span class="type">NoteItemType</span>  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">NoteItemType</span>: <span class="title">Int</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> income</div><div class="line">    <span class="keyword">case</span> outcome</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;时间轴是大家都很熟悉的特效，在网络上也有很多现成的资源，虽然轮子已经有很多，但是我们自己尝试来做一个也不失为是一种乐趣，下面我们通过 StoryBoard 和代码来完成一个时间轴的界面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;配置-StoryBoard：&quot;&gt;&lt;a href=&quot;#配置-StoryBoard：&quot; class=&quot;headerlink&quot; title=&quot;配置 StoryBoard：&quot;&gt;&lt;/a&gt;配置 StoryBoard：&lt;/h4&gt;&lt;p&gt;首先我们创建新的 &lt;code&gt;Project&lt;/code&gt; ，删掉默认的 &lt;code&gt;ViewController.swift&lt;/code&gt;，和 &lt;code&gt;MainStoryBoard&lt;/code&gt; 中的 &lt;code&gt;ViewControlle r Scene&lt;/code&gt; ，现在我们就有了一个空的项目。&lt;/p&gt;
&lt;p&gt;下面我们在 &lt;code&gt;Main.StoryBoard&lt;/code&gt; 中拖进来一个 &lt;code&gt;TableViewController&lt;/code&gt; 给它命名为 &lt;code&gt;NoteTableViewController&lt;/code&gt; ，然后创建 &lt;code&gt;New File - File&lt;/code&gt; ，选择 &lt;code&gt;Cocoa Touch Class&lt;/code&gt; ，继承自 &lt;code&gt;UITableViewController&lt;/code&gt; ，命名为 &lt;code&gt;NoteTableViewController&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;然后将 &lt;code&gt;NoteTableViewController&lt;/code&gt; 和 &lt;code&gt;NoteTableViewController.Class&lt;/code&gt; 进行绑定，并给&lt;code&gt;Main.StoryBoard&lt;/code&gt; 设置一个 &lt;code&gt;Identity&lt;/code&gt; ，并勾选 &lt;code&gt;Is Initial View Controller&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;下一步，选中 &lt;code&gt;NoteTableViewController&lt;/code&gt; 下的 &lt;code&gt;TableView&lt;/code&gt; ，将它的 &lt;code&gt;Row Height&lt;/code&gt; 设置为60，&lt;code&gt;Prototype Cells&lt;/code&gt; 设置为2。&lt;/p&gt;
&lt;p&gt;下面，设置两个 &lt;code&gt;Cell&lt;/code&gt; ，分别命名为 &lt;code&gt;RightCell 和 LeftCell&lt;/code&gt; ，给每个 &lt;code&gt;Cell&lt;/code&gt; 添加 &lt;code&gt;3个Buttonh 和 1个UIView&lt;/code&gt;。3个按钮命名依次为：&lt;code&gt;middle delete edit&lt;/code&gt; ，宽度30，高度30，并给按钮设置对应的背景图片，并让3个按钮对齐，&lt;code&gt;UIView&lt;/code&gt; 的宽度是2，高度30，背景颜色为黑色。&lt;/p&gt;
&lt;p&gt;给 &lt;code&gt;LeftCell&lt;/code&gt; 添加一个&lt;code&gt;Label&lt;/code&gt;，文本设置为右对齐，给 &lt;code&gt;RightCell&lt;/code&gt; 添加一个 &lt;code&gt;Label&lt;/code&gt;，文本设置为左对齐。&lt;/p&gt;
&lt;p&gt;最后，勾选 &lt;code&gt;delete edit&lt;/code&gt; 两个按钮的 &lt;code&gt;Hidden&lt;/code&gt; 选项，然后创建 &lt;code&gt;New File - File&lt;/code&gt; ，选择 &lt;code&gt;Cocoa Touch Class&lt;/code&gt; ，继承自 &lt;code&gt;UITableViewCell&lt;/code&gt; ，命名为 &lt;code&gt;NoteTableViewCell&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="代理模式" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="自定义控件" scheme="http://yoursite.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    
      <category term="MVC设计模式" scheme="http://yoursite.com/tags/MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程 - 线程间的通信</title>
    <link href="http://yoursite.com/2016/07/21/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%20%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2016/07/21/iOS多线程之 线程间的通信/</id>
    <published>2016-07-21T07:54:00.000Z</published>
    <updated>2016-08-21T18:12:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>因为线程是串行的，这意味着如果我们要下载一个图片，使它呈现在一个<code>UIImageView</code> 里，那么这个线程必须要等待图片下载完成后，才能显示出来。为了解决这样的问题，我们需要用到多线程的技术，将下载图片交给子线程完成，将加载图片到 <code>UIImageView</code> 交给主线程，这就涉及到一个问题，就是线程之间的通信。</p>
</blockquote>
<h4 id="线程通讯的两种方式"><a href="#线程通讯的两种方式" class="headerlink" title="线程通讯的两种方式"></a>线程通讯的两种方式</h4><ol>
<li>从一个线程给另一个线程传递数据。</li>
<li>在一个线程中执行完特定任务后，转到另一个线程继续执行。</li>
</ol>
<p>以上面的问题举例，我们要在一个线程中下载图片，然后要另一个线程展示图片，<strong>苹果官方推荐，刷新界面的操作最好在主线程中完成</strong>，那么我们来实验一下，如果将展示图片的操作交给子线程，会发生什么。<strong>首先我们创建一个 <code>UIImageView</code> 并将它添加到 <code>UIViewController</code></strong>，然后我们创建一个子线程：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> subThread = <span class="type">NSThread</span>(target: <span class="keyword">self</span>, selector: #selector(<span class="type">ViewController</span>.run(<span class="number">_</span>:)), object: <span class="string">"我是传入参数"</span>)</div><div class="line">    subThread.start()</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>下面我们创建 <code>run</code> 这个线程执行方法，写入以下代码下载图片：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> url: <span class="type">NSURL</span> = <span class="type">NSURL</span>(string: <span class="string">"http://pic.qiantucdn.com/58pic/19/40/65/17m58PICgSH_1024.jpg"</span>)!	<span class="comment">//使用 NSURL 创建下载链接</span></div><div class="line">    <span class="keyword">let</span> data: <span class="type">NSData</span> = <span class="type">NSData</span>(contentsOfURL: url)!	<span class="comment">//使用 NSData 获得文件</span></div><div class="line">    <span class="keyword">let</span> img: <span class="type">UIImage</span> = <span class="type">UIImage</span>(data: data)!	<span class="comment">//使用 init?(data: NSData) 实例化图片</span></div></pre></td></tr></table></figure>
<p>最后将图片加载到 <code>UIImageView</code> 里：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.myImg.image = img</div></pre></td></tr></table></figure>
<p>现在我们运行这个程序，如果你的 XCode 版本是新的话，那么可能会收到一条报错：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">App</span> <span class="type">Transport</span> <span class="type">Security</span> has blocked a cleartext <span class="type">HTTP</span> (http:<span class="comment">//) resource load since it is insecure. Temporary exceptions can be configured via your app's Info.plist file.</span></div></pre></td></tr></table></figure>
<p>这个原因是 iOS9 中新增了 <code>App Transport Security</code>（简称ATS）特性，在 iOS9 以前请求网络的时候都用到的<code>HTTP</code>，现在转向TLS1.2协议进行传输。这也意味着所有的 <code>HTTP</code> 协议都强制使用了 <code>HTTPS</code> 协议进行传输，所以系统会告诉我们不能直接使用HTTP进行请求，这需要在 <code>Info.plist</code> 新增一段用于控制ATS的配置：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;key&gt;<span class="type">NSAppTransportSecurity</span>&lt;/key&gt;</div><div class="line">&lt;dict&gt;</div><div class="line">   &lt;key&gt;<span class="type">NSAllowsArbitraryLoads</span>&lt;/key&gt;</div><div class="line">   &lt;<span class="literal">true</span>/&gt;</div><div class="line">&lt;/dict&gt;</div></pre></td></tr></table></figure>
<p>我们重新运行这个程序，相信这时图片已经成功加载出来了，但是控制台会收到这样一句提示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">This</span> application <span class="keyword">is</span> modifying the autolayout engine from a background thread, which can lead to engine corruption and weird crashes.  <span class="type">This</span> will cause an exception <span class="keyword">in</span> a future release.</div></pre></td></tr></table></figure>
<p>这是说，我们使用了 <code>background thread</code> 后台进程更改了布局，这可能会导致崩溃和其他问题，这也符合苹果官方所推荐的：<strong>刷新界面的操作最好在主线程中完成</strong>。</p>
<p>那么现在我们尝试解决这个问题，将刷新界面的操作交给主线程操作，相信大家已经意识到问题的核心，<strong>如何通知主线程刷新界面</strong> ？我们来调用这个方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">performSelectorOnMainThread(#selector(<span class="type">ViewController</span>.showImage(<span class="number">_</span>:)), withObject: img, waitUntilDone: <span class="literal">true</span>)</div></pre></td></tr></table></figure>
<p>下面我们先看一下这个方法的参数：</p>
<table>
<thead>
<tr>
<th>形参</th>
<th>作用</th>
<th>填写</th>
</tr>
</thead>
<tbody>
<tr>
<td>aSelector: Selector</td>
<td>这是一个选择器，代表要执行的方法。</td>
<td>自己写的方法</td>
</tr>
<tr>
<td>withObject arg: AnyObject?</td>
<td>这是执行方法的传入参数。</td>
<td>可以是nil</td>
</tr>
<tr>
<td>waitUntilDone wait: Bool</td>
<td>是否要等待执行方法的完成。</td>
<td>可以是false</td>
</tr>
</tbody>
</table>
<p>前两个参数比较好理解，因为执行方法也是需要时间的，第三个参数 <code>true</code> 和<code>false</code> 的区别是：如果是 <code>true</code> 的话，主线程会等待执行方法完成，主线程才会继续其他的操作；如是是 <code>false</code> 的话，主线程马上就会结束，并不关心执行方法是否完成。</p>
<p><strong>如果你有一些限制，比如要等执行方法完成之后，在执行一些其他的工作，这是就输入 <code>true</code>，如果你不关心执行的结果，就输入 <code>false</code>。</strong></p>
<p>下面我们实现让主线程操作 <code>UIImageView</code> 显示图片的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">showImage</span><span class="params">(img: UIImage)</span></span> &#123;</div><div class="line">    <span class="keyword">self</span>.myImg.image = img</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次运行，风险提示没有了，这说明我们实现了，从子线程中下载图片，并调用主线程，在主线程中刷新界面这样一个功能。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;因为线程是串行的，这意味着如果我们要下载一个图片，使它呈现在一个&lt;code&gt;UIImageView&lt;/code&gt; 里，那么这个线程必须要等待图片下载完成后，才能显示出来。为了解决这样的问题，我们需要用到多线程的技术，将下载图片交给子线程完成，将加载图片到 &lt;code&gt;UIImageView&lt;/code&gt; 交给主线程，这就涉及到一个问题，就是线程之间的通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;线程通讯的两种方式&quot;&gt;&lt;a href=&quot;#线程通讯的两种方式&quot; class=&quot;headerlink&quot; title=&quot;线程通讯的两种方式&quot;&gt;&lt;/a&gt;线程通讯的两种方式&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;从一个线程给另一个线程传递数据。&lt;/li&gt;
&lt;li&gt;在一个线程中执行完特定任务后，转到另一个线程继续执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上面的问题举例，我们要在一个线程中下载图片，然后要另一个线程展示图片，&lt;strong&gt;苹果官方推荐，刷新界面的操作最好在主线程中完成&lt;/strong&gt;，那么我们来实验一下，如果将展示图片的操作交给子线程，会发生什么。&lt;strong&gt;首先我们创建一个 &lt;code&gt;UIImageView&lt;/code&gt; 并将它添加到 &lt;code&gt;UIViewController&lt;/code&gt;&lt;/strong&gt;，然后我们创建一个子线程：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; subThread = &lt;span class=&quot;type&quot;&gt;NSThread&lt;/span&gt;(target: &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, selector: #selector(&lt;span class=&quot;type&quot;&gt;ViewController&lt;/span&gt;.run(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt;:)), object: &lt;span class=&quot;string&quot;&gt;&quot;我是传入参数&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    subThread.start()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="线程通信" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
      <category term="ATS特性" scheme="http://yoursite.com/tags/ATS%E7%89%B9%E6%80%A7/"/>
    
      <category term="线程转跳" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E8%BD%AC%E8%B7%B3/"/>
    
  </entry>
  
  <entry>
    <title>Xcode错误 - No Such Module</title>
    <link href="http://yoursite.com/2016/07/21/Xcode%E9%94%99%E8%AF%AF%20-%20No%20Such%20Module/"/>
    <id>http://yoursite.com/2016/07/21/Xcode错误 - No Such Module/</id>
    <published>2016-07-20T20:43:00.000Z</published>
    <updated>2016-11-26T01:16:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>No.1 首先确保工程中有这个库；</p>
<p>No.2 进入 <code>Build Phases</code> 找到 <code>Link Binary With Libraries</code> ，添加这个库；</p>
<p>No.3 点击 <code>Build Phases</code> 页面左上角加号，点击 <code>New Copy Files Phase</code> ，名字改为 <code>Copy FrameWorks</code> ，<code>Destination</code> 设置为 <code>FrameWorks</code>，将这个库添加进来即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;No.1 首先确保工程中有这个库；&lt;/p&gt;
&lt;p&gt;No.2 进入 &lt;code&gt;Build Phases&lt;/code&gt; 找到 &lt;code&gt;Link Binary With Libraries&lt;/code&gt; ，添加这个库；&lt;/p&gt;
&lt;p&gt;No.3 点击 &lt;code&gt;Build 
    
    </summary>
    
      <category term="Xcode错误" scheme="http://yoursite.com/categories/Xcode%E9%94%99%E8%AF%AF/"/>
    
    
      <category term="Xcode错误" scheme="http://yoursite.com/tags/Xcode%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程 - 3种方式创建线程</title>
    <link href="http://yoursite.com/2016/06/21/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%203%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/06/21/iOS多线程之 3种方式创建线程/</id>
    <published>2016-06-21T01:33:00.000Z</published>
    <updated>2017-01-24T15:48:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先来看这个方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">detachNewThreadSelector</span>(<span class="title">selector</span>: <span class="title">Selector</span>, <span class="title">toTarget</span> <span class="title">target</span>: <span class="title">AnyObject</span>, <span class="title">withObject</span> <span class="title">argument</span>: <span class="title">AnyObject</span>?)</span></div></pre></td></tr></table></figure>
<p>下面这个是常见的 <code>init</code> 创建线程：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(target: <span class="type">AnyObject</span>, selector: <span class="type">Selector</span>, object argument: <span class="type">AnyObject</span>?)</div></pre></td></tr></table></figure>
<p>这两种创建方式有哪些不同呢？我们对比来看下：</p>
<blockquote>
<p><code>init</code> 是一个构造器，<code>detachNewThreadSelector</code> 是一个类型方法。<code>detachNewThreadSelector</code> 返回值是 <code>void</code>，也就是说没有返回值。<code>detachNewThreadSelector</code> 在调用后立即启动，不需要 <code>start</code> 方法。</p>
</blockquote>
<a id="more"></a>
<p>下面我们来使用这个方法，在 <code>TouchesBegan</code> 方法中写入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">NSThread</span>.detachNewThreadSelector(#selector(<span class="type">ViewController</span>.run), toTarget: <span class="keyword">self</span>, withObject: <span class="string">"detachNewThreadSelector"</span>)</div></pre></td></tr></table></figure>
<p>创建 <code>run</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(str: NSString)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(str)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们就可以调用这个线程了。</p>
<p><code>detachNewThread</code> 这个类型方法没有返回值，这意味着我们不能像使用 <code>init</code> 构造器创建那样，使用<code>start</code> <code>exit</code> <code>name</code> <code>stackSize</code> 那样控制线程启动、关闭、命名、获取栈大小，也无法使用 <code>currentThread</code>  <code>mainThread</code>  <code>isMainThread</code>  <code>threadPriority</code> 进行获取当前线程、获取主线程、指定优先级等操作。</p>
<p>最后一种方法是 <code>selectorInBackground</code> ，从名字可以看出来，这是在在后台执行一个相应函数，与 <code>deathNewThread</code> 和 <code>init</code> 不同，<code>selectorInbackground</code> 是 <code>Object</code> 的实例方法，没有返回值，因此它同样不能对线程进行控制。这个方法的表达式如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">performSelectorInBackground(#selector(<span class="type">ViewController</span>.run(<span class="number">_</span>:)), withObject: <span class="string">"SelectorInBackground"</span>)</div></pre></td></tr></table></figure>
<p>通过上面的对比，我们可以得出结论，同 <code>init</code> 这种方式对比，<code>detachNewThread</code> 和 <code>performSelectorBackgroud</code> 无法对创建的线程进行命名、比较、设定优先级等操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先来看这个方法：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;detachNewThreadSelector&lt;/span&gt;(&lt;span class=&quot;title&quot;&gt;selector&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;Selector&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;toTarget&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;target&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;AnyObject&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;withObject&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;argument&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;AnyObject&lt;/span&gt;?)&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面这个是常见的 &lt;code&gt;init&lt;/code&gt; 创建线程：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;convenience&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt;(target: &lt;span class=&quot;type&quot;&gt;AnyObject&lt;/span&gt;, selector: &lt;span class=&quot;type&quot;&gt;Selector&lt;/span&gt;, object argument: &lt;span class=&quot;type&quot;&gt;AnyObject&lt;/span&gt;?)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这两种创建方式有哪些不同呢？我们对比来看下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;init&lt;/code&gt; 是一个构造器，&lt;code&gt;detachNewThreadSelector&lt;/code&gt; 是一个类型方法。&lt;code&gt;detachNewThreadSelector&lt;/code&gt; 返回值是 &lt;code&gt;void&lt;/code&gt;，也就是说没有返回值。&lt;code&gt;detachNewThreadSelector&lt;/code&gt; 在调用后立即启动，不需要 &lt;code&gt;start&lt;/code&gt; 方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="开线程" scheme="http://yoursite.com/tags/%E5%BC%80%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="后台进程" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
</feed>
